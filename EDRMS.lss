%REM
	Library edrms
	Created Feb-April 2015 by Dominic Shields
	Description: Comments for Library
%END REM
Option Public
Option Declare
Use "logging"
' No front end classes declared globally  in case it interferes with background agents, prefix everything here with edrms to prevent
' scope errors
Const EDRMSSLVERSION$ = "Version 7 - 24/10/2017 10:00"     ' This indicates (if used properly) whether the correct version of the code is out there
Const DB_PROFILE_ERRORS = 1001
Const EDRMSTERM$ = "EDRMS"									                        ' What we refer to the system as
Const EDRMSSL$ = "edrms"									                                ' This Script Library Name
Const EDRMSPROFILENAME$ = "edrmsprofile"				                     ' EDRMS Database Profile form name
Const EDRMSBDBPROFILENAME$ = "BDBProfile"                             ' BDB Profile form name
Const EDRMSMETADBPROFILENAME$ = "edrms_email_profile"	 ' MetaDB Profile form name
Const EDRMSSYSTEMROLES$ = "[dbadmin]:[registrar]"		            ' Roles with special EDRMS Access
Const EDRMSREGISTRAR$ = "[registrar]"                                             ' Registrar
Const EDRMSDBADMIN$ = "[dbadmin]" 	                                             ' dbadmin
Const EDRMSADMINS$ = "Records Management"                              ' Informal name for  EDRMS Admins
Const EDRMSADMINSGROUP$ = "ERMS Admins"                              ' Notes Email/ACL group for EDRMS Admins
Const EDRMSDEVELOPERGROUP$ = "Dominic Shields"                 ' Simplifies testing certain functions
Const HELPDESK$ = "Service Desk"                                                       'Current Help desk system - changed from Assyst 19/09/2016
Const NAMESNSF$ = "names.nsf"	                                                          ' Notes NAB
Const LOOKUPNSF$ = "lookup.nsf"								                         ' ONS Lookup Database
Const EDRMSNCDKEY$ = "NCD"	                                                          ' Lookup Key for NCD
Const EDRMSMETADATADBKEY$ = "EDRMS MANAGEMENT DB"    ' Lookup key for Management/Metadata DB
Const EDRMSHOLDINGDBKEY$ = "EDRMS HOLDING DB"              ' Lookup key for Holding DB
Const EDRMSCOUNTSKEY$ = "EDRMS FILE COUNTS"                    ' Lookup key for File Counts (maybe not needed)
Const LOOKUPA1$ = "A1"										                                      ' ONS Lookup Database View
Const LOOKUPBDB$ = "A3"                                                                       ' BDB LOOKUP.NSF VIEW
Const EDRMSNCDVIEW$ = "pnn"                                                             ' NCD People by Notes Name Abbreviated
Const EDRMSNABALLNAMES$ = "(AllNames)"                                     ' NAB All Names view
Const EDRMSEXCEPTIONSVIEW$ = "(ERMS Exceptions)"                 ' View of  Databases marked as exceptions in Counts DB
Const EDRMSVIEWLOGDELETE$ = "EDRMSH1"                                  '(EDRMS Advice Logs for Deletion)
Const EDRMSVIEWLOGS$ = "EDRMSH2"                                                 '(EDRMS All Advice Logs)
Const EDRMSVIEWREVIEWEDREMAIN$ = "EDRMSH3"                      '(EDRMS Reviewed Records Remaining)
Const EDRMSVIEWFORREVIEW$ = "EDRMSH4"                                   '(EDRMS Records For Review)
Const EDRMSVIEWOLDUNDECLARED$ = "EDRMSH5"                      '(EDRMS Undeclared Documents More Than 1 Year Old 1)
Const EDRMSVIEWTOPLEVELRECS$ = "EDRMSH6"                           ' (EDRMS Records Top Level Only) 
Const EDRMSVIEWALLDOCSINSCOPE$ = "EDRMSH7"                     ' (EDRMS Docs In Scope No Hierarchy)
Const EDRMSVIEWALLUNDECLARED$ = "EDRMSH8"                        ' (EDRMS All Undeclared Documents) 
Const EDRMSVIEWALLDECLARED$ = "EDRMSH9"                               ' (EDRMS All Declared Documents) 
Const EDRMSVIEWDEFAULT$ = "EDRMS1"                                             'EDRMS\1. Everything     
Const EDRMSVIEWDECLARETODAY$ = "EDRMS2"                              ' EDRMS\Declare Today
Const EDRMSVIEWREBUILD1$ = "EDRMS3"                                         ' EDRMS\Undeclared Docs By Owner
Const EDRMSVIEWREBUILD2$ = "EDRMS4"                                         ' EDRMS\Declared Records For Review Current Year By BDB Categories
Const EDRMSVIEWREBUILD3$ = "EDRMS5"                                         ' EDRMS\Declared Records For Review Current Year By EDRMS Categories
Const EDRMSVIEWREBUILD4$ = "EDRMS6"                                         ' EDRMS\Undeclared Records To Be Advised
Const EDRMSVIEWREBUILD5$ = "EDRMS7"                                         ' EDRMS\Undeclared Records To Be Deleted
Const EDRMSVIEWTRANSFER$ = "EDRMS8"                                         ' EDRMS\Undeclared Records Ready for Transfer
Const EDRMSVIEWDELETED$ = "EDRMS9"                                           ' EDRMS\Undeclared Records Deleted Documents (Top Level)
Const EDRMSVIEWRECSNOTREQD$ = "EDRMS10"                            ' EDRMS\2. Declared Records Not Required 
Const EDRMSVIEWREASSIGNED$ = "EDRMS11"                                  ' EDRMS\1. Reassigned Documents
Const EDRMSVIEWAUTODECLARE$ = "EDRMSH10"                           ' (EDRMS Undeclared Documents Older Than Cutoff Auto Declare)
Const EDRMSVIEWAUTODELETE$ = "EDRMSH11"                               ' (EDRMS Undeclared Documents Older Than Cutoff Auto Delete)
Const EDRMSSECMARKING$ = "OFFICIAL SENSITIVE"                     ' Security Marking that can be involved
Const EDRMSTRANSFERSTATUS$ = "Ready for Transfer"
Const EDRMSAWDCAT$ = "Awaiting Deletion"                                        ' Awaiting Deletion Category Value
Const EDRMSAWDSUBCAT$ = "Documents awaiting deletion"          ' Awaiting Deletion SubCategory Value
Const EDRMSRESTCAT$ ="(Restored Documents)"                             ' A restored documents category
Const EDRMSDELETIONLOGFORM$ = "DelLog"                                  ' Deletion log form
Const EDRMSDELETIONADVICELOGFORM$ = "DelAdvice"              ' Deletion Advice log form
Const EDRMSLOG$ = "edrmslog"                                                              ' Audit log field name
Const EDRMSDELETELOG$ = "deletelog"                                              ' Delete log field name
Const EDRMSMAXREPSIZE& = 30000                                                     ' Maximum size of a report (bytes)
Const EDRMSCONFLICT$ = "$Conflict"                                                     ' Field that indicates a conflict doc
Const BFFIELD$ = "bfdate"                                                                           ' Defining the BF Field 19/09/2016
' Constants containg values of days/months/years to calculate for declaration limits/deadlines
'Const EDRMS7DAYS% = -7                                                                         ' (Negative) Normally days grace with certain date adjustments
'Const EDRMS9DAYS% = -9                                                                          ' (Negative) Normally days grace with certain date adjustments
Const EDRMS15DAYS% = 15                                                                      ' Fortnight-ish calculation
Const EDRMS6WEEKS% = 42                                                                    ' Six weeks date adjust
Const EDRMSMONTHS% = 6                                                                      ' Used in one agent to deal with versions
Const EDRMSINITMONTHS% = -24                                                           ' (Negative) Months from creation for default initial declaration
Const EDRMSMODIFIEDYEAR% = -1                                                        ' (Negative) Years we allow modifications to delay declaration
Const EDRMSCREATEDYEAR% = -2                                                        ' (Negative) Years absolute lmiit for delay between creation and declaration/removal
Const EDRMSCREATEDDAYS% = 730                                                    ' The EDRMSCREATEDYEAR% expressed as days
Const EDRMSMODIFIEDDAYS% = 365                                                    ' The EDRMSMODIFIEDYEAR% expressed as days     'rob 

Dim edrmssess As NotesSession
Dim edrmsdb As NotesDatabase
Dim edrmsmetadatadb As NotesDatabase
Dim edrmsholdingdb As NotesDatabase
Dim edrmscountsdb As NotesDatabase
Dim edrmslookupnsfdb As NotesDatabase
Dim edrmsncddb As NotesDatabase
Dim edrmsnabdb As NotesDatabase
Dim edrmsview As NotesView
Dim edrmslookupnsfview As NotesView
Dim edrmslookupbdbview As NotesView
Dim edrmsdc As NotesDocumentCollection
Dim edrmsdoc As NotesDocument
Dim edrmsprofiledoc As NotesDocument
Dim edrmsbdbprofiledoc As NotesDocument
Dim edrmsmetaprofiledoc As NotesDocument
Dim edrmscurrentuser As NotesName
Dim edrmsdbservernn As NotesName
Dim edrmsmasterservernn As NotesName
Dim edrmsprofileitem As NotesItem

Dim edrmsfields() As String
Dim edrmsinitialdeclaration() As String
Dim edrmserrorstub As String
Dim edrmserrortext As String
Dim edrmsdbeditor As String
Dim edrmsdbdelete As String
Dim edrmsdoceditor As String
Dim edrmslastglobalerr As String
Dim edrmsbdbtitle As String
Dim edrmsadminsgroupmember As String
Dim edrmspreventnewdocs As string

Dim edrmsrespcount As Integer
Dim edrmsuseraccesslevel As Integer
Dim edrmsoldsecmarking As Integer
Dim edrmsmaxdeclarelimit As Integer
Dim edrmsmaxmovelimit As Integer
Dim edrmsmaxreviewlimit As Integer
Dim edrmslimitedaccessflag As integer

Dim edrmscategories As Variant
Dim edrmsretention As Variant
Dim edrmsretval As Variant
Dim edrmsusernameslist As Variant
Dim edrmssortedarray As Variant

Sub Initialize
	On Error GoTo globalerrhandle
	Set edrmssess = New NotesSession
	Set edrmsdb = edrmssess.Currentdatabase

	edrmserrorstub = edrmsdb.Title & ". Script Library: " & EDRMSSL$ & ". Sub/function "
	edrmserrortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	
	Print edrmserrorstub & " " & edrmserrortext  & " " &  EDRMSSLVERSION$
	
	Set edrmsdbservernn = New NotesName(edrmsdb.server)
	Set edrmscurrentuser = New NotesName(edrmssess.Username)
	' Find current user access level to current Database
	Call edrms_get_db_access(edrmsdb,edrmsdbeditor,edrmsdbdelete,edrmsuseraccesslevel)

	' GET HANDLE ON BDB PROFILE, BETTER DOING IT ONCE
	Set edrmsbdbprofiledoc = edrmsdb.getprofiledocument(EDRMSBDBPROFILENAME$)
	If edrmsbdbprofiledoc Is Nothing Then
		If edrmssess.Isonserver Then     ' Check not running on server
			Print "Error: Unable to locate the BDB Profile for this database, exiting " & edrmserrorstub & edrmserrortext
			logaction("Error: Unable to locate the BDB Profile for this database, exiting " & edrmserrorstub & edrmserrortext)
		Else                                                            ' Put out a nicer log message
			MsgBox "Error: Unable to locate the BDB Profile for this database, exiting",16,edrmserrorstub & edrmserrortext
		End If
		Exit Sub
	End If

	' GET HANDLE ON LOOKUP.NSF IF ON SERVER, BETTER DOING IT ONCE
	If edrmsdb.server <> "" Then
		Set edrmslookupnsfdb = New NotesDatabase(edrmsdb.server,LOOKUPNSF$)
		If edrmslookupnsfdb Is Nothing Then
			If Not edrmssess.Isonserver Then     ' Check not running on server
				MsgBox "Error: Unable to locate the Notes lookup database, exiting",16,edrmserrorstub & edrmserrortext
			Else                                                            ' Put out a nicer log message
				Print "Error: Unable to locate the Notes lookup database, exiting " & edrmserrorstub & edrmserrortext
			End If
			Exit Sub
		End If
		Set edrmslookupnsfview = edrmslookupnsfdb.getview(LOOKUPA1$)
		Set edrmslookupbdbview = edrmslookupnsfdb.getview(LOOKUPBDB$)
 	End If

	' GET HANDLE ON EDRMS PROFILE, BETTER DOING IT ONCE
	Set edrmsprofiledoc = edrmsdb.getprofiledocument(EDRMSPROFILENAME$)
	If edrmsprofiledoc.hasitem("EDRMSMasterServer")  Then
		If  edrmsprofiledoc.EDRMSMasterServer(0) = ""  Then
			Call edrms_profile_setup   ' If not set up then get the values from the Management/Metadata DB
		End If
	Else
		Call edrms_profile_setup   ' If not set up then get the values from the Management/Metadata DB
	End If

	' GET EDRMS PROFILE DOC VALUES FROM THIS Database
	Set edrmsmasterservernn = New NotesName(edrmsprofiledoc.EDRMSMasterServer(0))
	edrmscategories = edrmsprofiledoc.EDRMSCategories
	edrmsretention = edrmsprofiledoc.EDRMSRetention
	edrmsmaxdeclarelimit = edrmsprofiledoc.EDRMSMaxDeclareLimit(0)
	edrmsmaxmovelimit = edrmsprofiledoc.EDRMSMaxMoveLimit(0)
	edrmsmaxreviewlimit = edrmsprofiledoc.EDRMSMaxReviewLimit(0)
	edrmsbdbtitle = edrmsprofiledoc.EDRMSBDBTitle(0)
	
	' GET BDB PROFILE DOC VALUES FROM THIS DATABASE
	edrmspreventnewdocs = edrmsbdbprofiledoc.preventnewdocs(0)	 

	' DO NOT CHANGE THE ORDER OF FIELD NAMES IN THESE ARRAYS ! ADD NEW ONES TO THE END
	ReDim edrmsfields(15)
	edrmsfields(0) = "edrmsrecord"
	edrmsfields(1) = "edrmsdate"
	edrmsfields(2) = "edrmsdeclaredby"
	edrmsfields(3) = "edrmscategory"
	edrmsfields(4) = "edrmsinitialdeclaration"
	edrmsfields(5) = "edrmsundeclarepending"
	edrmsfields(6) = "edrmsreviewdate"
	edrmsfields(7) = "edrmsreviewstatus"
	edrmsfields(8) = "edrmsdeleteversion"
	edrmsfields(9) = "edrmssourcebdbtitle"
	edrmsfields(10) = "edrmssourcebdbpath"
	edrmsfields(11) = "edrmsreviewedby"
	edrmsfields(12) = "edrmsreviewedbydate"
	edrmsfields(13) = "edrmsdelayedflag"
	edrmsfields(14) = "edrmstransferdate"
	edrmsfields(15) = "edrmsdeleteflag"

	' Tempting to put these in a profile but two objections to that.
	' They would need rolling out to every profile
	' If they are changed dynamically, the consequential code would need changing anyhow
	ReDim edrmsinitialdeclaration(3)
	edrmsinitialdeclaration(0) = "Automatically Declare"
	edrmsinitialdeclaration(1) = "Automatically Delete"
	edrmsinitialdeclaration(2) = "Decide when notified"
	edrmsinitialdeclaration(3) = "Declare overnight"

	Exit Sub
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrmserrortext
	Print Time$ & " " & edrmslastglobalerr
	Print Time$ & " " & "Check the database profile " & EDRMSPROFILENAME$ & " has all the necessary values and save it just in case"
	Error DB_PROFILE_ERRORS,"Error " & edrmslastglobalerr  & Chr(10) & "First check the database profile " & EDRMSPROFILENAME$ & " has all the necessary values and save it just in case"
	Exit Sub
End Sub
Sub edrms_undeclare_record(doc As NotesDocument,undeclaredby As String)
	On Error GoTo globalerrhandle
	Const MODE$ = "UNDECLARE"
	Dim ws As New NotesUIWorkspace
	Dim uidoc As NotesUIDocument
	Dim dcr As NotesDocumentCollection
	Dim edrms_undeclare_record_errortext As String

	edrms_undeclare_record_errortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	If(undeclaredby = "") Then
		undeclaredby = edrmscurrentuser.abbreviated
	End If

	edrmsrespcount=0
	Call edrms_undeclare_set_values(doc,undeclaredby)
	Set dcr = doc.Responses
	If dcr.count > 0 Then
		Call edrms_recurse_responses(doc, MODE$,"",undeclaredby,Date$,Nothing,Nothing,0,0)
	End If
	If Not ws.currentdocument Is Nothing Then  ' Allowing dual use from the open doc and from a collection of selected docs
		MessageBox "Undeclared document and " & CStr(edrmsrespcount) & " responses",64, edrmsdb.title &" " & EDRMSTERM$ & " Undeclaration"
		Call ws.currentdocument.close
		Set uidoc = ws.EditDocument(False,doc)
	End If
Exit Sub
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_undeclare_record_errortext
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Sub
End Sub
Sub edrms_agent_review_recs_not_reqd(Agent As NotesAgent)
	On Error GoTo errhandle
	Const MODE$ = "MARKREVIEW"
	Const REVIEWSTATUS$ = "Not Required"
	Const VERSIONVIEW1$ = "EDRMSV1"  'SELECT (Form = "Document":"Blanksheet":"ONSLetter") & ((Version = 0 & Provversionno > 0) | (Version > 0 & Provversionno = 0)) & EDRMSReviewStatus != "Ready for Transfer"
	Const VERSIONVIEW5$ = "EDRMSV5"  'SELECT (Form = "Document":"ONSLetter":"Blanksheet") & ((Version = 0 & Provversionno > 0) | (Version > 0 & Provversionno = 0)) & EDRMSReviewStatus != "Ready for Transfer"
	Dim ws As New NotesUIWorkspace
	Dim view As NotesView
	Dim view1 As NotesView
	Dim dcnotrequired As NotesDocumentCollection
	Dim versiondc As NotesDocumentCollection
	Dim doc As NotesDocument
	Dim editdoc As NotesDocument
	Dim copydoc As NotesDocument
	Dim newdoc As NotesDocument
	Dim origdoc As NotesDocument
	Dim uidoc As NotesUIDocument
	Dim msg As String
	Dim msg3 As String
	Dim selectstring As String
	Dim doclevel As String
	Dim	storedsubject As String
	Dim	storedversion As String
	Dim	storedclonedfrom As String
	Dim searchkey As String
	Dim editoraccess As string
	Dim responseflag As Integer
	Dim recordflag As Integer
	Dim editorlevel As Integer
	Dim versiontype As Integer
	Dim removefromcollection As Integer
	Dim	storedversionno As Integer
	Dim returncode As Integer
	Dim errorcnt As Integer
	Dim delayedflag As integer
	Dim responsereviewed As Long
	Dim reviewed As Long
	Dim replyval As Variant

	responseflag = 0
	editorlevel = 0
	recordflag = 0
	reviewed = 0
	responsereviewed = 0
	errorcnt = 0
	returncode = 0
	delayedflag = 0

	edrmserrortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	Call initlog(agent.name)
	Set edrmsdc = edrmsdb.unprocesseddocuments
	
	' Firstly check that the user is eligible editor to the top level docs
	logaction("Check that the user is eligible editor to the top level docs")
	Set doc = edrmsdc.getfirstdocument

	While Not doc Is Nothing
		If Not doc.Isresponse Then
			logaction("Main Document subject: " & doc.subject(0)) 
			editoraccess = ""
			Call edrms_get_doc_access(doc,editoraccess)
			If editoraccess <> "Yes" Then
				msg3 = "You are not an eligible editor of all the top-level selected documents, you need either higher database access or to be a named editor of the documents"
				MessageBox msg3 ,16, edrmsdb.title &" " & EDRMSTERM$ & " Access Error"
				logclose("User informed " & msg3)
				Exit Sub
			End If
		End If
		Set doc=edrmsdc.GetNextDocument(doc)
	Wend

	logaction("Calling sub edrms_review_checks which performs checks on selected docs and their responses")
	Call edrms_review_checks(edrmsdc,REVIEWSTATUS$,returncode,editorlevel)
	If returncode > 0 Then
		logclose("Returned from edrms_review_checks with exit code " & CStr(returncode) & " user will have been informed why, exiting")
		Exit Sub
	End If

	logaction("Main processing loop - a lot of versioning checks")
	Set doc = edrmsdc.getfirstdocument
	While Not doc Is Nothing

		If doc.HasItem("version") Then ' This line added 07/03/12 Assyst call R229046
			If doc.version(0) > 0 Then
				Set view=edrmsdb.GetView(VERSIONVIEW1$)
				Set view1=edrmsdb.GetView(VERSIONVIEW5$)
				versiontype = 0                            ' 1 = top of chain, 2 = middle, 3 = bottom of chain, 4 = breaks chain
				removefromcollection = 0
				If doc.clonedfrom(0) <> "" And doc.clonedto(0) = "" Then ' Document top of the versioning chain
					On Error 4091 Resume Next
					Set origdoc = edrmsdb.getdocumentbyunid(doc.clonedfrom(0))
					Set versiondc=view.GetAllDocumentsByKey(doc.cloneref(0),True)
					If versiondc.Count = 2 Then
						versiontype = 4
						If Not origdoc Is Nothing Then
							origdoc.clonedto = ""
							origdoc.version = 0
							origdoc.versionno = 0
						End If

						Set copydoc = New NotesDocument(edrmsdb)
						Call doc.CopyAllItems(copydoc,True)

' Check if the document being deleted is the master clone record. If it isn't, then it needs switching to preserve any doc links...

						If doc.cloneref(0) = doc.UniversalID And Not origdoc Is Nothing Then
							Call origdoc.CopyAllItems(doc,True)
							origdoc.edrmsreviewstatus = EDRMSTRANSFERSTATUS$
							origdoc.edrmsdeleteversion = "Yes"
							Call origdoc.Save(True,True)
							removefromcollection = 1
						End If
						Call doc.Save(True,True)
					Else
						versiontype = 1

						On Error 4091 Resume Next
						Set origdoc = edrmsdb.getdocumentbyunid(doc.clonedfrom(0))
						If Not origdoc Is Nothing Then
							storedsubject = origdoc.subject(0)
							storedversion = origdoc.version(0)
							storedversionno = origdoc.versionno(0)
							storedclonedfrom = origdoc.clonedfrom(0)
							Set copydoc = New NotesDocument(edrmsdb)
							Call doc.CopyAllItems(copydoc,True)
							Call origdoc.CopyAllItems(doc,True)
							doc.clonedto = ""
							origdoc.edrmsreviewstatus = EDRMSTRANSFERSTATUS$
							origdoc.edrmsdeleteversion = "Yes"
							Call origdoc.Save(True,True)
							Call doc.Save(True,True)
							removefromcollection = 1
						End If
					End If

				ElseIf doc.clonedto(0) <> "" And doc.clonedfrom(0) <> "" Then ' Document middle of the versioning chain
					On Error 4091 Resume Next
					Set origdoc = edrmsdb.getdocumentbyunid(doc.clonedfrom(0))
					Set newdoc = edrmsdb.getdocumentbyunid(doc.clonedto(0))
					If Not origdoc Is Nothing And Not newdoc Is Nothing Then
						versiontype =  2
						origdoc.clonedto = doc.clonedto(0)
						newdoc.clonedfrom = doc.clonedfrom(0)
						Call origdoc.Save(True,True)
						Call newdoc.Save(True,True)
					End If

				ElseIf doc.clonedto(0) <> "" And doc.clonedfrom(0) = "" Then ' Document bottom of the versioning chain
					searchkey = doc.Universalid
					Set newdoc = view1.getdocumentbykey(searchkey,True)
' Check to see if this deletion breaks the versioning chain...
					Set versiondc=view.GetAllDocumentsByKey(doc.cloneref(0),True)
					If versiondc.Count = 2 Then
						versiontype = 4
					Else
						versiontype =  3
					End If
					If versiontype = 4 Then
						newdoc.clonedto = ""
						newdoc.version = 0
						newdoc.versionno = 0
						newdoc.clonedfrom = ""
					Else
						newdoc.clonedfrom = ""
					End If
					Call newdoc.Save(True,True)
				End If
			End If
		End If

		If  removefromcollection = 0 Then
			Set editdoc = doc
		Else
			Set editdoc = copydoc
			doc.clonedfrom = storedclonedfrom
			Call doc.Save(True,True)
			removefromcollection = 0
		End If

		editdoc.edrmssourcebdbtitle = edrmsdb.Title
		editdoc.edrmssourcebdbpath = edrmsdb.filepath
		Call edrms_mark_review_status(editdoc,REVIEWSTATUS$,reviewed,edrmscurrentuser.abbreviated,"","")
		logaction("Main doc marked as " & REVIEWSTATUS$  &" " &  editdoc.subject(0))

' RECURSE RESPONSES HERE
		If editorlevel = 0 Then           ' Current user is eligible editor to all responses
			logaction("Recursing response thread")
			edrmslimitedaccessflag = 0
			Call edrms_recurse_responses(editdoc,MODE$,REVIEWSTATUS$,edrmscurrentuser.abbreviated,"",Nothing,Nothing,responsereviewed,errorcnt)
			If edrmslimitedaccessflag = 1 Then
				editdoc.edrmsdelayedflag = 3
				editdoc.edrmsreviewstatus = EDRMSTRANSFERSTATUS$
				Call editdoc.save(True,True)
				Call logaction(editdoc.subject(0) & " has limited access responses which will need updating overnight, delayed flag set")
				delayedflag = 1               ' Indicates to the code below that there is not full author access
			End If
		Else
			logaction("User does not have high enough access to recurse response thread so delayed flag set")
			editdoc.edrmsdelayedflag = 3
		    editdoc.edrmsreviewstatus = EDRMSTRANSFERSTATUS$
			Call editdoc.save(True,True)
			delayedflag = 1               ' Indicates to the code below that there is not full author access
		End If

		Set doc=edrmsdc.GetNextDocument(doc)
	Wend

	Call edrms_review_report(REVIEWSTATUS$,responsereviewed,errorcnt,reviewed,msg)   ' THIS STATUS AND THE SUB CALLED NEEDS EXAMINING FOR INCONSISTENCIES

	logaction("User Messagebox : " & msg)

' If the user has author access to all docs Move marked documents from this view to a holding view, ready for the agent to move the record to the edrms Management database
	If delayedflag = 0 then
		selectstring = "edrmsreviewstatus = """  & REVIEWSTATUS$ & """"
		logaction("Setting the dcnotrequired documentcollection with query " & selectstring)
		Set dcnotrequired = edrmsdb.search (selectstring$,Nothing,0)
		If dcnotrequired.count > 0 Then
			logaction("Updating the dcnotrequired documentcollection which contains " & CStr(dcnotrequired.count) & " documents, setting field edrmsreviewstatus to " & EDRMSTRANSFERSTATUS$ & " where user is eligible author")
			Set doc = dcnotrequired.getfirstdocument
			While Not doc Is Nothing
				Call edrms_get_doc_access(doc,editoraccess)
				If editoraccess = "Yes" Then
					doc.edrmsreviewstatus = EDRMSTRANSFERSTATUS$
					doc.save false,False
				End if
				Set doc = dcnotrequired.getnextdocument(doc)
			Wend
		End If
	Else
		logaction("Current user does not have author access to update all docs in the documentcollection or there are limited access responses they cannot access " & selectstring)
		logaction("Processing all " & CStr(edrmsdc.count) & "  top level documents in the collection to ensure they have the delayed flag set to 3") 
		Set doc = edrmsdc.getfirstdocument
		While Not doc Is Nothing
			Call edrms_get_doc_access(doc,editoraccess)
			If editoraccess = "Yes" Then
				doc.edrmsreviewstatus = EDRMSTRANSFERSTATUS$
				doc.edrmsdelayedflag = 3
				doc.save False,False
			End If
			Set doc = edrmsdc.getnextdocument(doc)
		Wend
	End if

	If doclevel = "Yes" Then
		Set uidoc=ws.currentdocument
		Call uidoc.close
	Else
		Call edrms_deselect_docs(ws)
	End If
	
	Call ws.viewrefresh

	Call logclose("Ends OK")

Exit Sub
errhandle:
Call logerror(Err, Error, Erl, LSI_Info(2), LSI_Info(12), " Last module before this call " & edrmserrortext )   ' LOGS HELPFUL DETAIL ON AN ERROR
Call logaction(" Last Global Error " & edrmslastglobalerr)
Call alerterrors(agent.name ,"Error")     ' EMAILS THE ERROR ALERT TO ADDRESS IN PROFILE
Exit Sub
End Sub
Sub edrms_agent_review_advice_only(Agent As NotesAgent)
	' This processes documents in the view pointed to by global constant EDRMSVIEWFORREVIEW$ which selects the documents in scope
	' Converted Email Text Lookups to profile on Management DB
	' Extensively rewritten to handle people who are still ONS Staff but the names on the declared record are not the current ONS hierarchy of SITE/ONS DJS 17/12/2015 
	On Error GoTo errhandle
	Const NABFN$ = "FN"
	Const COUNTSFORM$ = "EDRMS Count"
	Dim view As NotesView
	Dim metadataview As NotesView
	Dim ncdview As NotesView
	Dim nabview As NotesView
	Dim checknabview As NotesView
	Dim checknabvc As NotesViewEntryCollection
	Dim nabdc As NotesDocumentCollection
	Dim doc As NotesDocument
	Dim doc1 As NotesDocument
	Dim countdoc As NotesDocument
	Dim nabdoc As NotesDocument
	Dim notifymail As NotesDocument
	Dim notifymailnoncd As NotesDocument
	Dim repdoc As NotesDocument
	Dim checknabdoc As NotesDocument
	Dim acl As NotesACL
	Dim getentry As NotesACLEntry
	Dim rtitem As NotesRichTextItem
	Dim rtitem1 As NotesRichTextItem
	Dim repitem As NotesItem
	Dim rsnormal As NotesRichTextStyle
	Dim rs1 As NotesRichTextStyle
	Dim rs2 As NotesRichTextStyle
	Dim rs3 As NotesRichTextStyle
	Dim rolename As NotesName
	Dim storedname As NotesName
	Dim name2 As NotesName
	Dim ncdname As NotesName
	Dim checkauthor As NotesName
	Dim namefieldout As NotesName
	Dim sendto() As string
	Dim edrmsview As String
	Dim staffreplist As String		 'for list of people who had emails sent to them for deletion report
	Dim storesreplist As String		 'for list of people who could not be found on NCD so email was sent to Stores/[Registrar] role for deletion report
	Dim regrolelist As String		 ' for list of people who hold registrar role
	Dim groupname As String
	Dim selectstring As String
	Dim storedsubject As String
	Dim whosdocs As String
	Dim subject As String
	Dim xsubject As String
	Dim emailtext As String
	Dim aclcount As Integer
	Dim a As Integer
	Dim runtype As Integer
	Dim sent As Integer
	Dim advicecount As Integer
	Dim loggednotnab As Integer
	Dim advicecountreassign As Integer
	Dim advicecountnoncd As Integer
	Dim emailssent As Integer
	Dim emailssentnoncd As Integer
	Dim docsadvised As Integer
	Dim docsadvisednoncd As Integer
	Dim itemcount As Integer
	Dim itemcountnoncd As Integer
	Dim registrarflag  As Integer
	Dim notonnab As Integer
	Dim reassignflag As Integer
	Dim owneddocs As Integer
	Dim helperdbsret As Integer
	Dim replyval As Variant
	Dim continue As Boolean

	staffreplist = ""
	storesreplist = ""
	regrolelist = ""
	aclcount = 0
	a = 0
	sent = 0
	advicecount = 0
	advicecountreassign = 0
	advicecountnoncd = 0
	emailssent = 0
	docsadvised = 0
	docsadvisednoncd = 0
	emailssentnoncd = 0

	If edrmssess.Isonserver Then
		If (edrmsdbservernn.common <> edrmsmasterservernn.common) Then
			Exit Sub   ' When run scheduled, not on master server so exit
		End If
	End If

	edrmserrortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	Call initlog(agent.name)

	' Call the function that gets the required external DBS
	logaction("Getting DB handles to edrmsncddb, edrmsnabdb, edrmsmetadatadb, edrmsholdingdb, edrmscountsdb")
	helperdbsret = edrms_get_helper_dbs
	If helperdbsret > 0 Then
		logaction("Error getting one or more of the required external databases,  check the Lookup.nsf and the default accesses to these DBs, error code = " & CStr(helperdbsret))
		logaction("Error codes: NCD = 99, NAB = 98, EDRMS Management DB = 97, EDRMS Holding DB = 96, EDRMS Counts DB = 95")
		Call alerterrors(agent.name ,"Error with external databases, error code " & CStr(helperdbsret))
		Exit Sub
	End If

	Set nabview = edrmsnabdb.getview(EDRMSNABALLNAMES$)
	If nabview Is Nothing Then
		logaction("Error getting " & edrmsnabdb.title & " view " & EDRMSNABALLNAMES$)
		Exit Sub
	End If

	Set checknabview = edrmsnabdb.GetView(NABFN$)
	If checknabview Is Nothing Then
		logaction("Error getting " & edrmsnabdb.title & " view " & NABFN$)
		Exit Sub
	End If

	Set ncdview = edrmsncddb.getview(EDRMSNCDVIEW$)
	If ncdview Is Nothing Then
		logaction("Error getting " & edrmsncddb.title & " view " & EDRMSNCDVIEW$)
		Exit Sub
	End If

	Set view = edrmsdb.getview(EDRMSVIEWFORREVIEW$)

	logaction(view.name & " contains " & CStr( view.Toplevelentrycount) & " documents")

	Set doc = view.getfirstdocument       ' Read ahead - note this for later

	GoSub setupreport     ' Note that the agent can exit in this subroutine if no docs to process so will not necessarily return from there

	GoSub setupemail     ' Set up the email layout

	reDim sendto(0)
	Call edrms_examine_acl_roles(ncdview,repitem,EDRMSREGISTRAR$,sendto,regrolelist)  ' get the list of DB registrars
	If ubound(sendto) = 0 And sendto(UBound(sendto)) = "" Then
		logaction("Error after Call edrms_examine_acl_roles - there were no people on the ACL with the " & EDRMSREGISTRAR$ & " role, adding " & EDRMSADMINSGROUP$ & " so that processing can continue")
		sendto(0) =  EDRMSADMINSGROUP$
	End If

	If(regrolelist <> "") Then                                                                                                                      ' Indicating use Registrars List
		logaction("Database Registrars ACL Role held by the following people " & regrolelist)   ' Indicating use Registrars List
		logaction("sendto variable contains " & CStr(UBound(sendto)) & " elements")                   ' Indicating use Registrars List
		aclcount = 1						                                                                                                                 ' Indicating use Registrars List
	End If

	logaction("Setup complete, checking whether run by user or scheduled")

	If edrmssess.Isonserver Then
		runtype = 6  										 ' Setting the variable indicating Live Run
		logaction("Running scheduled")
	Else
		Call edrms_user_live_test_prompt(view,name2,runtype,continue)
		If continue = False Then
			logclose("Run Ends, user aborted")
			Exit Sub
		End If
	End If

	Set doc1 = doc                                       ' setting another handle to the first read doc in the view
	storedsubject = doc.subject(0)

	If doc.Reassign_To(0) = "" Then
		whosdocs = doc.permanentauthor(0)
	Else
		whosdocs = doc.Reassign_To(0)
	End If

	Set storedname = New NotesName(whosdocs)
	If storedname.common = "" Then
		Set storedname = New NotesName(doc.authors(0))   ' Added for documents where PermanentAuthor field is not present...
	End If

	itemcount = 1
	itemcountnoncd = 0
	Set doc=view.getnextdocument(doc)
	While Not doc Is Nothing

		' Check that doc creator still on NAB
		If doc.Reassign_To(0) = "" Then
			Set ncdname = New NotesName(doc.permanentauthor(0))
		Else
			Set ncdname = New NotesName(doc.Reassign_To(0))
		End If

		If ncdname.common = "" Then
			Set ncdname = New NotesName(doc.authors(0))       		' Added for documents where PermanentAuthor field is not present...
		End If

		notonnab = 0
		Set nabdoc = nabview.getdocumentbykey(ncdname.canonical,True)           ' EDRMSNABALLNAMES$ = "(AllNames)"  NAB All Names view
		If nabdoc Is Nothing Then
			notonnab = 1
			If loggednotnab = 0 Then
				logaction("Not found on NAB " & ncdname.abbreviated)    ' we only want this message once
				loggednotnab = 1
			End If
		Else
			loggednotnab = 0
			If Left(ncdname.common,3) = "Fax" And Right(ncdname.common,7) = "Gateway" Then
				notonnab = 1
			End If
		End If

		If doc.Reassign_To(0) = "" Then
			If doc.permanentauthor(0) <> "" Then
				Set checkauthor = New NotesName(doc.permanentauthor(0))
			Else
				Set checkauthor = New NotesName(doc.authors(0))
			End If
		Else
			Set checkauthor = New NotesName(doc.Reassign_To(0))
		End If

		'		If checkauthor.abbreviated = storedname.abbreviated Then ' multiple entries
		If checkauthor.common = storedname.common Then ' multiple entries
			If notonnab = 1 Then
				GoSub write_doc_line_noncd_multi
			Else
				If itemcount = 1 Then ' write header and first software line
					Set notifymail = New NotesDocument(edrmsdb)
					notifymail.importance = "1"
					Set rtitem = New NotesRichTextItem( notifymail, "Body" )
					GoSub write_header_line
					GoSub write_doc_line
				Else ' just write current name line
					GoSub write_doc_line
				End If
			End If
		Else ' single name or end of multi name

			' temp NCD recheck on doc1...
			loggednotnab = 0
			If doc1.Reassign_To(0) = "" Then
				Set ncdname = New NotesName(doc1.permanentauthor(0))
			Else
				Set ncdname = New NotesName(doc1.Reassign_To(0))
			End If

			' Added for documents where PermanentAuthor field is not present...
			If ncdname.common = "" Then
				Set ncdname = New NotesName(doc1.authors(0))
			End If

			notonnab = 0
			Set nabdoc=nabview.getdocumentbykey(ncdname.canonical,True)       ' EDRMSNABALLNAMES$ = "(AllNames)"  NAB All Names view
			If nabdoc Is Nothing Then
				notonnab = 1
			Else
				If Left(ncdname.common,3) = "Fax" And Right(ncdname.common,7) = "Gateway" Then
					notonnab = 1
				End If
			End If

			If notonnab = 1 Then
				GoSub write_doc_line_noncd
				If doc.Reassign_To(0) = "" Then
					whosdocs = doc.permanentauthor(0)
				Else
					whosdocs = doc.Reassign_To(0)
				End If

				Set storedname = New NotesName(whosdocs)
				storedsubject = doc.subject(0)

				' Added for documents where PermanentAuthor field is not present...
				If storedname.common = "" Then
					Set storedname = New NotesName(doc.authors(0))
				End If

			Else
				If itemcount = 1 Then ' single item
					Set notifymail = New NotesDocument(edrmsdb)
					notifymail.importance = "1"
					Set rtitem = New NotesRichTextItem( notifymail, "Body" )
					GoSub write_header_line
					GoSub write_doc_line

				Else ' add the last line in and send the email
					GoSub write_doc_line
				End If

				notifymail.Subject = subject

				registrarflag  = 0
				Set nabdoc = nabview.GetDocumentByKey(storedname.canonical,True)                    ' EDRMSNABALLNAMES$ = "(AllNames)"  NAB All Names view
				If nabdoc Is Nothing Then
					notonnab = 1
					logaction("Failed to find " & storedname.canonical & " on the NAB, substituting with database registrars " & regrolelist)
					notifymail.sendto = SendTo()
					notifymail.Subject = subject & " Intended Addressee not found " & storedname.Abbreviated     ' indicate to registrars who this should be for
					registrarflag  = 1
				Else
					Set namefieldout = New NotesName(nabdoc.owner(UBound(nabdoc.owner)))
					notifymail.sendto = namefieldout.abbreviated
				End If

				notifymail.principal = EDRMSADMINSGROUP$
				notifymail.displaysent = "Scheduled agent. Please do not respond."

				GoSub write_body

				If runtype = 7 Then                       ' TEST MODE
					Call rtitem.AddNewLine( 2 )
					Call rtitem.appendstyle(rs3)
					If registrarflag  = 1 Then      ' NAB Failure above
						Call rtitem.AppendText("(In live situation, this email would be redirected to the registrars " & regrolelist)
						logaction("In live situation, this email would be redirected to the registrars " & regrolelist)
						notifymail.Subject = subject & "  Addressee in a Live Run: " & regrolelist
					Else
						Call rtitem.AppendText("(In live situation, this email would go to " & namefieldout.abbreviated)
						logaction("In live situation, this email would go to " & namefieldout.abbreviated)
						notifymail.Subject = subject & "  Addressee in a Live Run: " & namefieldout.abbreviated
					End If
					notifymail.sendto = name2.abbreviated          ' MAIL ADDRESSED TO TEST RECIPIENT  IN TEST MODE
				End If

				emailssent = emailssent + 1
				logaction("Sending mail to " & notifymail.sendto(0))
				Call notifymail.Send( False )           ' MAIL SENT HERE

				If doc.Reassign_To(0) = "" Then
					whosdocs = doc.permanentauthor(0)
				Else
					whosdocs = doc.Reassign_To(0)
				End If

				Set storedname = New NotesName(whosdocs)
				storedsubject = doc.subject(0)

				If storedname.common = "" Then
					Set storedname = New NotesName(doc.authors(0))    				' Added for documents where PermanentAuthor field is not present...
				End If

				sent = sent + 1
				itemcount = 1
			End If
		End If

		Set doc1=doc
		Set doc=view.getnextdocument(doc)

	Wend
endlab:
	' Send the final emails

	' Send normal email - don't send if last record not on NAB

	notonnab = 0
	Set nabdoc=nabview.getdocumentbykey(storedname.canonical,True)                   ' EDRMSNABALLNAMES$ = "(AllNames)"  NAB All Names view
	If nabdoc Is Nothing Then
		notonnab = 1
		If loggednotnab = 0 Then
			logaction("Not found on NAB " & storedname.abbreviated)
		End If
	Else
		If Left(ncdname.common,3) = "Fax" And Right(ncdname.common,7) = "Gateway" Then
			notonnab = 1
		End If
	End If

	If notonnab = 0 Then
		If itemcount = 1 Then
			Set notifymail = New NotesDocument(edrmsdb)
			notifymail.importance = "1"
			Set rtitem = New NotesRichTextItem( notifymail, "Body" )
			GoSub write_header_line
			GoSub write_doc_line
		Else
			GoSub write_doc_line
		End If

		notifymail.Subject = subject
		Set nabdoc=nabview.GetDocumentByKey(storedname.canonical,True)
		Set namefieldout = New NotesName(nabdoc.owner(UBound(nabdoc.owner)))
		notifymail.sendto = namefieldout.abbreviated
		notifymail.principal = EDRMSADMINSGROUP$
		notifymail.displaysent = "Scheduled agent. Please do not respond."
		Call rtitem.AddNewLine( 1 )
		GoSub write_body

		If runtype = 7 Then
			Call rtitem.AddNewLine( 2 )
			Call rtitem.appendstyle(rs3)
			Call rtitem.AppendText("(In live situation, this email would go to " + storedname.common + ")")
			logaction("FINAL EMAIL: In live situation, this email would go to " & storedname.common)
			notifymail.sendto = name2.abbreviated
		End If

		emailssent = emailssent + 1
		logaction("Sending final mail to " & notifymail.sendto(0))
		Call notifymail.Send( False )                                                 ' MAIL SENT HERE
		sent = sent + 1
	End If

	' If the last document relates to someone not on NCD, write details of that record

	If doc1.Reassign_To(0) = "" Then
		whosdocs = doc1.permanentauthor(0)
	Else
		whosdocs = doc1.Reassign_To(0)
	End If

	Set ncdname = New NotesName(whosdocs)

	If ncdname.common = "" Then
		Set ncdname = New NotesName(doc1.authors(0))
	End If

	Set nabdoc = nabview.getdocumentbykey(storedname.canonical,True)                    ' EDRMSNABALLNAMES$ = "(AllNames)"  NAB All Names view

	If nabdoc Is Nothing Then
		notonnab = 1
		GoSub write_doc_line_noncd
	End If

	If itemcountnoncd > 0 Then
		If runtype = 6 Then
			If aclcount = 0 Then
				' nobody on acl with [registrar] - live run - send to Admins
				notifymailnoncd.SendTo = EDRMSADMINSGROUP$
			Else
				notifymailnoncd.SendTo = SendTo()                                      ' This is the array of registrars passed out of edrms_examine_acl_roles
				logaction("Addressing email to registrars: " & regrolelist)
			End If
		Else	'test run
			If aclcount = 0 Then
				' nobody on acl with [registrar] - test run - send to selected name
				notifymailnoncd.SendTo = name2.common
			Else
				notifymailnoncd.SendTo = name2.common
			End If
		End If

		notifymailnoncd.principal = EDRMSADMINSGROUP$
		notifymailnoncd.displaysent = "Scheduled agent. Please do not respond."
		Call rtitem1.AddNewLine( 1 )

		Call rtitem1.AppendStyle(rsnormal)

		If docsadvisednoncd > 1 Then
			Call rtitem1.appendtext("These " + CStr(docsadvisednoncd) + " records are due for review on this BDB " & edrmsdb.Title & " ===> ")
		Else
			Call rtitem1.appendtext("This record is due for review on this BDB " & edrmsdb.Title & " ===> ")
		End If
		Call rtitem1.AppendDocLink(edrmsdb,edrmsdb.Title)
		Call rtitem1.addnewline(2)

		Call rtitem1.AppendText(edrmsmetaprofiledoc.regemailtext2(0))

		If runtype = 7 Then
			Call rtitem1.AddNewLine( 2 )
			Call rtitem1.appendstyle(rs3)
			Call rtitem1.AppendText("(In live situation, this email would go to Database Registrar(s) " + regrolelist$ + ")")
		End If

		emailssentnoncd = emailssentnoncd + 1
		logaction("Sending mail about not found on NAB to " & notifymailnoncd.sendto(0))
		Call notifymailnoncd.Send( False )          ' MAIL SEND
		sent = sent + 1
	End If

	If staffreplist$ = "" Then
		staffreplist$ = "No staff notification emails sent"
	End If

	If aclcount = 0 Then ' nobody on acl with [registrar]
		repdoc.StaffDetails = staffreplist$
		repdoc.StoresDetails = storesreplist$
		Call repdoc.save(True,False)
	Else
		repdoc.StaffDetails = staffreplist$
		repdoc.RoleDetails = storesreplist$
		Call repdoc.save(True,False)
	End If

	emailtext = " email(s) sent"

	logaction("End of advice run. " + CStr(sent) & emailtext)

	repdoc.emailssent = CStr(emailssent)
	repdoc.docsadvised = CStr(docsadvised)

	If repdoc.roleholders(0) = "" Then
		repdoc.docsadvisednoncd = "0"
		repdoc.docsadvisednoncdnoregistrar = CStr(docsadvisednoncd)
	Else
		repdoc.docsadvisednoncdnoregistrar = "0"
		repdoc.docsadvisednoncd = CStr(docsadvisednoncd)
	End If

	Call repdoc.save(True,True)

	' Log counts to the EDRMS Management Database

	Set countdoc = New NotesDocument(edrmsmetadatadb)
	countdoc.form = COUNTSFORM$
	countdoc.BDBName = edrmsdb.Title
	countdoc.emailssent = CStr(emailssent)
	countdoc.emailssentEDRMS = "0"
	countdoc.emailssentreg = "0"
	If repdoc.RoleDetails(0) <> "" Then
		countdoc.emailssentreg = "1"
		countdoc.emailssentEDRMS = "0"
	End If
	If repdoc.StoresDetails(0) <> "" Then
		countdoc.emailssentEDRMS = "1"
		countdoc.emailssentreg = "0"
	End If
	countdoc.docsadvised = CStr(docsadvised)
	If repdoc.roleholders(0) = "" Then
		countdoc.edrmsadminsadvised = CStr(docsadvisednoncd)
		countdoc.noncddocsadvised = 0
	Else
		countdoc.noncddocsadvised = CStr(docsadvisednoncd)
		countdoc.edrmsadminsadvised = 0
	End If
	Call countdoc.Save(True,True)

	Call logclose("")

	Exit Sub

write_header_line:

	reassignflag = 0
	owneddocs = 0
	Return

write_doc_line_noncd:
	Call rtitem1.AppendStyle(rsnormal)
	itemcountnoncd = itemcountnoncd + 1
	advicecountnoncd = advicecountnoncd + 1

	If storedname.common <> "" Then
		whosdocs = storedname.common
	Else
		whosdocs = "Uncategorised Documents"
	End If
	storesreplist$ = storesreplist$ + whosdocs + " (" + CStr(advicecountnoncd) + ")" + Chr(10)
	Call rtitem1.AppendStyle(rs1)

	If storedname.common <> "" Then
		Call rtitem1.AppendText(StoredName.common + " has ")
	End If
	Call rtitem1.AppendStyle(rs2)
	Call rtitem1.appendtext(CStr(advicecountnoncd))
	Call rtitem1.AppendStyle(rs1)
	If advicecountnoncd > 1 Then
		If storedname.common <> "" Then
			Call rtitem1.appendtext (" documents")
		Else
			Call rtitem1.appendtext (" uncategorised documents")
		End If
	Else
		If storedname.common <> "" Then
			Call rtitem1.appendtext (" document")
		Else
			Call rtitem1.appendtext (" uncategorised document")
		End If
	End If
	Call rtitem1.AppendStyle(rsnormal)
	docsadvisednoncd = docsadvisednoncd + 1

	Call rtitem1.addnewline(1)
	advicecountnoncd = 0

	Return

write_doc_line_noncd_multi:

	advicecountnoncd = advicecountnoncd + 1
	docsadvisednoncd = docsadvisednoncd + 1
	Return

write_doc_line:

	Call rtitem.AppendStyle(rsnormal)
	itemcount = itemcount + 1
	docsadvised = docsadvised + 1
	If doc1.Reassign_To(0) = "" Then
		advicecount = advicecount + 1
	Else
		advicecountreassign = advicecountreassign + 1
	End If

	Return

write_body:

	Call rtitem.AppendText(edrmsmetaprofiledoc.emailtext1(0))
	Call rtitem.addnewline(2)
	Call rtitem.AppendStyle(rs1)
	Call rtitem.AppendText("You have ")
	Call rtitem.AppendStyle(rs2)
	Call rtitem.AppendText(CStr(advicecount))
	Call rtitem.AppendStyle(rs1)

	If advicecount = 0 Or advicecount > 1 Then
		If advicecountreassign > 0 Then
			Call rtitem.AppendText(" records on the " + edrmsdb.title + " database which you created")
		Else
			Call rtitem.AppendText(" records on the " + edrmsdb.title + " database")
		End If
	Else
		If advicecountreassign = 1 Then
			Call rtitem.AppendText(" record on the " + edrmsdb.title + " database which you created")
		Else
			Call rtitem.AppendText(" record on the " + edrmsdb.title + " database")
		End If
	End If

	If advicecountreassign > 0 Then
		Call rtitem.addnewline(2)
		Call rtitem.AppendStyle(rs1)
		Call rtitem.AppendText("You have ")
		Call rtitem.AppendStyle(rs2)
		Call rtitem.AppendText(CStr(advicecountreassign))
		Call rtitem.AppendStyle(rs1)
		If advicecountreassign > 1 Then
			Call rtitem.AppendText(" records on the " + edrmsdb.title + " database which were created by someone else and which have been assigned to you")
		Else
			Call rtitem.AppendText(" record on the " + edrmsdb.title + " database which was created by someone else and which has been assigned to you")
		End If
		Call rtitem.AppendStyle(rsnormal)
	End If

	Call rtitem.addnewline(2)
	Call rtitem.AppendStyle(rsnormal)

	If advicecountreassign > 0 Then
		If advicecount + advicecountreassign > 1 Then
			Call rtitem.appendtext("These " + CStr(advicecount + advicecountreassign) + " records are due for review this year on this BDB ===> ")
		Else
			Call rtitem.appendtext("This record is due for review this year on this BDB ===> ")
		End If
	Else
		If advicecount > 1 Then
			Call rtitem.appendtext("These records are due for review this year on this BDB ===> ")
		Else
			Call rtitem.appendtext("This record is due for review this year on this BDB ===> ")
		End If
	End If
	Call rtitem.AppendDocLink( edrmsdb, edrmsdb.Title )

	Call rtitem.AppendStyle(rsnormal)
	Call rtitem.addnewline(2)
	Call rtitem.AppendText(edrmsmetaprofiledoc.EmailText2(0))
	Call rtitem.addnewline(2)
	Call rtitem.appendtext("Registrar(s) of this database are - " + regrolelist)

	staffreplist$ = staffreplist$ + storedname.common +  " (" + CStr(advicecount + advicecountreassign) + ")" + Chr(10)

	advicecount = 0
	advicecountreassign = 0

	Return

setupreport:
	' set report log up
	Set repdoc = edrmsdb.createdocument
	repdoc.Form = EDRMSDELETIONADVICELOGFORM$
	repdoc.M_originator = "Agent " & agent.name
	repdoc.logdate = Date
	Set repItem = New NotesItem( repdoc, "RoleHolders", "",NAMES )

	If doc Is Nothing Then
		logaction("No records to advise were found, writing report doc to this database")
		staffreplist = "No staff notification emails sent"
		repdoc.emailssent = "0"
		repdoc.emailssentreg = "0"
		repdoc.edrmsadminssent = "0"
		repdoc.docsadvised = "0"
		repdoc.docsadvisednoncd = "0"
		repdoc.docsadvisednoncdnoregistrar = "0"
		repdoc.StaffDetails = staffreplist
		Call repdoc.save(True,False)

		' Write the BDB / File Counts log record

		logaction("Writing nil counts document to " & edrmsmetadatadb.title)
		Set countdoc = New NotesDocument(edrmsmetadatadb) ' Check this is the correct Database
		countdoc.form = COUNTSFORM$
		countdoc.BDBName = edrmsdb.Title
		countdoc.docsadvised = 0
		countdoc.noncddocsadvised = 0
		countdoc.edrmsadminsadvised = 0
		countdoc.emailssentEDRMS = "0"
		countdoc.emailssentreg = "0"
		countdoc.emailssent = "0"
		Call countdoc.Save(True,True)

		logclose("Exiting as no documents to process")
		Exit Sub
	End If
	Return

setupemail:
	' Set up Rich Text Styles:-

	Set rsnormal = edrmssess.CreateRichTextStyle ' default text
	rsnormal.bold=False
	rsnormal.fontsize = 10
	rsnormal.NotesColor = COLOR_BLACK

	Set rs1 = edrmssess.CreateRichTextStyle
	rs1.NotesColor = COLOR_BLUE
	rs1.bold=False

	Set rs2 = edrmssess.CreateRichTextStyle
	rs2.NotesColor = COLOR_BLUE
	rs2.bold=True

	Set rs3 = edrmssess.CreateRichTextStyle
	rs3.fontsize = 8
	rs3.NotesColor = COLOR_RED

	' Set up the text strings for the email notification

	subject = edrmsmetaprofiledoc.emailheader(0) + " Database " + edrmsdb.title

	If regrolelist$ = "" Then
		regrolelist$ = EDRMSADMINSGROUP$
	End If

	' and the email to notify Registrars of Staff not on NCD...

	xsubject = edrmsmetaprofiledoc.regemailheader(0) & " Database " & edrmsdb.title

	' Set up the email to notify Registrars of Staff not on NCD...

	Set notifymailnoncd = New NotesDocument(edrmsdb)
	Set rtitem1 = New NotesRichTextItem( notifymailnoncd, "Body" )
	notifymailnoncd.importance = "1"
	notifymailnoncd.Subject = xSubject

	' Set up the initial text...

	Call rtitem1.AppendText(edrmsmetaprofiledoc.regemailtext1(0))
	Call rtitem1.AddNewLine( 2 )
	Return

errhandle:
	Call logerror(Err, Error, Erl, LSI_Info(2), LSI_Info(12), " Last module before this call " & edrmserrortext )   ' LOGS HELPFUL DETAIL ON AN ERROR
	Call logaction(" Last Global Error " & edrmslastglobalerr)
	Call alerterrors(agent.name ,"Error")     ' EMAILS THE ERROR ALERT TO ADDRESS IN PROFILE
	Exit Sub
End Sub
Sub edrms_review_checks(dc As NotesDocumentCollection,action As String,exitcode As Integer,editorlevel As integer)
	On Error GoTo globalerrhandle
	Dim doc As NotesDocument
	Dim edrms_review_checks_errtxt As String
	Dim doclevel As String
	Dim msg As String
	Dim responseflag As Integer
	Dim recordflag As Integer
	Dim replyval As Variant

	edrms_review_checks_errtxt = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	exitcode = 0  ' The default ends OK result
	responseflag = 0
	recordflag = 0
	editorlevel = 0
	Set doc = dc.getfirstdocument

	If doc.IsUIDocOpen Then
		doclevel = "Yes"
	End If

	Call edrms_check_responses_records(edrmsdc, responseflag, recordflag,editorlevel,0)
	If responseflag = 1 Then
		MessageBox "Please restrict your selection to top level documents only. Any response documents present "+_
		"will get picked up automatically if a parent document is selected.",16,edrmsdb.title &" " & EDRMSTERM$ & " Selection Contains Response Documents"
		exitcode = 1
		Exit Sub
	End If

	If editorlevel = 2 Then
		MessageBox "You have selected document(s) that you are not an eligible editor of, please refine your selection " _
		,16,edrmsdb.title &" " & EDRMSTERM$ & " Selection Contains Documents You Cannot Change"
		exitcode = 2
		Exit Sub
	End If

	If recordflag > 0 Then
		MessageBox "You have selected document(s) that are not all declared as records, please refine your selection " _
		,16,edrmsdb.title &" " & EDRMSTERM$ & " Selection Contains Undeclared Documents"
		exitcode = 3
		Exit Sub
	End If

' Check that the number of documents selected does not exceed the maximum allowed...
	If dc.count > edrmsmaxreviewlimit Then
		MessageBox "The number of records selected (" + CStr(dc.count) + "), exceeds the maximum number " +_
		"of records allowed to be reviewed at any one time (" + CStr(edrmsmaxreviewlimit)  + _
		"). Please refine your selection.",16,edrmsdb.title &" " & EDRMSTERM$ & " Too Many Records Selected"
		exitcode = 4
		Exit Sub
	End If

	If dc.count = 1 Then
		If doclevel = "Yes" Then
			msg = "This action will mark this record as """ & action & """. Continue?"
		Else
			msg = "This action will mark the selected record as """ & action & """. Continue?"
		End If
	Else
		msg = "This action will mark the " + CStr(dc.count) + " selected records as """ & action & """. Continue?"
	End If

	replyval = MessageBox(msg,36,edrmsdb.title &" " & EDRMSTERM$ & "Confirmation Required")
	If replyval = 7 Then
		MessageBox "Action aborted",64, edrmsdb.title &" " & EDRMSTERM$ & " Exiting"
		exitcode = 5
		Exit Sub
	End If

' Check that current user has edit access on all response documents. If they don't, advise that the top level document will be marked
' with responses being marked automatically via a run the following evening...
	If editorlevel = 1 Then
		If dc.Count = 1 Then
			MessageBox "This record has responses to which you do not have edit access. The record will be marked as """ & action & """now with " +_
			"responses being marked overnight tonight.",64,edrmsdb.title &" " & EDRMSTERM$ & " Delayed Update"
		Else
			MessageBox "One or more of the selected records have responses to which you do not have edit access. The record will be marked as """ & action & """ now with " +_
			"responses being marked overnight tonight.",64,edrmsdb.title &" " & EDRMSTERM$ & " Delayed Update"
		End If
	End If
Exit Sub
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_review_checks_errtxt
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Sub
End Sub
Sub edrms_check_declare(doc As NotesDocument, continue As Variant)
	On Error GoTo globalerrhandle
	Dim edrms_check_declare_errortext As String
	edrms_check_declare_errortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	continue = True
	If doc.hasitem("edrmsrecord") Then
		If doc.edrmsrecord(0) = "Yes" Then
			continue = False
			MsgBox "Declared Records cannot be edited or re-declared",16,edrmsdb.title &" " & EDRMSTERM$ & " Illegal Action"
		End If
	End If
Exit Sub
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_check_declare_errortext
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Sub
End Sub
Function edrms_util_create_email(subject As String,sendto As Variant,copyto As Variant,blindcopyto As Variant) As NotesDocument
	On Error GoTo globalerrhandle
	Dim edrms_util_create_email_errortext As String

	edrms_util_create_email_errortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	Dim doc As New NotesDocument(edrmsdb)
	doc.form = "Memo"
	doc.subject = subject
	doc.sendto = sendto
	doc.copyto = copyto
	doc.blindcopyto = blindcopyto

	Set edrms_util_create_email = doc
Exit Function
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_util_create_email_errortext
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Function
End Function
Sub edrms_agent_undeclared_records_advise(Agent As NotesAgent)
	' This agent runs against the documents selected by the view  pointed to by global constant 
	'	Const EDRMSVIEWREBUILD4$ = "EDRMS6"                                         ' EDRMS\Undeclared Records To Be Advised
	' Converted Email Text Lookups to profile on Management DB
	'NB, there is considerable embedded text at the end of this agent that needs looking at
	On Error GoTo errhandle
	Const DELIMITER$ = ","
	Dim view As NotesView
	Dim ncdview As NotesView
	Dim nabview As NotesView
	Dim checkview As NotesView
	Dim nabdc As NotesDocumentCollection
	Dim responsedc As NotesDocumentCollection
	Dim doc As NotesDocument
	Dim doc1 As NotesDocument
	Dim ncddoc As NotesDocument
	Dim notifymail As NotesDocument
	Dim notifymailnoncd As NotesDocument
	Dim repdoc As NotesDocument
	Dim checkdoc As NotesDocument
	Dim nabdoc As NotesDocument
	Dim rolename As NotesName
	Dim ncdname As NotesName
	Dim storedname As NotesName
	Dim name01 As NotesName
	Dim name02 As NotesName
	Dim name2 As NotesName
	Dim rtitem As NotesRichTextItem
	Dim rtitem1 As NotesRichTextItem
	Dim repItem As NotesItem
	Dim acl As NotesACL
	Dim getentry As NotesACLEntry
	Dim rs1 As NotesRichTextStyle
	Dim rs2 As NotesRichTextStyle
	Dim rs3 As NotesRichTextStyle
	Dim rs4 As NotesRichTextStyle
	Dim rsnormal As NotesRichTextStyle
	Dim storeddate As NotesDateTime
	Dim lastmoddate As NotesDateTime		'added rob 
	Dim sendto() As String
	Dim checkauthor As String
	Dim staffreplist As String				'for list of people who had emails sent to them for deletion report
	Dim storesreplist  As String			'for list of people who could not be found on NCD so email was sent to Stores/[Registrar] role for deletion report
	Dim storedsubject As String
	Dim regrolelist  As String				'for list of people who hold registrar role
	Dim whosdoc As String
	Dim selectstring As String
	Dim groupname As String
	Dim subject As String
	Dim para1a As String
	Dim para1b As String
	Dim para1c As String
	Dim para1d As String
	Dim para2 As String
	Dim para3 As String
	Dim para4 As String
	Dim para5a As String
	Dim para5b As String
	Dim para6a As String
	Dim para6b As String
	Dim para7a As String
	Dim para7b As String
	Dim para8 As String
	Dim xsubject As String
	Dim xpara1   As String
	Dim xpara1aa As String
	Dim xpara1ab As String
	Dim xpara1a  As String
	Dim xpara2   As String
	Dim xpara3a  As String
	Dim xpara3b  As String
	Dim xpara3c  As String
	Dim xpara4   As String
	Dim xpara5   As String
	Dim repdocpartno As Integer
	Dim aclcount As Integer
	Dim a As Integer
	Dim runtype As Integer
	Dim cont As Integer
	Dim cont1 As Integer
	Dim reassignflag  As Integer
	Dim owneddocs  As Integer
	Dim itemcount As Integer
	Dim itemcountnoncd As Integer
	Dim notonncd  As Integer
	Dim linkflagnoncd  As Integer
	Dim linkflag  As Integer
	Dim helperdbsret As Integer
	Dim sent As Integer
	Dim censusdb As Integer
	Dim howold1 As Long
	Dim howold2 As Long
	Dim howold3 As Long		'rob 
	Dim howold4 As Long		'rob 
	Dim continue As Boolean

	repdocpartno = 1
	aclcount = 0
	sent = 0
	itemcount = 1
	itemcountnoncd = 0
	staffreplist = ""
	storesreplist = ""
	regrolelist = ""

	If edrmssess.Isonserver Then
		If (edrmsdbservernn.common <> edrmsmasterservernn.common) Then
			Exit Sub   ' When run scheduled, not on master server so exit
		End If
	End If

	edrmserrortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	Call initlog(agent.name)

	' Call the function that gets the required external DBS
	logaction("Getting DB handles to edrmsncddb, edrmsnabdb, edrmsmetadatadb, edrmsholdingdb, edrmscountsdb")
	helperdbsret = edrms_get_helper_dbs
	If helperdbsret > 0 Then
		logaction("Error getting one or more of the required external databases, check the Lookup.nsf and the default accesses to these DBs, error code = " & CStr(helperdbsret))
		logaction("Error codes: NCD = 99, NAB = 98, EDRMS Management DB = 97, EDRMS Holding DB = 96, EDRMS Counts DB = 95")
		Call alerterrors(agent.name ,"Error with external databases, error code " & CStr(helperdbsret))
		Exit Sub
	End If

	' Check if this database is on the exceptions list...

	Set checkview = edrmscountsdb.GetView( EDRMSEXCEPTIONSVIEW$)
	Set checkdoc = checkview.GetDocumentByKey(edrmsdb.FilePath,True)
	censusdb = 0
	If Not checkdoc Is Nothing Then
		censusdb = 1
	End If

	' set report log up
	Set repdoc = edrmsdb.createdocument
	repdoc.Form = EDRMSDELETIONADVICELOGFORM$
	repdoc.from = "Agent " & agent.name
	repdoc.logdate = date
	Set repItem = New NotesItem( repdoc, "RoleHolders", "",NAMES )

	Set ncdview = edrmsncddb.getview(EDRMSNCDVIEW$)
	If ncdview Is Nothing Then
		logaction("Error getting " & edrmsncddb.title & " view " & EDRMSNCDVIEW$)
		Exit Sub
	End If

	Set nabview = edrmsnabdb.getview(EDRMSNABALLNAMES$)
	Set view = edrmsdb.getview(EDRMSVIEWREBUILD4$)           ' Const EDRMSVIEWREBUILD4$ = "EDRMS6"   ' EDRMS\Undeclared Records To Be Advised
	logaction(view.name & " contains " & CStr( view.Toplevelentrycount) & " documents")
	Set doc = view.getfirstdocument
	Set doc1 = doc   ' Need to check the previous document later in the code

	' If no documents to notify, write nil return report line and exit sub...
	If doc Is Nothing Then
		staffreplist = "No staff notification emails sent"
		Print "No documents to advise were found"
		repdoc.StaffDetails = staffreplist
		Call repdoc.save(True,False)
		logclose("Exiting as there are no documents to process in the view " & view.name)
		Exit Sub
	End If

	logaction("Examining ACL for the relevant roles " & EDRMSREGISTRAR$)

	ReDim sendto(0)
	Call edrms_examine_acl_roles(ncdview,repitem,EDRMSREGISTRAR$,sendto,regrolelist)  ' get the list of DB registrars
	If UBound(sendto) = 0 And sendto(UBound(sendto)) = "" Then
		logaction("Error after Call edrms_examine_acl_roles - there were no people on the ACL with the " & EDRMSREGISTRAR$ & " role, adding " & EDRMSADMINSGROUP$ & " so that processing can continue")
		sendto(0) =  EDRMSADMINSGROUP$
	End If
	
	If(regrolelist <> "") Then                                                                                                                      ' Indicating use Registrars List
		logaction("Database Registrars ACL Role held by the following people " & regrolelist)   ' Indicating use Registrars List
		logaction("sendto variable contains " & CStr(UBound(sendto)) & " elements")                   ' Indicating use Registrars List
		aclcount = 1						                                                                                                                 ' Indicating use Registrars List 
	End If

	logaction("Setup complete, checking whether run by user or scheduled")

	If edrmssess.Isonserver Then
		runtype = 6
		logaction("Running Scheduled")
	Else
		logaction("Run by user action, prompting for Live or Test")
		Call edrms_user_live_test_prompt(view,name2,runtype,continue)
		If continue = False Then
			logclose("Run Ends, user aborted")
			Exit Sub
		End If
	End If

	storedsubject = doc.subject(0)

	If doc.Reassign_To(0) = "" Then
		whosdoc = doc.permanentauthor(0)
	Else
		whosdoc = doc.Reassign_To(0)
	End If

	Set storedname = New NotesName(whosdoc)

	' Set up Rich Text Styles:-

	Set rsnormal = edrmssess.CreateRichTextStyle ' default text
	rsnormal.bold=False
	rsnormal.fontsize = 10
	rsnormal.NotesColor = COLOR_BLACK
	Set rs1 = edrmssess.CreateRichTextStyle
	rs1.NotesColor = COLOR_RED
	Set rs2 = edrmssess.CreateRichTextStyle
	rs2.bold=True
	Set rs3 = edrmssess.CreateRichTextStyle
	rs3.NotesColor = COLOR_BLUE
	Set rs4 = edrmssess.CreateRichTextStyle
	rs3.NotesColor = COLOR_BLUE
	rs4.fontsize = 8

	' System checks date created on records against next parameter. If create date is earlier than this value, line on email is red,
	' otherwise line is blue

	howold2 = (CLng(Today) - (EDRMSCREATEDDAYS% - EDRMS15DAYS%))         '   howold2 As Long ' used to store date 15 days before declaration deadline
	howold4 = (CLng(Today) - (EDRMSMODIFIEDDAYS% - EDRMS15DAYS%))         '   howold4 As Long ' used to store date 15 days before last modified declaration deadline     rob 
	logaction("Working out how many days to go back relative to today, value = " & CStr(howold2))
	logaction("Working out how many days to go back relative to today for last modified, value = " & CStr(howold4))	'rob 
	
	If censusdb = 0 Then
		logaction("Building usual email body")
		subject = edrmsmetaprofiledoc.normalheader(0) + " " + edrmsdb.title
		para1a = edrmsmetaprofiledoc.normalfirstline1(0)
		para1b = edrmsdb.title	+ " "
		para1c = edrmsmetaprofiledoc.normalfirstline2(0) + Chr(10) + Chr(10)
		para2 = edrmsmetaprofiledoc.normalmaintext(0) + regrolelist + "." + Chr(10) + Chr(10)
		para6a = edrmsmetaprofiledoc.normaltrailer1(0)
		para6b = edrmsmetaprofiledoc.normaltrailer2(0) + Chr(10) + Chr(10)
		para7a = edrmsmetaprofiledoc.normaltrailer3(0) + Chr(10) + Chr(10)
		para7b = edrmsmetaprofiledoc.normaltrailer4(0) + Chr(10) + Chr(10)
		para8 = edrmsmetaprofiledoc.normaltrailer5(0)
	Else
		logaction("Building Census email body")
		subject = edrmsmetaprofiledoc.censusheader(0) + " " + edrmsdb.title
		para1a = edrmsmetaprofiledoc.censusfirstline1(0)
		para1b = edrmsdb.title  + " "
		para1c = edrmsmetaprofiledoc.censusfirstline2(0) + Chr(10) + Chr(10)
		para2 = edrmsmetaprofiledoc.censusmaintext(0) + regrolelist + "." + Chr(10) + Chr(10)
		para6a = edrmsmetaprofiledoc.censustrailer1(0)
		para6b = edrmsmetaprofiledoc.censustrailer2(0) + Chr(10) + Chr(10)
		para7a = edrmsmetaprofiledoc.censustrailer3(0) + Chr(10) + Chr(10)
		para7b = edrmsmetaprofiledoc.censustrailer4(0) + Chr(10) + Chr(10)
		para8 = edrmsmetaprofiledoc.censustrailer5(0)
	End If

	If regrolelist = "" Then
		logaction("No registrars found so subsituting with " &  EDRMSADMINSGROUP$)
		regrolelist = EDRMSADMINSGROUP$
	End If

	' and the email to notify Registrars of Staff not on NCD...
	If censusdb = 0 Then
		xsubject = edrmsmetaprofiledoc.RegistrarsHeader(0)  + " " + edrmsdb.title
		xpara1 = edrmsmetaprofiledoc.RegistrarsFirstLine1(0)
		xpara1aa = edrmsdb.title + " "
		xpara1ab = edrmsmetaprofiledoc.RegistrarsFirstLine2(0) + Chr(10) + Chr(10)
		xpara2 = edrmsmetaprofiledoc.registrarsmaintext(0) + Chr(10) + Chr(10)
	Else
		xsubject = edrmsmetaprofiledoc.RegistrarsHeaderCensus(0)  + " " + edrmsdb.title
		xpara1 = edrmsmetaprofiledoc.RegistrarsFirstLine1Census(0)
		xpara1aa = edrmsdb.title + " "
		xpara1ab = edrmsmetaprofiledoc.RegistrarsFirstLine2Census(0)  + Chr(10) + Chr(10)
		xpara2 = edrmsmetaprofiledoc.registrarsmaintextCensus(0) + Chr(10) + Chr(10)
	End If

	' Set up the email to notify Registrars of Staff not on NCD...
	logaction("Building email to notify registrars about staff not found on NAB/NCD")
	Set notifymailnoncd = New NotesDocument(edrmsdb)
	notifymailnoncd.importance = "1"
	notifymailnoncd.Subject = xSubject
	Set rtitem1 = New NotesRichTextItem( notifymailnoncd, "Body" )
	Call rtitem1.AppendText(xpara1)
	Call rtitem1.AppendStyle(rs2)
	Call rtitem1.AppendText(xpara1aa)
	Call rtitem1.AppendStyle(rsnormal)
	Call rtitem1.AppendText(xpara1ab)

	' Added for documents where PermanentAuthor field is not present...

	If storedname.common = "" Then
		Set storedname = New NotesName(doc.authors(0))
	End If

	If doc.Versioncreatedate(0) <> "" Then
		Set storeddate = New NotesDateTime(doc.Versioncreatedate(0))
	Else
		Set storeddate = New NotesDateTime(doc.created)
	End If

	'added - rob Used to determine whether or not to write email line in red or not
	If doc.edrmslastmod(0) <> "" Then
		Set lastmoddate = New NotesDateTime(doc.edrmslastmod(0))
	Else
		Set lastmoddate = New NotesDateTime(doc.created)
	End If

	
	
	
	' Check first document on NCD...

	If doc.Reassign_To(0) = "" Then
		Set ncdname = New NotesName(doc.permanentauthor(0))
	Else
		Set ncdname = New NotesName(doc.Reassign_To(0))
	End If

	Set ncddoc = ncdview.getdocumentbykey(ncdname.abbreviated,True)
	Set doc=view.getnextdocument(doc)

	'############# START OF MAIN LOOP #############
	logaction("Starting main loop")
	While Not doc Is Nothing

		' Check that doc creator still on NCD
		If doc.Reassign_To(0) = "" Then
			Set ncdname = New NotesName(doc.permanentauthor(0))
		Else
			Set ncdname = New NotesName(doc.Reassign_To(0))
		End If

		' Added for documents where PermanentAuthor field is not present...
		If ncdname.common = "" Then
			Set ncdname = New NotesName(doc.authors(0))
		End If

		' Look up NAB rather than NCD

		Set nabdoc = nabview.getdocumentbykey(ncdname.canonical,True)
		If nabdoc Is Nothing Then
			notonncd = 1
		Else
			notonncd = 0
		End If

		If doc.Reassign_To(0) = "" Then
			checkauthor = doc.permanentauthor(0)
		Else
			checkauthor = doc.Reassign_To(0)
		End If
		
		If checkauthor = "" Then                                 ' DJS V004 16/02/2016  - problem with reassigned docs and the original author being sent advice
			checkauthor = doc.authors(0)
		End If
		
		If checkauthor = storedname.canonical then          ' DJS V004 16/02/2016 - problem with reassigned docs and the original author being sent advice - removed:   Or doc.authors(0) = storedname.canonical Then ' multiple entries
			If notonncd = 1 Then
				GoSub write_doc_line_noncd
				storedsubject = doc.subject(0)

				If doc.Versioncreatedate(0) <> "" Then
					Set storeddate = New NotesDateTime(doc.Versioncreatedate(0))
				Else
					Set storeddate = New NotesDateTime(doc.created)
				End If

				'added- rob Used to determine whether or not to write email line in red or not
				If doc.edrmslastmod(0) <> "" Then
					Set lastmoddate = New NotesDateTime(doc.edrmslastmod(0))
				Else
					Set lastmoddate = New NotesDateTime(doc.created)
				End If
			Else
				If itemcount = 1 Then ' write header and first software line
					Set notifymail = New NotesDocument(edrmsdb)
					notifymail.importance = "1"
					Set rtitem = New NotesRichTextItem( notifymail, "Body" )
					GoSub write_header_line
					GoSub write_doc_line
					storedsubject = doc.subject(0)

					If doc.Versioncreatedate(0) <> "" Then
						Set storeddate = New NotesDateTime(doc.Versioncreatedate(0))
					Else
						Set storeddate = New NotesDateTime(doc.created)
					End If

					'added - rob Used to determine whether or not to write email line in red or not
					If doc.edrmslastmod(0) <> "" Then
						Set lastmoddate = New NotesDateTime(doc.edrmslastmod(0))
					Else
						Set lastmoddate = New NotesDateTime(doc.created)
					End If
				Else ' just write current name line
					GoSub write_doc_line
					storedsubject = doc.subject(0)

					If doc.Versioncreatedate(0) <> "" Then
						Set storeddate = New NotesDateTime(doc.Versioncreatedate(0))
					Else
						Set storeddate = New NotesDateTime(doc.created)
					End If

					'added - rob Used to determine whether or not to write email line in red or not
					If doc.edrmslastmod(0) <> "" Then
						Set lastmoddate = New NotesDateTime(doc.edrmslastmod(0))
					Else
						Set lastmoddate = New NotesDateTime(doc.created)
					End If
				End If
			End If
		Else ' single name or end of multi name

			If doc1.Reassign_To(0) = "" Then
				Set ncdname = New NotesName(doc1.permanentauthor(0))
			Else
				Set ncdname = New NotesName(doc1.Reassign_To(0))
			End If

			' Added for documents where PermanentAuthor field is not present...
			If ncdname.common = "" Then
				Set ncdname = New NotesName(doc1.authors(0))
			End If

			' Look up NAB rather than NCD

			Set nabdoc = nabview.getdocumentbykey(ncdname.canonical,True)

			If nabdoc Is Nothing Then
				notonncd = 1
			Else
				notonncd = 0
			End If

			If notonncd = 1 Then
				GoSub write_doc_line_noncd
				storedsubject = doc.subject(0)
				If doc.Reassign_To(0) = "" Then
					whosdoc = doc.permanentauthor(0)
				Else
					whosdoc = doc.Reassign_To(0)
				End If

				Set storedname = New NotesName(whosdoc)

				' Added for documents where PermanentAuthor field is not present...
				If storedname.common = "" Then
					Set storedname = New NotesName(doc.authors(0))
				End If

				If doc.Versioncreatedate(0) <> "" And doc.versioncreatedby(0) <> "" Then
					Set storeddate = New NotesDateTime(doc.Versioncreatedate(0))
				Else
					Set storeddate = New NotesDateTime(doc.created)
				End If

				'added  - rob Used to determine whether or not to write email line in red or not
				If doc.edrmslastmod(0) <> "" Then
					Set lastmoddate = New NotesDateTime(doc.edrmslastmod(0))
				Else
					Set lastmoddate = New NotesDateTime(doc.created)
				End If
			Else
				If itemcount = 1 Then ' single software
					Set notifymail = New NotesDocument(edrmsdb)
					notifymail.importance = "1"
					Set rtitem = New NotesRichTextItem( notifymail, "Body" )
					GoSub write_header_line
					GoSub write_doc_line
					storedsubject = doc.subject(0)

					If doc.Versioncreatedate(0) <> "" Then
						Set storeddate = New NotesDateTime(doc.Versioncreatedate(0))
					Else
						Set storeddate = New NotesDateTime(doc.created)
					End If

					'added  - rob Used to determine whether or not to write email line in red or not
					If doc.edrmslastmod(0) <> "" Then
						Set lastmoddate = New NotesDateTime(doc.edrmslastmod(0))
					Else
						Set lastmoddate = New NotesDateTime(doc.created)
					End If
				Else ' add the last line in and send the email
					GoSub write_doc_line
					storedsubject = doc.subject(0)

					If doc.Versioncreatedate(0) <> "" Then
						Set storeddate = New NotesDateTime(doc.Versioncreatedate(0))
					Else
						Set storeddate = New NotesDateTime(doc.created)
					End If

					'added  - rob Used to determine whether or not to write email line in red or not
					If doc.edrmslastmod(0) <> "" Then
						Set lastmoddate = New NotesDateTime(doc.edrmslastmod(0))
					Else
						Set lastmoddate = New NotesDateTime(doc.created)
					End If
				End If

				notifymail.Subject = subject
				If runtype = 6 Then
					notifymail.SendTo = storedname.abbreviated
				Else
					notifymail.SendTo = name2.common
				End If
				notifymail.principal = EDRMSADMINSGROUP$
				notifymail.displaysent = "Scheduled agent. Please do not respond."

				Call rtitem.AddNewLine( 1 )
				GoSub write_body

				If runtype = 7 Then
					Call rtitem.AddNewLine( 2 )
					Call rtitem.AppendText("(In live situation, this email would go to " + storedname.common + ")")
				End If

				logaction("Sending email with subject " & notifymail.Subject(0) & " To " & edrms_util_implodearray(notifymail.SendTo,DELIMITER$))
				Call notifymail.Send( False )     ' SENDING EMAIL
				storedsubject = doc.subject(0)

				If doc.Reassign_To(0) = "" Then
					whosdoc = doc.permanentauthor(0)
				Else
					whosdoc = doc.Reassign_To(0)
				End If

				Set storedname = New NotesName(whosdoc)

				' Added for documents where PermanentAuthor field is not present...

				If storedname.common = "" Then
					Set storedname = New NotesName(doc.authors(0))
				End If

				If doc.Versioncreatedate(0) <> "" Then
					Set storeddate = New NotesDateTime(doc.Versioncreatedate(0))
				Else
					Set storeddate = New NotesDateTime(doc.created)
				End If

				'added  - rob Used to determine whether or not to write email line in red or not
				If doc.edrmslastmod(0) <> "" Then
					Set lastmoddate = New NotesDateTime(doc.edrmslastmod(0))
				Else
					Set lastmoddate = New NotesDateTime(doc.created)
				End If
				sent = sent + 1
				itemcount = 1
			End If
		End If
		Set doc1=doc
		Set doc=view.getnextdocument(doc)

	Wend
	'############# END OF MAIN LOOP #############

endlab:
	' Send the final emails

	' Lookup NAB
	Set nabdoc = nabview.getdocumentbykey(storedname.canonical,True)

	If nabdoc Is Nothing Then
		notonncd = 1
	Else
		notonncd = 0
	End If

	If notonncd = 0 Then
		If itemcount = 1 Then
			Set notifymail = New NotesDocument(edrmsdb)
			notifymail.importance = "1"
			Set rtitem = New NotesRichTextItem( notifymail, "Body" )
			GoSub write_header_line
			GoSub write_doc_line
		Else
			GoSub write_doc_line
		End If

		notifymail.Subject = subject
		If runtype = 6 Then
			notifymail.SendTo = storedname.abbreviated
		Else
			notifymail.SendTo = name2.common
		End If
		notifymail.principal = EDRMSADMINSGROUP$
		notifymail.displaysent = "Scheduled agent. Please do not respond."
		Call rtitem.AddNewLine( 1 )
		GoSub write_body

		If runtype = 7 Then
			Call rtitem.AddNewLine( 2 )
			Call rtitem.AppendText("(In live situation, this email would go to " + storedname.common + ")")
		End If

		logaction("Sending email with subject " & notifymail.Subject(0) & " To " & edrms_util_implodearray(notifymail.SendTo,DELIMITER$))
		Call notifymail.Send( False )
		sent = sent + 1
	End If

	' If the last document relates to someone not on NCD, write details of that record

	If doc1.Reassign_To(0) = "" Then
		whosdoc = doc1.permanentauthor(0)
	Else
		whosdoc = doc1.Reassign_To(0)
	End If

	Set ncdname = New NotesName(whosdoc)

	If ncdname.common = "" Then
		Set ncdname = New NotesName(doc1.authors(0))
	End If

	' Check NAB rather than NCD

	Set nabdoc=nabview.getdocumentbykey(storedname.canonical,True)
	'
	If nabdoc Is Nothing Then
		GoSub write_doc_line_noncd
	End If

	If itemcountnoncd > 0 Then
		If runtype = 6 Then
			If aclcount = 0 Then
				' nobody on acl with [registrar] - live run - send to Admins
				notifymailnoncd.SendTo = EDRMSADMINSGROUP$
				logaction("Addressing email to: " & EDRMSADMINSGROUP$)
			Else
				notifymailnoncd.SendTo = SendTo()                                         ' This is the array of registrars passed out of edrms_examine_acl_roles  
				logaction("Addressing email to registrars: " & regrolelist)
			End If
		Else	'test run
			If aclcount = 0 Then
				' nobody on acl with [registrar] - test run - send to selected name
				notifymailnoncd.SendTo = name2.common
			Else
				notifymailnoncd.SendTo = name2.common
			End If
		End If

		notifymailnoncd.principal = EDRMSADMINSGROUP$
		notifymailnoncd.displaysent = "Scheduled agent. Please do not respond."
		Call rtitem1.AddNewLine( 1 )
		GoSub write_body_noncd

		If runtype = 7 Then
			Call rtitem1.AddNewLine( 2 )
			Call rtitem1.AppendText("(In live situation, this email would go to Database Registrars" + regrolelist + ")")
		End If
		logaction("Sending email with subject " & notifymailnoncd.Subject(0) & " To " & edrms_util_implodearray(notifymailnoncd.SendTo,DELIMITER$))
		Call notifymailnoncd.Send( False )
		sent = sent + 1
	End If

	If staffreplist = "" Then
		staffreplist = "No staff notification emails sent"
	End If

	If aclcount = 0 Then
		' nobody on acl with the role in EDRMSREGISTRAR$
		repdoc.StaffDetails = staffreplist
		repdoc.StoresDetails = storesreplist
		Call repdoc.save(True,False)
	Else

		repdoc.StaffDetails = staffreplist
		repdoc.RoleDetails = storesreplist
		Call repdoc.save(True,False)
	End If

	MessageBox "End of run. " + CStr(sent) + " emails sent",64,edrmsdb.title &" " & EDRMSTERM$ & " Ends OK"
	Call logclose("End of run. " & CStr(sent) & " emails sent")
	Exit Sub

	'==============================================================================================
	' SUBROUTINES
	'==============================================================================================
write_header_line:

	Call rtitem.AppendText(para1a)
	Call rtitem.AppendStyle(rs2)
	Call rtitem.AppendText(para1b)
	Call rtitem.AppendStyle(rsnormal)
	Call rtitem.AppendText(para1c)
	reassignflag = 0
	owneddocs = 0
	Return

write_doc_line_noncd:

	howold1 = CLng(storeddate.lslocaltime)
	howold3 = CLng(lastmoddate.lslocaltime)		'rob 
	'	If howold1 < howold2 Then
	If howold1 < howold2 Or howold3 < howold4 Then		'rob 
		Call rtitem1.AppendStyle(rs1)
	Else
		Call rtitem1.AppendStyle(rs3)
	End If

	If doc1.form(0) = "LinkDoc" Or doc1.form(0) = "URLLinkDoc" Or doc1.form(0) = "AttachDoc" Then
		linkflagnoncd = 1

		If doc1.Versioncreatedate(0) <> "" And doc1.versioncreatedby(0) <> "" Then
			Call rtitem1.AppendText("     " + storedsubject + " (new version created " + CStr(storeddate.dateonly) + ")")
		ElseIf doc1.versioncreatedate(0) <> "" Then
			Call rtitem1.AppendText("     " + storedsubject + " (originally created " + CStr(storeddate.dateonly) + ")")
		Else
			Call rtitem1.AppendText("     " + storedsubject + " (created " + CStr(storeddate.dateonly) + ")")
		End If

		Call rtitem1.AppendStyle(rs2)
		Call rtitem1.AppendText(" *** Please see note at bottom of e-mail concerning Link, Attachment or URL Documents ***")
		Call rtitem1.AppendStyle(rsnormal)
		'	If howold1 < howold2 Then
		If howold1 < howold2 Or howold3 < howold4 Then		'rob 
			Call rtitem1.AppendStyle(rs1)
		Else
			Call rtitem1.AppendStyle(rs3)
		End If
	Else
		If doc1.Versioncreatedate(0) <> "" And doc1.versioncreatedby(0) <> "" Then
			Call rtitem1.AppendText("     " + storedsubject + " (new version created by " + storedname.common + " on " + CStr(storeddate.dateonly) + ") ===> ")
		ElseIf doc1.versioncreatedate(0) <> "" Then
			Call rtitem1.AppendText("     " + storedsubject + " (originally created by " + storedname.common + " on " + CStr(storeddate.dateonly) + ") ===> ")
		Else
			Call rtitem1.AppendText("     " + storedsubject + " (created by " + storedname.common + " on " + CStr(storeddate.dateonly) + ") ===> ")
		End If

		Call rtitem1.AppendDocLink( doc1, edrmsdb.Title )
	End If

	' If document has responses, include this information at the end of the line...

	Set responsedc = doc1.responses

	If responsedc.count > 0 Then
		Call rtitem1.AppendText(" (This document has one or more responses)")
	End If

	Call rtitem1.AddNewLine( 1 )
	Call rtitem1.AppendStyle(rsnormal)
	itemcountnoncd = itemcountnoncd + 1

	If Len(staffreplist) >EDRMSMAXREPSIZE& Or Len(storesreplist) >EDRMSMAXREPSIZE& Then
		If aclcount = 0 Then
			' nobody on acl with [registrar]
			repdoc.StaffDetails = staffreplist
			repdoc.StoresDetails = storesreplist
			Call repdoc.save(True,False)
		Else
			repdoc.StaffDetails = staffreplist
			repdoc.RoleDetails = storesreplist
		End If

		repdoc.partno = " (Part " + CStr(repdocpartno) + ")"
		Call repdoc.save(True,False)
		Set repdoc = edrmsdb.createdocument
		repdoc.Form = EDRMSDELETIONADVICELOGFORM$
		repdoc.logdate = date
		repdocpartno = repdocpartno + 1
		repdoc.partno = " (Part " + CStr(repdocpartno) + ")"
		Set repItem = New NotesItem( repdoc, "RoleHolders", "",NAMES )
		staffreplist = ""
		storesreplist = ""
	End If

	If doc1.Versioncreatedate(0) <> "" And doc1.versioncreatedby(0) <> "" Then
		storesreplist = storesreplist + storedsubject + " (new version created by " + storedname.common + " on " + CStr(storeddate.dateonly) + ")" + Chr(10)
	Else
		storesreplist = storesreplist + storedsubject + " (created by " + storedname.common + " on " + CStr(storeddate.dateonly) + ")" + Chr(10)
	End If

	Return

write_doc_line:
	' If reassigned documents, add blank line to separate out from owned documents
	If doc1.reassign_to(0) <> "" Then
		If reassignflag <> 1 Then

			' Don't write a blank line if only reassigned documents

			If owneddocs = 1 Then
				Call rtitem.AddNewLine( 1 )
				reassignflag = 1
			End If
		End If
	End If

	howold1 = CLng(storeddate.lslocaltime)
	howold3 = CLng(lastmoddate.lslocaltime)		'rob 
	'	If howold1 < howold2 Then
	If howold1 < howold2 Or howold3 < howold4 Then		'rob 
		Call rtitem.AppendStyle(rs1)
	Else
		Call rtitem.AppendStyle(rs3)
	End If

	' Add the link - pointless including a link on a Linked Document...

	If doc1.form(0) = "LinkDoc" Or doc1.form(0) = "URLLinkDoc" Or doc1.form(0) = "AttachDoc" Then
		linkflag = 1

		If doc1.Versioncreatedate(0) <> "" And doc1.versioncreatedby(0) <> "" Then
			Call rtitem.AppendText("     " + storedsubject + " (new version created " + CStr(storeddate.dateonly) + ")")
		ElseIf doc1.versioncreatedate(0) <> "" Then
			Call rtitem.AppendText("     " + storedsubject + " (originally created " + CStr(storeddate.dateonly) + ")")
		Else
			Call rtitem.AppendText("     " + storedsubject + " (created " + CStr(storeddate.dateonly) +")")
		End If

		Call rtitem.AppendStyle(rs2)
		Call rtitem.AppendText(" *** Please see note at bottom of e-mail concerning Link, Attachment or URL Documents ***")
		Call rtitem.AppendStyle(rsnormal)
		'	If howold1 < howold2 Then
		If howold1 < howold2 Or howold3 < howold4 Then		'rob 
			Call rtitem.AppendStyle(rs1)
		Else
			Call rtitem.AppendStyle(rs3)
		End If
	Else
		If doc1.Versioncreatedate(0) <> "" And doc1.versioncreatedby(0) <> "" Then
			Call rtitem.AppendText("     " + storedsubject + " (new version created " + CStr(storeddate.dateonly) + ") ===> ")
		ElseIf doc1.versioncreatedate(0) <> "" Then
			Call rtitem.AppendText("     " + storedsubject + " (originally created " + CStr(storeddate.dateonly) + ") ===> ")
		Else
			Call rtitem.AppendText("     " + storedsubject + " (created " + CStr(storeddate.dateonly) + ") ===> ")
		End If

		Call rtitem.AppendDocLink( doc1, edrmsdb.Title )
	End If

	If doc1.reassign_to(0) = "" Then
		owneddocs = 1
	End If

	' If document has responses, indicate this at the end of the line...

	Set responsedc = doc1.responses

	If responsedc.count > 0 Then
		Call rtitem.AppendText(" (This document has one or more responses)")
	End If

	' Indicate if documents have been reassigned to, rather than created by, the recipient...

	If doc1.reassign_to(0) <> "" Then
		Set name01 = New NotesName(doc1.permanentauthor(0))
		Set name02 = New NotesName(doc1.reassign_by(0))
		Call rtitem.AddNewLine( 1 )
		If name01.common <> "" Then
			Call rtitem.AppendText("           ***** Document originally created by " + name01.common + ", reassigned to you by " + name02.common + " on " + CStr(doc1.reassign_date(0)) + " *****")
		Else
			Call rtitem.AppendText("           ***** Document reassigned to you by " + name02.common + " on " + CStr(doc1.reassign_date(0)) + " *****")
		End If
	End If

	Call rtitem.AddNewLine( 1 )
	Call rtitem.AppendStyle(rsnormal)
	itemcount = itemcount + 1

	If doc1.Versioncreatedate(0) <> "" And doc1.versioncreatedby(0) <> "" Then
		staffreplist = staffreplist + storedname.common +  " - " + storedsubject + " (new version created " + CStr(storeddate.dateonly) + ")" + Chr(10)
	Else

		If Len(staffreplist) > EDRMSMAXREPSIZE& Then

			If aclcount = 0 Then
				' nobody on acl with [registrar]
				repdoc.StaffDetails = staffreplist
				repdoc.StoresDetails = storesreplist
			Else

				repdoc.StaffDetails = staffreplist
				repdoc.RoleDetails = storesreplist
			End If

			'repdoc.staffdetails = staffreplist
			'	repdoc.storesdetails = storesreplist
			repdoc.partno = " (Part " + CStr(repdocpartno) + ")"
			Call repdoc.save(True,False)
			Set repdoc = edrmsdb.createdocument
			repdoc.Form = EDRMSDELETIONADVICELOGFORM$
			repdoc.logdate = date
			repdocpartno = repdocpartno + 1
			repdoc.partno = " (Part " + CStr(repdocpartno) + ")"
			Set repItem = New NotesItem( repdoc, "RoleHolders", "",NAMES )
			staffreplist = ""
			storesreplist = ""
		End If

		staffreplist = staffreplist + storedname.common +  " - " + storedsubject + " (created " + CStr(storeddate.dateonly) + ")" + Chr(10)
	End If

	Return

write_body:

	Call rtitem.AppendText(para1d)
	Call rtitem.AppendText(para2)
	Call rtitem.AppendText(para3)
	Call rtitem.AppendText(para4)
	Call rtitem.AppendText(para5a)
	Call rtitem.AppendText(para5b)
	Call rtitem.AppendText(para6a)
	Call rtitem.AppendStyle(rs3)
	Call rtitem.AppendText(para6b)
	Call rtitem.AppendStyle(rsnormal)
	Call rtitem.AppendText(para7a)
	Call rtitem.AppendStyle(rs3)
	Call rtitem.AppendText(para7b)
	Call rtitem.AppendStyle(rsnormal)
	Call rtitem.AppendText(para8)
	If linkflag=1 Then
		linkflag = 0
		Call rtitem.AppendStyle(rs2)
		Call rtitem.AppendText(Chr(10) & Chr(10) & "*** Link, Attachment or URL Documents: ")
		Call rtitem.AppendStyle(rsnormal)
		Call rtitem.AppendText("Links to these types of documents are not shown as this would direct you to either the linked document, " +_
		"would open the attachment or open the website it links to rather than the original documents you have been notified of. " +_
		"To find the documents notified above, either copy the title and search for it in the database or open the database and sort " +_
		"documents by Type. From February 2012, if you need to retain the information within these documents you will need to cut " +_
		"and paste it into a standard document and declare that as Link documents can no longer be declared.")
		Call rtitem.AppendStyle(rs2)
		Call rtitem.AppendText("***")
		Call rtitem.AppendStyle(rsnormal)
	End If
	Return

write_body_noncd:

	Call rtitem1.AppendText(xpara1a)
	Call rtitem1.AppendText(xpara2)
	Call rtitem1.AppendText(xpara3a)
	Call rtitem1.AppendText(xpara3b)
	Call rtitem1.AppendText(xpara3c)
	Call rtitem1.AppendText(xpara4)
	Call rtitem1.AppendText(xpara5)
	Call rtitem1.AppendText(para6a)
	Call rtitem1.AppendStyle(rs3)
	Call rtitem1.AppendText(para6b)
	Call rtitem1.AppendStyle(rsnormal)
	Call rtitem1.AppendText(para7a)
	Call rtitem1.AppendStyle(rs3)
	Call rtitem1.AppendText(para7b)
	Call rtitem1.AppendStyle(rsnormal)
	Call rtitem1.AppendText(para8)
	If linkflagnoncd = 1 Then
		linkflagnoncd = 0
		Call rtitem1.AppendStyle(rs2)
		Call rtitem1.AppendText(Chr(10) & Chr(10) & "*** Link, Attachment or URL Documents: ")
		Call rtitem1.AppendStyle(rsnormal)
		Call rtitem1.AppendText("Links to these types of documents are not shown as this would direct you to either the linked document, " +_
		"would open the attachment or open the website it links to rather than the original document(s) you have been notified of. " +_
		"To find the document(s) notified above, either copy the title and search for it in the database or open the database and sort " +_
		"documents by Type.  Once found, you can edit the document(s) by right clicking and choosing edit.")
		Call rtitem1.AppendStyle(rs2)
		Call rtitem1.AppendText("***")
		Call rtitem1.AppendStyle(rsnormal)
	End If
	Return

handler:
	Print "Error on Undeclared Records - Advise Agent on " + edrmsdb.Title + " " + CStr(Err) + " - " + Error + " (Name " + storedname.common + ", Document " + storedsubject + ")"
	Resume Next

errhandle:
	Call logerror(Err, Error, Erl, LSI_Info(2), LSI_Info(12), " Last module before this call " & edrmserrortext )   ' LOGS HELPFUL DETAIL ON AN ERROR
	Call logaction(" Last Global Error " & edrmslastglobalerr)
	Call alerterrors(agent.name ,"Error")     ' EMAILS THE ERROR ALERT TO ADDRESS IN PROFILE
	Exit Sub
End Sub
Function edrms_get_helper_dbs As Integer
' Some of the lookup.nsf lookup keys were originally in the profile document of this database but this created a large overhead in
' populating these profile values for 700+ databases for values that realistically were more sensible as constants as even if what they 
' point at changes the key can remain the same or if we absolutely need to change then it is just one line of code in the declare of this script lib
	On Error GoTo globalerrhandle
	Dim lookupdoc As NotesDocument
	Dim edrms_get_helper_dbs_errortext As String
	edrms_get_helper_dbs_errortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	edrms_get_helper_dbs = 0

' Get NCD
	Set lookupdoc = edrmslookupnsfview.GetDocumentByKey(EDRMSNCDKEY$,True)
	If lookupdoc Is Nothing Then
		Print edrmserrortext & " Cannot locate lookup document " & EDRMSNCDKEY$
		edrms_get_helper_dbs = 99
	Else
		Set edrmsncddb = New NotesDatabase(lookupdoc.target_server(0),lookupdoc.path(0))
		If edrmsncddb Is Nothing Then
			Print edrmserrortext & " Cannot access database " & lookupdoc.target_server(0) & "!!" & lookupdoc.path(0)
			edrms_get_helper_dbs = 99
		End If 
	End If

' Get names.nsf
	Set edrmsnabdb = New NotesDatabase(edrmsdb.server,NAMESNSF$)
	If edrmsnabdb Is Nothing Then
		Print edrmserrortext & " Cannot access " & NAMESNSF$
		edrms_get_helper_dbs = 98
	End If

' Get Metadata Database
	Set lookupdoc = edrmslookupnsfview.GetDocumentByKey(EDRMSMETADATADBKEY$,True)
	If lookupdoc Is Nothing Then
		Print edrmserrortext & " Cannot locate lookup document " & EDRMSMETADATADBKEY$
		edrms_get_helper_dbs = 97
	Else
		Set edrmsmetadatadb = New NotesDatabase(lookupdoc.target_server(0),lookupdoc.path(0))
		If edrmsmetadatadb Is Nothing Then
			Print edrmserrortext & " Cannot access database " & lookupdoc.target_server(0) & "!!" & lookupdoc.path(0)
			edrms_get_helper_dbs = 97
		Else
			Set edrmsmetaprofiledoc = edrmsmetadatadb.Getprofiledocument(EDRMSMETADBPROFILENAME$) ' Contains system parameters and email text definitions			
		End If 
	End If

' Get Holding Database
	Set lookupdoc = edrmslookupnsfview.GetDocumentByKey(EDRMSHOLDINGDBKEY$,True)
	If lookupdoc Is Nothing Then
		Print  edrmserrortext & " Cannot locate lookup document " & EDRMSHOLDINGDBKEY$
		edrms_get_helper_dbs = 96
	Else
		Set edrmsholdingdb = New NotesDatabase(lookupdoc.target_server(0),lookupdoc.path(0))
		If edrmsholdingdb Is Nothing Then
			Print edrmserrortext & " Cannot access database " & lookupdoc.target_server(0) & "!!" & lookupdoc.path(0)
			edrms_get_helper_dbs = 96
		End If 
	End If

' Get Counts Database
	Set lookupdoc = edrmslookupnsfview.GetDocumentByKey(EDRMSCOUNTSKEY$,True)
	If lookupdoc Is Nothing Then
		Print edrmserrortext & " Cannot locate lookup document " & EDRMSCOUNTSKEY$
		edrms_get_helper_dbs = 95
	Else
		Set edrmscountsdb = New NotesDatabase(lookupdoc.target_server(0),lookupdoc.path(0))
		If edrmscountsdb Is Nothing Then
			Print edrmserrortext & " Cannot access database " & lookupdoc.target_server(0) & "!!" & lookupdoc.path(0)
			edrms_get_helper_dbs = 95
		End If 
	End If

Exit Function
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_get_helper_dbs_errortext
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Function
End Function
Function edrms_findrole(role As String) As Integer
	On Error GoTo globalerrhandle
	Dim doc As NotesDocument
	Dim edrms_findrole_errtxt As String
	Dim eval As Variant
	Dim Indexresult As Variant

	edrms_findrole_errtxt = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	Set doc = edrmsdb.createdocument

	If(InStr(role,"[") = 0) Then
		role = "[" & role & "]"                                  ' cope with variable input
	End If

	eval = Evaluate("@UserNamesList", doc)      ' eval is a variant containing all the groups and roles current user belongs to

	Indexresult = ArrayGetIndex(eval,role)	            ' find the role in the variant array

	If(IsNull(indexresult)) Then
		edrms_findrole = 0                          ' role not found
	Else
		edrms_findrole = 1                          ' role found
	End If

Exit Function
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_findrole_errtxt
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Function
End Function



Sub edrms_agent_action_undeclare_request(agent As NotesAgent)
	On Error GoTo errhandle
	Dim ws As New NotesUIWorkspace
	Dim doc As NotesDocument
	Dim uidoc As NotesUIDocument
	Dim doclevel As String
	Dim msgtxt As String
	Dim responsereviewed As Integer
	Dim responseflag As Integer
	Dim recordflag As Integer
	Dim editorlevel As Integer

	edrmserrortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	Call initlog(agent.name)
	Set edrmsdc = edrmsdb.unprocesseddocuments
	Set doc = edrmsdc.getfirstdocument

	If edrmsdc.Count = 0 Then
		MessageBox "No records selected",16,edrmsdb.title &" " & EDRMSTERM$ & " Error"
		logaction("User informed no documents selected, exiting")
		Exit Sub
	End If

	If doc.IsUIDocOpen Then
		doclevel = "Yes"
	End If

' Make sure responses not selected...
	logaction("Checking for documents of type response, response to response or alert")

' TEST WHETHER RESPONSES AND DOCS NOT DECLARED AS RECORDS ARE IN THE SELECTION, ALSO CHECKS USER ACCESS
	Call edrms_check_responses_records(edrmsdc, responseflag, recordflag,editorlevel,0)

	If responseflag = 1 Then
		MessageBox "Please restrict your selection to top level documents only. Any response documents present "+_
		"will get picked up automatically if a parent document is selected.",16,edrmsdb.title &" " & EDRMSTERM$ & " Selection Contains Response Documents"
		logaction("User informed about response or response to response documents selected, exiting")
		Exit Sub
	End If

' Make sure only declared records are selected...

	If recordflag > 0 Then
		If doclevel = "Yes" Then
			MessageBox "This document cannot be undeclared as it is not a declared record." ,16,edrmsdb.title &" " & EDRMSTERM$ & " Not a Declared Record"
		Else
			MessageBox "Your selection includes documents that have not been declared. Please restrict your selection to declared " +_
			"records.",16,edrmsdb.title &" " & EDRMSTERM$ & " Selection Contains Undeclared Documents"
		End If
		logaction("User informed that a selected document is not a record, exiting")
		Exit Sub
	End If

	Set doc=edrmsdc.getfirstdocument

	While Not doc Is Nothing
		logaction("Undeclaring record " & doc.subject(0) & " and any response thread")
		Call edrms_undeclare_record(doc,EDRMSADMINS$)
		Set doc=edrmsdc.getnextdocument(doc)
	Wend

	If edrmsdc.Count = 1 Then
		If doclevel = "Yes" Then
			msgtxt = "This record has been undeclared"
		Else
			msgtxt = "The selected record has been undeclared"
		End If
	Else
		msgtxt = "The " + CStr(edrmsdc.Count) + " selected records have been undeclared"
	End If

	Call ws.viewrefresh

	MessageBox msgtxt,64,edrmsdb.title &" " & EDRMSTERM$ & " Undeclare Action Complete"
	logclose("User informed : " & msgtxt)

	If doclevel = "Yes" Then
		Set uidoc=ws.currentdocument
		Call uidoc.close
		Call ws.viewrefresh
	End If

	Exit Sub
errhandle:
	Call logerror(Err, Error, Erl, LSI_Info(2), LSI_Info(12), " Last module before this call " & edrmserrortext )   ' LOGS HELPFUL DETAIL ON AN ERROR
	Call logaction(" Last Global Error " & edrmslastglobalerr)
	Call alerterrors(agent.name ,"Error")     ' EMAILS THE ERROR ALERT TO ADDRESS IN PROFILE
	Exit Sub
End Sub
Sub edrms_util_doinsertsort ( sA() As String, ByVal bottom As Long, ByVal top As Long,sortorder As String )
	On Error GoTo globalerrhandle
	Dim edrms_util_doinsertsort_errortext As String
	Dim v As String
	Dim i As Long
	Dim x As Long
	Dim Found As Integer

	edrms_util_doinsertsort_errortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	If UCase(sortorder) = "DESC" Then
		For i = bottom+1 To top
			x = i
			v = sA (i )
			Do While (sA(x-1) < v)   ' SORT DESCENDING
				sA ( x ) = sA ( x-1 )
				x = x - 1
				If x=0 Then
					Exit Do
				End If
			Loop
			sA (x) = v
		Next
		
	Else

		For i = bottom+1 To top
			x = i
			v = sA (i )
			Do While (sA(x-1) > v)   ' SORT ASCENDING
				sA ( x ) = sA ( x-1 )
				x = x - 1
				If x=0 Then
					Exit Do
				End If
			Loop
			sA (x) = v
		Next
		
	End If	
		
	Exit Sub
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_util_doinsertsort_errortext
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Sub
End Sub
Sub edrms_quc(source As NotesUIDocument, continue As Variant)
	On Error GoTo globalerrhandle
	Dim ws As New NotesUIWorkspace
	Dim parentdoc As NotesDocument
	Dim edrms_quc_errortext As String
	
	edrms_quc_errortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	
	If source.document.isresponse And source.Editmode Then
		Set parentdoc = edrmsdb.Getdocumentbyunid(source.document.ParentDocumentUNID)
		If Not parentdoc Is Nothing Then
			If parentdoc.hasitem("edrmsrecord") then
				If parentdoc.edrmsrecord(0) = "Yes" Then
					Call edrms_declare_set_values(source.Document,parentdoc.edrmscategory(0),edrmscurrentuser.abbreviated)
					MsgBox "This response has been declared as a record so can no longer be amended",64,edrmsdb.title &" " & EDRMSTERM$ & " Information"
					Call ws.Viewrefresh()
				End If
			End If
		End If
	End If
Exit Sub
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_quc_errortext
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Sub
End Sub
Sub edrms_choose_bdb(bdb As NotesDatabase)
	On Error GoTo globalerrhandle
	Dim ws As New NotesUIWorkspace
	Dim doc As NotesDocument
	Dim edrms_choose_bdb_errortext As String
	Dim retval As Variant
	edrms_choose_bdb_errortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	retval = ws.PickListStrings(PICKLIST_CUSTOM,False,edrmsdb.server,LOOKUPNSF$,LOOKUPBDB$,edrmsdb.title & " " & EDRMSTERM$ & " Target BDB Selector", "Please Choose A BDB",1)
	If(IsEmpty(retval)) Then
		MessageBox "No database chosen, exiting",16,edrmsdb.title &" " & EDRMSTERM$ & " Exiting"
		Exit Sub
	End If

	Set doc = edrmslookupbdbview.getdocumentbykey(retval(0),True)
	If doc Is Nothing Then
		MessageBox "Database selection error, exiting",16,edrmsdb.title &" " & EDRMSTERM$ & " Exiting"
		Exit Sub
	End If

	Set bdb = New NotesDatabase(doc.target_server(0), doc.path(0))
	If bdb Is Nothing Then
		MessageBox "BDB " & retval(0) & " not found.",16,edrmsdb.title & " " & EDRMSTERM$ & " Aborting"
		Exit Sub
	End If

	Exit Sub
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_choose_bdb_errortext
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Sub
End Sub
Sub edrms_agent_declare_multiple_documents(agent As NotesAgent)
	On Error GoTo errhandle
	Const MODE$ = "DECLARE"
	Dim ws As New NotesUIWorkspace
	Dim dcr As notesdocumentcollection
	Dim doc As NotesDocument
	Dim editoraccess As String
	Dim msg As String
	Dim responseflag As Integer
	Dim responsecheck As Integer
	Dim recorddeclaredflag As Integer
	Dim totct As Long
	Dim unprocessedct As Integer
	Dim oldsecmarking As Integer
	Dim recordflag  As Integer
	Dim editorlevel As Integer
	Dim editoraccesscheck As Integer
	Dim provversionflag As Integer
	Dim reviewdate As Variant
	responseflag = 0
	recorddeclaredflag = 0
	totct = 0
	unprocessedct = 0
	oldsecmarking = 0
	responsecheck = 0
	provversionflag = 0
	editoraccesscheck = 0

	edrmserrortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	Call initlog(agent.name)

	Set edrmsdc = edrmsdb.UnprocessedDocuments
	totct = edrmsdc.Count
	
	If edrmsdc.Count = 0 Then
		MessageBox "No documents selected",16,edrmsdb.title &" " & EDRMSTERM$ & " exiting"
		Call logclose("User exited as no documents were selected")
		Exit Sub
	End If

	If edrmsdc.Count = 1 Then
		MessageBox "This action can only be used where multiple documents are selected",16,edrmsdb.title &" " & EDRMSTERM$ & " exiting"
		Call logclose("User exited as only one document was selected")
		Exit Sub
	End If
	
	' The maximum number of documents that can be declared in one go checked (held in edrms profile)
	If edrmsdc.count > edrmsmaxdeclarelimit Then
		MessageBox "The number of documents selected (" + CStr(edrmsdc.Count) + "), exceeds the maximum number " +_
		"of documents allowed to be declared at any one time (" + CStr(edrmsmaxdeclarelimit) + _
		"). Please refine your selection.",16,edrmsdb.title &" " & EDRMSTERM$ & " Too Many Documents Selected"
		Call logclose("User informed : The number of documents selected (" + CStr(edrmsdc.Count) + "), exceeds the maximum number ")
		Exit Sub
	End If
	
	Set doc = edrmsdc.getfirstdocument
	
	While Not doc Is Nothing
		If Not doc.Isresponse Then
			logaction("Main Document subject: " & doc.subject(0)) 
			editoraccess = ""
			Call edrms_get_doc_access(doc,editoraccess)
			If editoraccess <> "Yes" Then
				msg = "You are not an eligible editor of all the top-level selected documents, you need either higher database access or to be a named editor of the documents"
				MessageBox msg ,16, edrmsdb.title &" " & EDRMSTERM$ & " Access Error"
				Call logclose("User informed " & msg)
				Exit Sub
			End If
		End If
		
		edrmsoldsecmarking = 0 ' GLOBAL
		Call edrms_check_responses_records(edrmsdc, responseflag, recordflag,editorlevel,0)
		
		If editorlevel > 0 Then
			editoraccesscheck = 1
		End If

		If responseflag = 1 And (recordflag = 0 Or recordflag = 2) Then
			MessageBox "The selection contains both Response documents and documents that have already been declared. Please refine your selection",16,edrmsdb.title &" " & EDRMSTERM$ & " exiting"
			Call logclose("User informed : The selection contains both Response documents and documents that have already been declared. Please refine your selection")
			Exit Sub
		ElseIf responseflag = 1 Then
			MessageBox "The selection contains Response documents. Please refine your selection",16,edrmsdb.title &" " & EDRMSTERM$ & " exiting"
			Call logclose("User informed : The selection contains Response documents. Please refine your selection")
			Exit Sub
		ElseIf  (recordflag = 0 Or recordflag = 2) Then
			MessageBox "The selection contains documents that have already been declared. Please refine your selection",16,edrmsdb.title &" " & EDRMSTERM$ & " exiting"
			Call logclose("User informed : The selection contains documents that have already been declared. Please refine your selection")
			Exit Sub
		ElseIf edrmsoldsecmarking = 1 Then
			MessageBox "The selection contains documents with Secuity Markings that are no longer valid. " +_
			"Please edit these documents and use Doc Actions -> Amend Security Markings to select a new value before " +_
			"rerunning this action.",16,edrmsdb.title &" " & EDRMSTERM$ & " Security Marking Error"
			Call logclose("User informed : The selection contains documents with Secuity Markings that are no longer valid - Fix them")
			Exit Sub
		End If
		
		Set doc=edrmsdc.GetNextDocument(doc)
	Wend

	edrmsretval = edrms_choose_record_category
	If IsEmpty(edrmsretval) Then
		MsgBox "No Record Type chosen, exiting the declaration.",16,edrmsdb.title &" " & EDRMSTERM$ & " Exiting Amend record type "
		Call logclose("User made no valid Record category choice, exited")
		Exit Sub
	End If

	' Advise user if they don't have enough access to all responses

	If editoraccesscheck = 1 Then
		MessageBox "Some of the documents being declared have responses to which you do not have edit access. The selected documents " +_
		"will be declared now with declaration of responses being completed overnight tonight.",64,edrmsdb.title &" " & EDRMSTERM$
		Call logaction("User informed : Some of the documents being declared have responses to which you do not have edit access")
	End If

	Call logaction("Main declaration loop begins")
	Set doc=edrmsdc.GetFirstDocument

	While Not doc Is Nothing

		If doc.bfdate(0) <> "" Then
			MessageBox "You cannot declare document " + doc.subject(0) + " as it is has a b/f date set. "  + Chr(10) + Chr(10) +_
			"This setting needs to be cleared before the document can be declared as a record",64,edrmsdb.title &" " & EDRMSTERM$
			Call logaction("User informed : You cannot declare document " + doc.subject(0) + " as it is has a b/f date set.")
			unprocessedct = unprocessedct + 1
			totct = totct - 1
			GoTo nextrec
		End If

		If doc.HasItem("provversionno") Then
			If doc.provversionno(0) > 0 Then
				provversionflag = provversionflag + 1
				MessageBox "You cannot declare document " + doc.subject(0) + " as it is unprocessed version. " +_
				"This document can only be declared as an individual document.",16,edrmsdb.title &" " & EDRMSTERM$
				Call logaction("User informed : You cannot declare document " + doc.subject(0) + " as it is unprocessed version")
				unprocessedct = unprocessedct + 1
				totct = totct - 1
				GoTo nextrec
			End If
		End If

		Call logaction("Declaring " & doc.subject(0) & " as a record of category " & CStr(edrmsretval))
		Call edrms_declare_set_values(doc,CStr(edrmsretval),edrmscurrentuser.Abbreviated)
		Set dcr = doc.responses
		Call edrms_check_responses_records(dcr, responseflag, recordflag,editorlevel,0)
		If editorlevel > 0 Or editoraccesscheck = 1 Then
			doc.edrmsdelayedflag = 1       ' Some responses will need to be updated ovenight due to user not being elgible author
			Call doc.save(True,True)
			Call logaction(doc.subject(0) & " has responses which will need declaring overnight, delayed flag set")
		Else
			Call logaction("Declaring all responses to " & doc.subject(0))
			edrmslimitedaccessflag = 0
			Call edrms_recurse_responses(doc, MODE$,CStr(edrmsretval),edrmscurrentuser.Abbreviated,"",Nothing,Nothing,0,0)
			If edrmslimitedaccessflag = 1 Then
				doc.edrmsdelayedflag = 1       ' Some responses will need to be updated ovenight due to user not having access to all docs in the thread
				Call doc.save(True,True)
				Call logaction(doc.subject(0) & " has limited access responses which will need declaring overnight, delayed flag set")
			End If
		End If

nextrec:
		Set doc=edrmsdc.GetNextDocument(doc)
	Wend

	Call ws.viewrefresh
	Call edrms_deselect_docs(ws)

	If totct > 1 Then
		If unprocessedct = 0 Then
			MessageBox "The " + CStr(totct) + " selected documents have been declared.",64,edrmsdb.title &" " & EDRMSTERM$
		ElseIf unprocessedct = 1 Then
			MessageBox CStr(totct) + " document(s) have been declared. 1 document could not be processed.",64,edrmsdb.title &" " & EDRMSTERM$
		Else
			MessageBox CStr(totct) + " document(s) have been declared. " + CStr(unprocessedct) + " document(s) could not be processed.",64,edrmsdb.title &" " & EDRMSTERM$
		End If
	Else
		If totct > 0 Then
			If unprocessedct = 1 Then
				MessageBox "One of the selected documents has been declared. 1 document could not be processed.",64,edrmsdb.title &" " & EDRMSTERM$
			Else
				MessageBox "One of the selected documents has been declared. " + CStr(unprocessedct) + " document(s) could not be processed.",64,edrmsdb.title &" " & EDRMSTERM$
			End If
		Else
			MessageBox "None of the selected documents have been declared.",64,edrmsdb.title &" " & EDRMSTERM$
		End If
	End If

	Call logclose("")
	Exit Sub
errhandle:
	Call logerror(Err, Error, Erl, LSI_Info(2), LSI_Info(12), " Last module before this call " & edrmserrortext )   ' LOGS HELPFUL DETAIL ON AN ERROR
	Call logaction(" Last Global Error " & edrmslastglobalerr)
	Call alerterrors(agent.name ,"Error")     ' EMAILS THE ERROR ALERT TO ADDRESS IN PROFILE
	Exit Sub
End Sub
Sub edrms_agent_deleted_documents_sweep(Agent As NotesAgent)
	On Error GoTo errhandle
	Dim view As NotesView
	Dim versionview As NotesView
	Dim vc As NotesViewEntryCollection
	Dim entry As NotesViewEntry
	Dim doc As NotesDocument
	Dim versiondoc As NotesDocument
	Dim anotherversiondoc As NotesDocument
	Dim agentruntime As New NotesDateTime(Now)
	Dim helperdbsret As Integer
	Dim multipleversions As Integer
	
	If edrmssess.Isonserver Then
		If (edrmsdbservernn.common <> edrmsmasterservernn.common) Then
			Exit Sub   ' When run scheduled, not on master server so exit
		End If
	End If

	edrmserrortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	Call initlog(agent.name)

	logaction("Getting DB handles to edrmsncddb, edrmsnabdb, edrmsmetadatadb, edrmsholdingdb, edrmscountsdb")
	helperdbsret = edrms_get_helper_dbs
	If helperdbsret > 0 Then
		logaction("Error getting one or more of the required external databases, check the Lookup.nsf and the default accesses to these DBs, error code = " & CStr(helperdbsret))
		logaction("Error codes: NCD = 99, NAB = 98, EDRMS Management DB = 97, EDRMS Holding DB = 96, EDRMS Counts DB = 95")
		Call alerterrors(agent.name ,"Error with external databases, error code " & CStr(helperdbsret))
		Exit Sub
	End If

	Set view=edrmsdb.getview("DeletedDocs")
	Set versionview=edrmsdb.getview("EDRMSV4")
	Set vc = view.allentries
	If vc.count = 0 Then
		Call logclose("No documents to delete, exiting")
		Exit Sub
	End If

' Check if any docs are versions. Tidy up if they are...
	logaction("Looping though " & CStr(vc.count) & " documents")
	Set doc = view.getfirstdocument
	While Not doc Is Nothing
		If doc.form(0) = "Response" Or doc.form(0) = "Response to Response" Or doc.form(0) = "Alert" Then
			If doc.hasitem("responseonly") Then
				doc.form = "Document"
				doc.subject = doc.originalresponsesubject(0)
				doc.RemoveItem( "$Ref" )
				doc.gk_status = "Default"
				doc.version = 0
				Call doc.save(True,True)
			End If
		Else
			If doc.hasitem("Version") Then
				If doc.version(0) > 0 Then
					Set versiondoc = versionview.GetDocumentByKey(doc.clonedfrom(0))
					
					If versiondoc Is Nothing Then
						GoTo nextdoc     ' DJS Stop versioning erroring June 2017
					End If
					
					multipleversions% = 0
					Set anotherversiondoc = versionview.getdocumentbykey(versiondoc.clonedfrom(0))
					If Not anotherversiondoc Is Nothing Then
						multipleversions% = 1
					End If
					If multipleversions% = 0 Then
						versiondoc.clonedto = ""
						versiondoc.clonedfrom = ""
						versiondoc.versionno = 0
						versiondoc.version = 0
						Call versiondoc.Save(True,True)
					Else
						versiondoc.clonedto = ""
						Call versiondoc.Save(True,True)
					End If
				End If
			End If
		End If

nextdoc:

		Set doc=view.getnextdocument(doc)
	Wend

	Call vc.StampAll("holdingdbtransferdate",agentruntime.dateonly)
	Call vc.stampall("sourcebdbtitle",edrmsdb.Title)
	Call vc.stampall("sourcebdbpath",edrmsdb.filepath)
	Set entry = vc.GetFirstEntry()

	Set doc=entry.document
	While Not entry Is Nothing
		logaction("Copying " & doc.subject(0) & " to "  & edrmsholdingdb.title)
		Call doc.copytodatabase(edrmsholdingdb)
		Set entry=vc.getnextentry(entry)
		If Not entry Is Nothing Then
			Set doc=entry.document
		End If
	Wend

	logaction("Deleting " & CStr(vc.count) & " documents in scope")      ' DJS June 2017 
	Call vc.removeall(True)

	Call logclose("")

Exit Sub
errhandle:
Call logerror(Err, Error, Erl, LSI_Info(2), LSI_Info(12), " Last module before this call " & edrmserrortext )   ' LOGS HELPFUL DETAIL ON AN ERROR
Call logaction(" Last Global Error " & edrmslastglobalerr)
Call alerterrors(agent.name ,"Error")     ' EMAILS THE ERROR ALERT TO ADDRESS IN PROFILE
Exit Sub
End Sub
Sub edrms_agent_amend_readers(Agent As NotesAgent)
	On Error GoTo errhandle
	Const DELIMITER$ = ","
	Dim ws As New NotesUIWorkspace
	Dim doc As NotesDocument
	Dim readersdoc As NotesDocument
	Dim amendreadersdoc  As NotesDocument
	Dim item As NotesItem
	Dim logmsg As String
	Dim existingreadlist As String
	Dim newreadlist As String
	Dim existinggroupaccess As String
	Dim newgroupaccess As String
	Dim editoraccess As String
	Dim updcnt As Long
	Dim replyval As Variant
	Dim evaluatevar As Variant
	Dim dialogret As Boolean

	updcnt = 0
	dialogret = False

	edrmserrortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	Call initlog(agent.name)
	Set edrmsdc = edrmsdb.unprocesseddocuments
	Set doc = edrmsdc.getfirstdocument

	If (edrmsdc.Count = 0) Then
		MessageBox "Please select a document to add or remove readers for",48,edrmsdb.title &" " & EDRMSTERM$ & " Exiting"
		logclose("User informed that no documents were selected and exited")
		Exit Sub
	End If

	Set readersdoc = New NotesDocument(edrmsdb)
	readersdoc.readlist_current = doc.readlist
	readersdoc.groupaccess_current = doc.groupaccess
	readersdoc.m_secure_current = doc.m_secure
popup:
	dialogret =  ws.dialogBox( "_edrmsreadersdialog",True,True , , , , ,edrmsdb.title &" " & EDRMSTERM$ & " Amend Readers",readersdoc)
	If dialogret = False Then
		logclose("User cancelled at the Dialog box prompt")
		Exit Sub
	End If

	If readersdoc.m_secure_new(0) = "Limit Access" Then
		If  readersdoc.readlist_new(0) = "" And  readersdoc.groupaccess_new(0) = "" Then
			MessageBox "You have selected 'Limit Access' but have not listed anyone in the access fields. Please select users to give read access to, or change the access level to 'Public' or 'Private'.",64,edrmsdb.title &" " & EDRMSTERM$ & " Amend Readers"
			GoTo popup
		End If
	ElseIf readersdoc.m_secure_new(0) <> "Limit Access" Then
		If readersdoc.readlist_new(0) <> "" Or  readersdoc.groupaccess_new(0) <> "" Then
			MessageBox "You have selected users in the access fields but have not selected 'Limit Access'. Please remove users from the access fields, or change the access level to 'Limit Access'.",64,edrmsdb.title &" " & EDRMSTERM$ & " Amend Readers"
			GoTo popup
		End If
	End If

	logmsg = "Document read access updated"
	logmsg = logmsg & Chr(10) & "Previous access level: " & doc.m_secure(0)
	logmsg = logmsg & Chr(10) & "New access level: " & readersdoc.m_secure_new(0)

	If edrms_util_implodearray(doc.readlist,DELIMITER$) = "" Then
		existingreadlist = "No users selected"
	Else
		existingreadlist = edrms_util_implodearray(doc.readlist,DELIMITER$)
	End If
	logmsg = logmsg & Chr(10) & "Previous readlist: " & existingreadlist

	If edrms_util_implodearray(readersdoc.readlist_new,DELIMITER$) = "" Then
		newreadlist = "No users selected"
	Else
		newreadlist = edrms_util_implodearray(readersdoc.readlist_new,DELIMITER$)
	End If
	logmsg = logmsg & Chr(10) & "New Readlist: " & newreadlist

	If edrms_util_implodearray(doc.groupaccess,DELIMITER$) = "" Then
		existinggroupaccess = "No groups selected"
	Else
		existinggroupaccess = edrms_util_implodearray(doc.groupaccess,DELIMITER$)
	End If
	logmsg = logmsg & Chr(10) & "Previous groupaccess: " & existinggroupaccess

	If edrms_util_implodearray(readersdoc.groupaccess_new,DELIMITER$) = "" Then
		newgroupaccess = "No groups selected"
	Else
		newgroupaccess =  edrms_util_implodearray(readersdoc.groupaccess_new,DELIMITER$)
	End If
	logmsg = logmsg & Chr(10) & "New Groupaccess: " & newgroupaccess

	logaction("User prompted to confirm the changes " & logmsg)

	replyval = MessageBox("Are you sure you want to amend the read access for these "& CStr(edrmsdc.count)&" document(s)",36,edrmsdb.title &" " & EDRMSTERM$ & " Amend Readers")
	If replyval = 7 Then
		logclose("User cancelled at the confirmation prompt")
		Exit Sub
	End If

	Do Until doc Is Nothing

		editoraccess = ""
		Call edrms_get_doc_access(doc,editoraccess)
		If editoraccess = "Yes" Then

			doc.m_secure = readersdoc.m_secure_new(0)

			If readersdoc.m_secure_new(0) = "Public" Then
				logaction("Updating " & doc.subject(0) & " To Public")
				doc.privacy = ""
				doc.documentreaders = ""
				doc.scope = "Public"
				doc.groupaccess = ""
				doc.readlist = ""
				doc.reeders_disp = ""

			ElseIf readersdoc.m_secure_new(0) = "Private" Then
				logaction("Updating " & doc.subject(0) & " To Private")
				doc.documentreaders = edrmssess.Username                   ' doc.from(0)  UNRELIABLE AS IT IS COMMON NAME 
				doc.groupaccess = ""
				doc.readlist = ""
				doc.privacy = "[private]"
				doc.scope = "Private"
				doc.reeders_disp = ""

			ElseIf readersdoc.m_secure_new(0) = "Limit Access" Then
				logaction("Updating " & doc.subject(0) & " To Limit Access")
				doc.documentreaders = ""
				doc.groupaccess = readersdoc.groupaccess_new
				doc.readlist = readersdoc.readlist_new
				doc.scope = "Public"
				doc.privacy = "[private]"

				Dim evalreadlistdoc As New NotesDocument(edrmsdb)
				evalreadlistdoc.from = doc.from
				evalreadlistdoc.readlist =  readersdoc.readlist_new
				evalreadlistdoc.authorlist = doc.authorlist
				evalreadlistdoc.groupaccess =  readersdoc.groupaccess_new
				doc.reeders_disp = Evaluate({@Unique(@Name([CN];From):@Name([CN];readlist):@Name([CN];authorlist):@Name([Abbreviate];groupaccess))},evalreadlistdoc)

			End If

			Call edrms_update_log(doc,"readaccessamendments",logmsg,edrmscurrentuser.Abbreviated)

			Call doc.save(True,True)
			updcnt = updcnt + 1

		Else

			MessageBox "You are not an allowable author (editor) of the selected document " & doc.subject(0),16,edrmsdb.title &" " & EDRMSTERM$ & " Amend Readers"
			logaction(" User informed that they are not an allowable author (editor) of the selected document " & doc.subject(0))
		End If

		Set doc = edrmsdc.GetNextDocument(doc)

	Loop
	
	Call edrms_deselect_docs(ws)
	Call logclose("Ends OK, Updated " & CStr(updcnt))

Exit Sub

errhandle:
Call logerror(Err, Error, Erl, LSI_Info(2), LSI_Info(12), " Last module before this call " & edrmserrortext )   ' LOGS HELPFUL DETAIL ON AN ERROR
Call logaction(" Last Global Error " & edrmslastglobalerr)
Call alerterrors(agent.name ,"Error")     ' EMAILS THE ERROR ALERT TO ADDRESS IN PROFILE
Exit Sub
End Sub
Function edrms_qmc(Source As NotesUIDocument, Continue As Variant)
	On Error GoTo globalerrhandle
	Dim edrms_qmc_errortext As String
	edrms_qmc_errortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	If Not source.isnewdoc Then
		Call edrms_check_declare(source.document, Continue)
	End If
Exit Function
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_qmc_errortext
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Function
End Function
Sub edrms_agent_mark_responses_for_deletion(Agent As NotesAgent)
	On Error GoTo errhandle
	Dim ws As New NotesUIWorkspace
	Dim uiview As NotesUIView
	Dim responsedc As NotesDocumentCollection
	Dim doc As NotesDocument
	Dim responsedoc As NotesDocument
	Dim msg As String
	Dim responseflag As Integer
	Dim recordflag As Integer
	Dim editorlevel As Integer
	Dim responsesmarked As Long
	Dim docsdeleted As Long
	Dim replyval As Variant

	responseflag = 0
	recordflag = 0
	editorlevel = 0
	responsesmarked = 0
	docsdeleted = 0

	edrmserrortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	Call initlog(agent.name)

	Set uiview = ws.CurrentView
	Set edrmsdc = edrmsdb.unprocesseddocuments
	Set doc = edrmsdc.getfirstdocument

	If edrmsdc.count = 0 Then
		MessageBox "Please select a document",16,edrmsdb.title &" " & EDRMSTERM$ & " No document selected"
		logclose("User had not selected any documents, told to do so and code exited")
		Exit Sub
	End If

	Call edrms_check_responses_records(edrmsdc, responseflag, recordflag,editorlevel,0)

' Check that only responses selected
	If responseflag = -1 Then
		MessageBox "Your selection includes non Response documents. Please refine your selection",16,edrmsdb.title &" " & EDRMSTERM$ & " Invalid Selection"
		logclose("User had selected main documents, told to only select response docs and code exited")
		Exit Sub
	End If

	If recordflag <> 1 Then
		MessageBox "Some of the documents you have selected are declared as " & EDRMSTERM$ &" records (or are pending declaration), please amend your selection to exclude these" _
		,16,edrmsdb.title &" " & EDRMSTERM$ & " Exiting"
		logclose("User has been informed that they have included declared documents and exited.")
		Exit Sub
	End If

	If editorlevel > 0 Then
		MessageBox "You are not an eligible editor to one or more of the selected documents, they " &_
		" cannot therefore be marked for deletion. Please revise your selection before trying again.",16,edrmsdb.title &" " & EDRMSTERM$
		logaction("User informed that they are not eligible editors to all responses and exited")
		Exit Sub
	End If

	While Not doc Is Nothing
' Check document not already marked
		If doc.hasitem("softdeleteddocsflag") Then     ' This was field "responseonly" which is an integer
			If doc.softdeleteddocsflag(0) = "1" Then         ' This was field "responseonly"  which is an integer
				MessageBox "Your selection includes documents already marked for deletion. Please refine your " +_
				"selection.",16,edrmsdb.title &" " & EDRMSTERM$ & " Invalid Selection"
				logclose("User has been informed that they have included documents already marked for deletion and exited.")
				Exit Sub
			End If
		End If

' Check selection does not include responses that have responses. OK if responses have already been marked..
		Set responsedc = doc.responses
		If responsedc.count > 0 Then
			responsesmarked = 0

			Set responsedoc = responsedc.getfirstdocument
			While Not responsedoc Is Nothing
				If responsedoc.hasitem("softdeleteddocsflag")Then    ' This was field "responseonly"  which is an integer
					If responsedoc.softdeleteddocsflag(0) = "1" Then        ' This was field "responseonly"  which is an integer
						responsesmarked = 1
					End If
				Else
					responsesmarked = 0
				End If
' Check that response not part of selection...
				If edrmsdc.Contains(responsedoc) Then
					responsesmarked = 1
				End If
				Set responsedoc = responsedc.getnextdocument(responsedoc)
			Wend

			If responsesmarked = 0 Then
				MessageBox "Your selection includes responses which also have responses which have not been selected. " +_
				"You cannot mark such responses in isolation as this would " +_
				"orphan the remaining response(s)." ,16,edrmsdb.title &" " & EDRMSTERM$ & " Invalid Selection"
				logclose("User has been informed that they have missed some responses to selected docs and exited.")
				Exit Sub
			End If
		End If

		Set doc = edrmsdc.getnextdocument(doc)
	Wend

	msg = "This will mark the " + CStr(edrmsdc.count) + " selected responses for deletion. Continue?"
	logaction("User prompted : " & msg)
	replyval = MessageBox(msg,36,edrmsdb.title &" " & EDRMSTERM$ & " Confirmation Required")
	If replyval = 7 Then
		MessageBox "Action aborted",64,edrmsdb.title &" " & EDRMSTERM$ & " Exiting"
		logclose("User aborted at confirmation prompt")
		Exit Sub
	End If

	Set doc = edrmsdc.getfirstdocument
	While Not doc Is Nothing
		logaction("Marking document " & doc.subject(0) & " for deletion")

		doc.softdeleteddocsflag = "1"
		doc.responseonly = 1
		doc.softdeletedby = edrmscurrentuser.Abbreviated
		doc.softdeleteddate = Now
		doc.originalresponsesubject = doc.subject(0)
		doc.subject = "PENDING DELETION " + doc.subject(0)
		doc.parentunid = doc.parentdocumentunid

		Call edrms_update_log(doc,EDRMSDELETELOG$,"Marked For deletion On BDB " & edrmsdb.title + " On " ,edrmscurrentuser.Abbreviated)
		Call doc.save(True,True)
		docsdeleted = docsdeleted + 1

		Set doc = edrmsdc.getnextdocument(doc)
	Wend

	Call uiview.DeselectAll
	Call ws.viewrefresh

	If docsdeleted = 0 Then
		msg = "No responses could be marked for deletion"
	Else
		msg = CStr(docsdeleted) + " response(s) were marked for deletion and will be deleted from the database within the next week."
	End If

	MsgBox msg,64,edrmsdb.title &" " & EDRMSTERM$ & "Delete Action Complete"
	Call logclose("User informed " & msg)

Exit Sub
errhandle:
Call logerror(Err, Error, Erl, LSI_Info(2), LSI_Info(12), " Last module before this call " & edrmserrortext )   ' LOGS HELPFUL DETAIL ON AN ERROR
Call logaction(" Last Global Error " & edrmslastglobalerr)
Call alerterrors(agent.name ,"Error")     ' EMAILS THE ERROR ALERT TO ADDRESS IN PROFILE
Exit Sub
End Sub
Sub edrms_agent_review_records_required(Agent As NotesAgent)
	On Error GoTo errhandle
	Const MODE$ = "MARKREVIEW"
	Const REVIEWSTATUS$ = "Re-declared"
	Dim ws As New NotesUIWorkspace
	Dim doc As NotesDocument
	Dim uidoc As NotesUIDocument
	Dim doclevel As String
	Dim msg As String
	Dim msg1 As String
	Dim msg2 As String
	Dim msg3 As String
	Dim editoraccess As String
	Dim responseflag As Integer
	Dim recordflag As Integer
	Dim editorlevel As Integer
	Dim categoryflag As Integer
	Dim errorcnt As Integer
	Dim returncode As Integer
	Dim loopcnt As integer
	Dim responsereviewed As Long
	Dim reviewed As Long
	Dim replyval As Variant
	Dim reviewdate As Variant

	responseflag = 0
	reviewed = 0
	responsereviewed = 0
	errorcnt = 0
	returncode = 0

	edrmserrortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	Call initlog(agent.name)

	Set edrmsdc = edrmsdb.unprocesseddocuments
	
' Firstly check that the user is eligible editor to the top level docs
	logaction("Check that the user is eligible editor to the top level docs")
	Set doc = edrmsdc.getfirstdocument

	While Not doc Is Nothing
		If Not doc.Isresponse Then
			logaction("Main Document subject: " & doc.subject(0)) 
			editoraccess = ""
			Call edrms_get_doc_access(doc,editoraccess)
			If editoraccess <> "Yes" Then
				msg3 = "You are not an eligible editor of all the top-level selected documents, you need either higher database access or to be a named editor of the documents"
				MessageBox msg3 ,16, edrmsdb.title &" " & EDRMSTERM$ & " Access Error"
				logclose("User informed " & msg3)
				Exit Sub
			End If
		End If
		Set doc=edrmsdc.GetNextDocument(doc)
	Wend

	logaction("Calling sub edrms_review_checks which performs checks on selected docs and their responses")
	Call edrms_review_checks(edrmsdc,REVIEWSTATUS$,returncode,editorlevel)
	If returncode > 0 Then
		logclose("Returned from edrms_review_checks with exit code " & CStr(returncode) & " user will have been informed why, exiting")
		Exit Sub
	End If

	logaction("Main processing loop")
	Set doc = edrmsdc.getfirstdocument

	While Not doc Is Nothing

		' Check the record has a record category

		If  doc.edrmscategory(0) = "" Then
			msg1 = "This record " & doc.subject(0) & " does not have an " & EDRMSTERM$  & " category present. " +_
			"This value will need to be set before the record can be redeclared."
			msg2 = EDRMSTERM$  & " Categories Missing from Selected Record"
			MessageBox msg1,16,edrmsdb.title &" " & EDRMSTERM$ & " " & msg2
			errorcnt = errorcnt + 1
			logaction("User informed " & msg1 & " skip to next record")
			GoTo nextrec
		End If

		loopcnt = 0
calcreviewdate:
		reviewdate = doc.edrmsreviewdate        ' Populate with current review date
		Call edrms_calculate_review_date( doc.edrmscategory(0), reviewdate)
		If InStr(reviewdate,"Error") <> 0 Then
			loopcnt = loopcnt + 1
			If loopcnt > 3 Then  ' catch any kind of loop condition caused either by the user not understanding or some undefined issue
				GoTo nextrec				
			End If
			msg1 = "The record ''" + doc.subject(0) + "'' has an ''" & EDRMSTERM$  & "' category value present which can not be found " +_
			"on the Master List. Please choose the appropriate category from the list that will be presented."
			msg2 = "Invalid ''" & EDRMSTERM$  & "' Category Present on Selected Record"
			MessageBox msg1,16,edrmsdb.title &" " & EDRMSTERM$ & " " & msg2
			logaction("User informed " & msg1)
			logaction("User presented with category choice popup")
			doc.edrmscategory = edrms_choose_record_category
			logaction("User chose the category " & doc.edrmscategory(0) & " control passed back to the edrms_calculate_review_date function")
			GoTo calcreviewdate
		End If

		Call edrms_mark_review_status(doc,REVIEWSTATUS$,reviewed,edrmscurrentuser.abbreviated,reviewdate,doc.edrmscategory(0))  ' doc save is in here
		logaction("Main doc marked as " & REVIEWSTATUS$  & " " & doc.subject(0))

		' RECURSE RESPONSES HERE
		If editorlevel = 0 Then           ' Current user is eligible editor to all responses
			logaction("Recursing response thread")
			edrmslimitedaccessflag = 0
			Call edrms_recurse_responses(doc,MODE$,REVIEWSTATUS$,edrmscurrentuser.abbreviated,CStr(reviewdate),Nothing,Nothing,responsereviewed,errorcnt)
			If edrmslimitedaccessflag = 1 Then
				doc.edrmsdelayedflag = 2       ' Some responses will need to be updated ovenight due to user not having access to all docs in the thread
				Call doc.save(True,True)
				Call logaction(doc.subject(0) & " has limited access responses which will need updating overnight, delayed flag set")
			End If
		Else
			logaction("User does not have high enough access to recurse response thread so delayed flag set")
			doc.edrmsdelayedflag = 2
			Call doc.save(True,True)
		End If

nextrec:
		Set doc=edrmsdc.GetNextDocument(doc)

	Wend

	Call edrms_review_report(REVIEWSTATUS$,responsereviewed,errorcnt,reviewed,msg)
	logaction("User Messagebox : " & msg)

	If doclevel = "Yes" Then
		Set uidoc=ws.currentdocument
		Call uidoc.close
	Else
		Call edrms_deselect_docs(ws)
	End If
	Call ws.viewrefresh

	Call logclose("Ends OK")

	Exit Sub
errhandle:
	Call logerror(Err, Error, Erl, LSI_Info(2), LSI_Info(12), " Last module before this call " & edrmserrortext )   ' LOGS HELPFUL DETAIL ON AN ERROR
	Call logaction(" Last Global Error " & edrmslastglobalerr)
	Call alerterrors(agent.name ,"Error")     ' EMAILS THE ERROR ALERT TO ADDRESS IN PROFILE
	Exit Sub

End Sub
Sub edrms_agent_undeclare_records_request(agent As NotesAgent)
	On Error GoTo errhandle
	Dim ws As New NotesUIWorkspace
	Dim doc As NotesDocument
	Dim emaildoc As NotesDocument
	Dim rtitem As NotesRichTextItem
	Dim rs1 As NotesRichTextStyle
	Dim rsnormal As NotesRichTextStyle
	Dim msg As String
	Dim notdeclaredflag As Integer
	Dim responseflag As Integer
	Dim recordflag As Integer
	Dim editorlevel As Integer
	Dim versionflag As Integer
	Dim replyval As Variant

	notdeclaredflag = 0
	responseflag = 0
	recordflag = 0
	editorlevel = 0
	versionflag = 0

	edrmserrortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	Call initlog(agent.name)
	Set edrmsdc = edrmsdb.unprocesseddocuments

	Call edrms_check_responses_records(edrmsdc, responseflag, recordflag,editorlevel,versionflag)

	If responseflag = 1 Then
		MessageBox "Please restrict your selection to top level documents only. Any response documents present "+_
		"will get picked up automatically if a parent document is selected.",16,edrmsdb.title &" " & EDRMSTERM$ &" Selection Contains Response Documents"
		logclose("User has been informed that they have included responses/resp to resp/alerts and exited.")
		Exit Sub
	End If

	If recordflag <> 0 Then
		MessageBox "Some of the documents you have selected are not declared as records, please amend your selection to exclude these" _
		,16,edrmsdb.title &" " & EDRMSTERM$
		logclose("User has been informed that they have included undeclared documents and exited.")
		Exit Sub
	End If

reason:
	logaction("user prompted for reason for undeclare request")

	replyval = ws.prompt(PROMPT_OKCANCELEDIT,"Reason for request","Please explain why you need these records to be undeclared. " +_
	"If you have different reasons for different records, please cancel this action and contact " & EDRMSADMINS$ & "  for advice." + Chr(10) + Chr(10))

	If IsEmpty(replyval) Then
		MessageBox "Action has been cancelled",64,edrmsdb.title &" " & EDRMSTERM$ &" Action cancelled"
		Exit Sub
	End If

	If replyval = "" Then
		MessageBox "You did not supply a reason",64,edrmsdb.title &" " & EDRMSTERM$ &" No reason supplied"
		GoTo reason
	End If

	Set rs1 = edrmssess.CreateRichTextStyle
	rs1.underline = True
	Set rsnormal = edrmssess.CreateRichTextStyle
	rsnormal.underline = False

	' Email the result to the System Admins
	logaction("Generating email to "  & EDRMSADMINSGROUP$)
	Set emaildoc = edrms_util_create_email("Documents to be undeclared on BDB " & edrmsdb.title,EDRMSADMINSGROUP$,Null,Null)
	Set rtitem = New NotesRichTextItem(emaildoc, "Body" )
	Call rtitem.appendtext("The following document(s) in " & edrmsdb.Title & " need to be undeclared.")
	Call rtitem.addnewline(2)
	Call rtitem.appendtext("Please click on the doclinks to view the documents.")
	Call rtitem.addnewline(2)

	Set doc = edrmsdc.getfirstdocument
	While Not doc Is Nothing
		If editorlevel = 0 Then
			doc.edrmsundeclarepending = "Yes"
			Call edrms_update_log(doc,EDRMSLOG$,"Record undeclare request submitted, reason : " & CStr(replyval),edrmscurrentuser.Abbreviated)
			Call doc.Save(True,True)
		End If
		Call rtitem.AppendDocLink( doc, edrmsdb.Title )
		Call rtitem.appendtext("   " & doc.subject(0))
		If editorlevel > 0 Then
			Call rtitem.appendtext(" (NOTE:- This record could not be marked as awaiting undeclare)")
		End If
		Call rtitem.addnewline(1)
		Set doc=edrmsdc.GetNextDocument(doc)
	Wend

	Call rtitem.addnewline(1)
	Call rtitem.AppendStyle(rs1)
	Call rtitem.appendtext("Reason for request:")
	Call rtitem.AppendStyle(rsnormal)
	Call rtitem.appendtext("  " & CStr(replyval))
	Call rtitem.addnewline(2)
	Call rtitem.appendtext("If you are unable to access these documents, please allow up to 40 minutes for database replication to occur.")

	Call emaildoc.Send( False )

	msg = CStr(edrmsdc.Count) & " declared records have been selected. An email has been sent to the " & EDRMSTERM$ & " Administrators."
	MessageBox msg,64,edrmsdb.title &" " & EDRMSTERM$ & " Email sent"
	Call edrms_deselect_docs(ws)
	Call ws.viewrefresh
	Call logclose("User informed : " & msg)

	Exit Sub
errhandle:
	Call logerror(Err, Error, Erl, LSI_Info(2), LSI_Info(12), " Last module before this call " & edrmserrortext )   ' LOGS HELPFUL DETAIL ON AN ERROR
	Call logaction(" Last Global Error " & edrmslastglobalerr)
	Call alerterrors(agent.name ,"Error")     ' EMAILS THE ERROR ALERT TO ADDRESS IN PROFILE
	Exit Sub
End Sub
Sub edrms_agent_review_sweep(Agent As NotesAgent)
' This agent moves both declared and undeclared documents that have edrmsreviewstatus = "Ready for Transfer" 	
	On Error GoTo errhandle
	Const TRANSFERDATE$ = "edrmstransferdate"
	Dim view As NotesView
	Dim vc As NotesViewEntryCollection
	Dim entry As NotesViewEntry
	Dim doc As NotesDocument
	Dim readyfortransferviews(1) As string
	Dim helperdbsret As Integer
	Dim i As Integer
	Dim movedcount As long

	If (edrmsdbservernn.common <> edrmsmasterservernn.common) Then
		Exit Sub   ' Not on master server so exit
	End If

	edrmserrortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	Call initlog(agent.name)

' Call the function that gets the required external DBS
	logaction("Getting DB handles to edrmsncddb, edrmsnabdb, edrmsmetadatadb, edrmsholdingdb, edrmscountsdb")
	helperdbsret = edrms_get_helper_dbs
	If helperdbsret > 0 Then
		logaction("Error getting one or more of the required external databases, check the Lookup.nsf and the default accesses to these DBs, error code = " & CStr(helperdbsret))
		logaction("Error codes: NCD = 99, NAB = 98, EDRMS Management DB = 97, EDRMS Holding DB = 96, EDRMS Counts DB = 95")
		Call alerterrors(agent.name ,"Error with external databases, error code " & CStr(helperdbsret))
		Exit Sub
	End If
	
	movedcount = 0
	
	readyfortransferviews(0) = EDRMSVIEWTRANSFER$               '  EDRMSVIEWTRANSFER$ = "EDRMS8"  EDRMS\3. Undeclared Records Ready for Transfer
	readyfortransferviews(1) =  EDRMSVIEWRECSNOTREQD$    '  EDRMSVIEWRECSNOTREQD$ = "EDRMS10"   EDRMS\2. Declared Records Not Required 

	For i = LBound(readyfortransferviews) To UBound(readyfortransferviews)
		
		Set view = edrmsdb.getview(readyfortransferviews(i))
	
		logaction("Get all entries in view " & view.name)
		Set vc = view.allentries
		movedcount = movedcount + vc.count
		logaction("Stamp all " & CStr(vc.count) & " entries in view with " & TRANSFERDATE$ & " of " & CStr(Today))
		Call vc.StampAll(TRANSFERDATE$,Today)
		Set entry = vc.GetFirstEntry()
		logaction("Loop through all view entries")
		If Not entry Is Nothing Then
			Set doc=entry.document
			While Not entry Is Nothing
				Call doc.copytodatabase(edrmsmetadatadb)  ' CHECK THIS IS THE CORRECT DB
				Call logaction("Copying " & doc.subject(0) & " to " & edrmsmetadatadb.title)
				Set entry=vc.getnextentry(entry)
				If Not entry Is Nothing Then
					Set doc=entry.document
				End If
			Wend
		End If
	
		logaction("Removing all from source")
		Call vc.removeall(True)
	Next

	Call logclose("Ends OK, moved " & CStr(movedcount))

Exit Sub
errhandle:
Call logerror(Err, Error, Erl, LSI_Info(2), LSI_Info(12), " Last module before this call " & edrmserrortext )   ' LOGS HELPFUL DETAIL ON AN ERROR
Call logaction(" Last Global Error " & edrmslastglobalerr)
Call alerterrors(agent.name ,"Error")     ' EMAILS THE ERROR ALERT TO ADDRESS IN PROFILE
Exit Sub
End Sub
Function edrms_quo(Source As NotesUIDocument,  Isnewdoc As Variant, Continue As Variant)
	On Error GoTo globalerrhandle
	Dim edrms_quo_errortext As String
	edrms_quo_errortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	If Not source.isnewdoc Then
		If(source.EditMode) Then
			Call edrms_check_declare(source.document, Continue)
		End If
	End If
Exit Function
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_quo_errortext
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Function
End Function
Sub edrms_agent_undeclared_records_perm_del(Agent As NotesAgent)
	On Error GoTo errhandle
	Const MODE$ = "REMOVE"
	Dim view As NotesView
	Dim checkview As NotesView
	Dim dc As NotesDocumentCollection
	Dim doc As NotesDocument
	Dim checkdoc As NotesDocument
	Dim repdoc As NotesDocument
	Dim storedname As NotesName
	Dim storeddate As NotesDateTime
	Dim agentruntime As New NotesDateTime(Now)
	Dim dellist As String
	Dim storedsubject As String
	Dim selectstring As String
	Dim helperdbsret As Integer
	Dim censusdb As Integer
	Dim repdocpartno As Integer
	dim respcnt As integer
	Dim movedcount As Long

	dellist = ""
	repdocpartno = 1
	movedcount = 0

	If edrmssess.Isonserver Then
		If (edrmsdbservernn.common <> edrmsmasterservernn.common) Then
			Exit Sub   ' When run scheduled, not on master server so exit
		End If
	End If
	edrmserrortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	Call initlog(agent.name)

' Call the function that gets the required external DBS
	logaction("Getting DB handles to edrmsncddb, edrmsnabdb, edrmsmetadatadb, edrmsholdingdb, edrmscountsdb")
	helperdbsret = edrms_get_helper_dbs
	If helperdbsret > 0 Then
		logaction("Error getting one or more of the required external databases, check the Lookup.nsf and the default accesses to these DBs, error code = " & CStr(helperdbsret))
		logaction("Error codes: NCD = 99, NAB = 98, EDRMS Management DB = 97, EDRMS Holding DB = 96, EDRMS Counts DB = 95")
		Call alerterrors(agent.name ,"Error with external databases, error code " & CStr(helperdbsret))
		Exit Sub
	End If

	' Check if this database is on the exceptions list...

	Set checkview = edrmscountsdb.GetView(EDRMSEXCEPTIONSVIEW$)
	Set checkdoc = checkview.GetDocumentByKey(edrmsdb.FilePath,True)
	censusdb = 0
	If Not checkdoc Is Nothing Then    ' Found on exceptions
		censusdb = 1
		logaction("Database is on the exceptions list so setting flag")
	End If
	
	' Added as a failsafe due to problems with restored docs still having the value 
	logaction("Resetting any stray documents from restores etc which may still have the delete flag set to 9") 
	selectstring = "SELECT (edrmsdeleteflag = ""9"") "
	logaction("Creating document collection with query " & selectstring )
	Set dc = edrmsdb.Search (selectstring,Nothing,0)
	logaction("Document collection contains " & CStr(dc.Count) )
	If dc.count > 0 Then
		logaction("Stamping the document collection to reset edrmsdeleteflag to null, these will be stray values from restores etc")
		Call dc.StampAll("edrmsdeleteflag","")
	End If

	Set repdoc = edrmsdb.createdocument
	repdoc.Form = EDRMSDELETIONLOGFORM$
	repdoc.logdate = Date
	repdoc.from = "Agent " & agent.name
	
	If censusdb = 0 Then           ' Not Census so OK to process 

		logaction("Getting handle on view " & EDRMSVIEWDELETED$)
		Set view = edrmsdb.getview(EDRMSVIEWDELETED$)   	' EDRMS9
		GoSub looptheview
		
		logaction("Getting handle on view of documents with initial declaration : Automatically Delete " & EDRMSVIEWAUTODELETE$)
		Set view = edrmsdb.getview( EDRMSVIEWAUTODELETE$)   	' EDRMSH11  (EDRMS Undeclared Documents Older Than Cutoff Auto Delete)
		GoSub looptheview

		If dellist = "" Then
			repdoc.DocDetails = "No documents deleted"
		Else
			repdoc.DocDetails = dellist
		End If
		Call repdoc.save(True,False)

		' Delete the documents

		selectstring = "SELECT (edrmsdeleteflag = ""9"") "
		logaction("Creating document collection with query " & selectstring )
		Set dc = edrmsdb.Search (selectstring,Nothing,0)
		logaction("Document collection contains " & CStr(dc.Count) )

		' Update documents prior to deletion
		Set doc = dc.getfirstdocument
		While Not doc Is Nothing
			logaction("Updating the deletion log on " & doc.form(0) & "    " & doc.subject(0) )
			Call edrms_update_log(doc,"deletelog","Deleted from " & edrmsdb.title,agent.name)
			Call doc.save(True,True)
			Set doc=dc.getnextdocument(doc)
		Wend

		logaction("Stamping the document collection with the required metadata")
		Call dc.StampAll("holdingdbtransferdate",agentruntime.dateonly)
		Call dc.stampall("sourcebdbtitle",edrmsdb.Title)
		Call dc.stampall("sourcebdbpath",edrmsdb.filepath)
		Call dc.stampall("softdeletedby",agent.name)
		Call dc.stampall("softdeleteddocsflag","1")
		Call dc.StampAll("softdeleteddate",agentruntime.lslocaltime)

		Set doc = dc.getfirstdocument
		logaction("Copying " & CStr(dc.count) & " documents to " & edrmsholdingdb.title)
		While Not doc Is Nothing
			Call doc.copytodatabase(edrmsholdingdb)
			logaction("Copying " & doc.form(0) & "    " & doc.subject(0) & "    Created : " & doc.created)
			Set doc=dc.getnextdocument(doc)
		Wend

		logaction("Removing all " & CStr(dc.count) & " documents from the document collection (and hence database)")
		Call dc.RemoveAll(True)
		Call logclose("Ends OK, moved and deleted " & CStr(movedcount) & " documents to " & edrmsholdingdb.title)

	Else    ' for If censusdb = 0 Then

		repdoc.DocDetails = "Database on the Exceptions List - no documents deleted"
		Call repdoc.save(True,False)
		Call logclose("Ends OK, Database on the Exceptions List - no documents deleted")

	End If   ' for If censusdb = 0 Then

	Exit Sub
	
looptheview:
	logaction("")
	logaction("Processing view " & view.name & "  which contains " & CStr(view.Toplevelentrycount) & " main documents (excluding responses)")
	view.AutoUpdate = False
	Set doc = view.getfirstdocument

	While Not doc Is Nothing
		Set storedname = New NotesName(doc.permanentauthor(0))
		storedsubject = doc.subject(0)

		If doc.Versioncreatedate(0) <> "" Then
			Set storeddate = New NotesDateTime(doc.Versioncreatedate(0))
		Else
			Set storeddate = New NotesDateTime(doc.created)
		End If

		If Len(dellist) > EDRMSMAXREPSIZE& Then
			repdoc.Form = EDRMSDELETIONLOGFORM$
			repdoc.logdate = Date
			repdoc.from = "Agent " & agent.name
			repdoc.docdetails = dellist
			repdoc.partno = " (Part " + CStr(repdocpartno) + ")"
			Call repdoc.save(True,False)
			Set repdoc = edrmsdb.createdocument
			repdoc.Form = EDRMSDELETIONLOGFORM$
			repdoc.logdate = Date
			repdocpartno = repdocpartno + 1
			repdoc.partno = " (Part " + CStr(repdocpartno) + ")"
			dellist = ""
		End If

		If doc.Versioncreatedate(0) <> "" And doc.versioncreatedby(0) <> "" Then
			dellist = dellist + storedname.common +  " - " + storedsubject + " (new version created " + CStr(storeddate.dateonly) + ") - (Main Document)" + Chr(10)
		ElseIf doc.versioncreatedate(0) <> "" Then
			dellist = dellist + storedname.common +  " - " + storedsubject + " (originally created " + CStr(storeddate.dateonly) + ") - (Main Document)" + Chr(10)
		Else
			dellist = dellist + storedname.common +  " - " + storedsubject + " (created " + CStr(storeddate.dateonly) + ") - (Main Document)" + Chr(10)
		End If

        respcnt = 0
		Call edrms_count_responses(doc,respcnt)
		logaction("Marking " & doc.subject(0) & " created by " & doc.m_originator(0)  & " and " & CStr(respcnt) & " responses for removal")
		Call edrms_mark_deletion_values(doc,movedcount,agent.name,MODE$)

		Call edrms_recurse_responses(doc,MODE$,"",agent.name,"",Nothing, Nothing, movedcount,0)

		Set doc = view.getnextdocument(doc)
	Wend

	logaction("Marked " & CStr(movedcount) & " documents for transfer and removal (setting the delete flag to 9)")
	Return
	
errhandle:
	Call logerror(Err, Error, Erl, LSI_Info(2), LSI_Info(12), " Last module before this call " & edrmserrortext )   ' LOGS HELPFUL DETAIL ON AN ERROR
	Call logaction(" Last Global Error " & edrmslastglobalerr)
	Call alerterrors(agent.name ,"Error")     ' EMAILS THE ERROR ALERT TO ADDRESS IN PROFILE
	Exit Sub
End Sub
Sub edrms_mark_deletion_values(doc As NotesDocument,deletedcnt As Long,reviewer As String,mode As String)
	On Error GoTo globalerrhandle
	Dim edrms_mark_deletion_values_errtxt As String
	Dim logmsg As String

	edrms_mark_deletion_values_errtxt = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	Select Case mode
		Case "MARKFORDELETION"  :
			doc.softdeleteddocsflag = "1"
			doc.softdeletedby = reviewer
			doc.softdeleteddate = Now
			logmsg = "Marked for deletion on BDB " + edrmsdb.title + " on "
		Case  "RESTOREFROMDELETION" :
			doc.softdeleteddocsflag = ""
			doc.softdeletedby = ""
			doc.softdeleteddate = Null
			logmsg = "Restored on BDB " + edrmsdb.title + " on "
		Case "UNDECLAREDRECORDSDELETE" :
			doc.edrmsdeleteflag = "1"
			logmsg = "Marked for deletion by Agent on BDB " + edrmsdb.title + " on "
		Case "REMOVE" :
			doc.edrmsdeleteflag = "9"
			logmsg = "Marked for transfer and removal by Agent on BDB " + edrmsdb.title + " on "
	End Select

	Call edrms_update_log(doc,EDRMSDELETELOG$,logmsg,reviewer)
	Call doc.save(True,True)
	deletedcnt = deletedcnt + 1

Exit Sub
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_mark_deletion_values_errtxt
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Sub
End Sub
Sub edrms_qus(source As NotesUIDocument, continue As Variant)
	On Error GoTo globalerrhandle
	Dim ws As New NotesUIWorkspace
	Dim edrms_qus_errortext As String
	edrms_qus_errortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	Call source.Refreshhideformulas()
	
' Was originally in Queryclose, moved here to stop various untidyness issues
	If source.editmode And not source.document.responsedoc(0) = "Yes" Then
			Call edrms_set_initial_declaration(source,continue)
	End If
	
Exit Sub
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_qus_errortext
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Sub
End Sub
Sub edrms_agent_copy_paste(agent As NotesAgent)
	On Error GoTo errhandle
	Dim ws As New NotesUIWorkspace
	Dim uiview As NotesUIView
	Dim doc As NotesDocument
	Dim rptflag As Integer

	edrmserrortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	Call initlog(agent.name)
	Set edrmsdc = edrmsdb.unprocesseddocuments
	Set doc = edrmsdc.getfirstdocument

	rptflag = 0

	logaction("User attempting to copy and paste " & CStr(edrmsdc.count) & " documents")

	If edrmsdc.count = 0 Then
		MessageBox "You have no documents selected.",16,edrmsdb.title &" " & EDRMSTERM$ & " Invalid Action"
		Exit Sub
	End If

	Do While Not doc Is Nothing
		If	doc.edrmsrecord(0) = "Yes" Then
			MessageBox "Pasting is not allowed for " & EDRMSTERM$ & " declared records.",16,edrmsdb.title &" " & EDRMSTERM$ & " Invalid Action on " & doc.subject(0)
			logaction("Attempt to copy and paste EDRMS declared record intercepted " & doc.subject(0))
			Exit Sub
		Else
			If(doc.isresponse) Then
				If(rptflag = 0) Then
					MessageBox "You can only copy and paste top-level documents, not responses, please ask the database administrator if you need to do this.",16, edrmsdb.title &" " & EDRMSTERM$ & " Pasting Of Responses not allowed"
					rptflag = 1
				End If
			Else
				Dim newdoc As New NotesDocument(edrmsdb)
				logaction("Copying " & doc.form(0) & "  " & doc.subject(0))
				Call doc.CopyAllItems(newdoc,True )
				newdoc.RemoveItem("Clonedfrom")
				newdoc.RemoveItem("Clonedto")
				newdoc.RemoveItem("CloneRef")
				newdoc.RemoveItem("Oldversion")
				newdoc.RemoveItem("Oldversionlink")
				newdoc.Provversionno = 0
				newdoc.Version = 0
				newdoc.save True,True
			End If
		End If
		Set doc = edrmsdc.getnextdocument(doc)
	Loop

	Call edrms_deselect_docs(ws)
	Call ws.ViewRefresh
	Set uiview = ws.CurrentView
	If Not newdoc Is Nothing Then
		Call uiview.selectdocument(newdoc)
	End If

	Call logclose("")
	Exit Sub
errhandle:
	Call logerror(Err, Error, Erl, LSI_Info(2), LSI_Info(12), " Last module before this call " & edrmserrortext )   ' LOGS HELPFUL DETAIL ON AN ERROR
	Call logaction(" Last Global Error " & edrmslastglobalerr)
	Call alerterrors(agent.name ,"Error")     ' EMAILS THE ERROR ALERT TO ADDRESS IN PROFILE
	Exit Sub
End Sub
Sub edrms_user_live_test_prompt(view As NotesView,nameout As NotesName,runtype As Integer,continue As Boolean)
	On Error GoTo globalerrhandle
	Dim ws As New NotesUIWorkspace
	Dim chosenname As NotesName
	Dim edrms_user_live_test_prompt_errtxt As String
	Dim namechoice As Variant
	Dim replyval As Variant

	edrms_user_live_test_prompt_errtxt = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	continue = True

		logaction("User prompted whether this is a live run")
		runtype = MessageBox("Is this a live run?",36,edrmsdb.title &" " & EDRMSTERM$ & " Run Type")

	If runtype = 7 Then   ' TEST RUN

			logaction("User prompted whether to continue as a test")
			replyval = MessageBox ("Test run. A live run of this action will send emails to owners of the " & CStr(view.toplevelentrycount) &_
			" records in the view " & view.name &_
			". In the test environment, all emails will be sent to a named person who you will be asked to select in the next dialog box. " +_
			"Are you sure you want to continue?",36,edrmsdb.title &" " & EDRMSTERM$ & " Warning")
			If replyval = 7 Then
				logaction("User aborted at test prompt")
				MessageBox "Run aborted",64,edrmsdb.title & " " & EDRMSTERM$ & " Exiting"
				continue = False
				Exit Sub
			End If
			namechoice = ws.pickliststrings(PICKLIST_NAMES)
			Set nameout = New NotesName(namechoice(0))
			logaction("User prompted whether to continue as a test and send all emails to " & nameout.common)
			replyval = MessageBox ("You have indicated that for the purposes of this test, all emails are to be sent to " + nameout.common +_
			". Are you sure you want to continue?",36,edrmsdb.title &" " & EDRMSTERM$ & " Warning")
			If replyval = 7 Then
				logaction("User aborted at second test prompt")
				MessageBox "Run aborted",64,edrmsdb.title & " " & EDRMSTERM$ & " Exiting"
				continue = False
				Exit Sub
			End If

	Else  ' LIVE RUN

			logaction("User prompted whether to continue as a live run sending emails to all concerned")
			replyval = MessageBox ("Live run. This action will send emails to all people who have records due for review in the current review year. " +_
			"Are you sure you want to continue?",36,edrmsdb.title &" " & EDRMSTERM$ & " Warning")
			If replyval = 6 Then
				logaction("User prompted again whether to continue as a live run")
				replyval =  MessageBox ("Are you really sure you want to do a live run",36,edrmsdb.title &" " & EDRMSTERM$ & " Warning")
				If replyval = 7 Then
					logaction("User aborted at second live prompt")
					MessageBox "Run aborted",64,edrmsdb.title &" " & EDRMSTERM$ & " Exiting"
					continue = False
					Exit Sub
				End If
			Else
				logaction("User aborted at first live prompt")
				MessageBox "Run aborted",64,edrmsdb.title &" " & EDRMSTERM$ & " Exiting"
				continue = False
				Exit Sub
			End If

	End If

	Exit Sub
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_user_live_test_prompt_errtxt
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Sub

End Sub
Sub edrms_recurse_responses(doc As NotesDocument, mode As String,category As String,declaredby As String,dateval As String,_
                            target_db As NotesDatabase, dc As NotesDocumentCollection, movedcount As Long, errorcnt As Integer)
	On Error GoTo globalerrhandle
	Dim dcr As NotesDocumentCollection
	Dim responsedoc As NotesDocument
	Dim editoraccess As String
	Dim edrms_recurse_responses_errortext As String

	edrms_recurse_responses_errortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	If doc Is Nothing Then
		Exit Sub                                          ' Odd things can happen with multiple selections
	End If
	
    Set dcr = doc.Responses
	If dcr Is Nothing Then
		edrmslimitedaccessflag = 1        ' Global. It would appear that this scenario is encountered when limited access responses are present for Author access 
		Exit Sub                                            ' Doc has No responses 
	End If
	
	Set responsedoc  = dcr.GetFirstDocument
	Do Until responsedoc Is Nothing
		If (responsedoc.universalid = "") Then   ' It would appear that this is encountered when limited access responses are present for Manager  access 
			edrmslimitedaccessflag = 1    ' Global
			Exit sub
		End If
		
		If responsedoc.hasitem(EDRMSCONFLICT$) Then                      ' Confllcts can cause an infinite recursion
			GoTo skipdoc
		End If     
		
		If edrmsdbeditor <> "Yes" Then
			Call edrms_get_doc_access(responsedoc,editoraccess)   ' Check what access the current user has to this response
			If editoraccess = "No" Then
				edrmsdoceditor = "No"   ' GLOBAL
				If(mode = "CHECKACC") Then
					Exit Sub                                         ' If user doesn't have author access to even one doc, may as well halt the test
				End If
				'CHECK IF ON SERVER AND PUT OUT APPROPRIATE ERROR MESSAGE/LOG
			End If
		Else
' THIS CAN OVERWRITE A CORRECT NO DJS 12/08/2015			edrmsdoceditor = "Yes"   ' GLOBAL
			If(mode = "CHECKACC") Then
				Exit Sub                                         ' If user doesn't have author access to even one doc, may as well halt the test
			End If
		End If

 		edrmsrespcount = edrmsrespcount + 1
 		Select Case mode
			Case "DECLARE" : Call edrms_declare_set_values(responsedoc,category,declaredby)
			Case "UNDECLARE" : Call edrms_undeclare_set_values(responsedoc,declaredby)                  ' UNDECLARER
			Case "AMENDCAT" : Call edrms_amend_category_values(responsedoc,category,declaredby,dateval)
			Case "MOVE" : 		Call edrms_move_to_other_db(responsedoc, target_db,dc,movedcount, errorcnt)
			Case "MARKREVIEW" :  Call edrms_mark_review_status(responsedoc,category,movedcount,declaredby,dateval,doc.edrmscategory(0))    ' Have re-purposed category and declaredby here
			Case "MARKFORDELETION", "RESTOREFROMDELETION", "UNDECLAREDRECORDSDELETE", "REMOVE" :
					Call edrms_mark_deletion_values(responsedoc,movedcount,declaredby,mode)
 		End Select
 		
skipdoc:
		Call edrms_recurse_responses(responsedoc,mode,category,declaredby,dateval, target_db,dc,movedcount, errorcnt)
		Set responsedoc = dcr.GetNextDocument(responsedoc)
 	Loop

	Exit Sub
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_recurse_responses_errortext
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Sub
End Sub
Sub edrms_declare_record(doc As NotesDocument,edrms_uidoc As NotesUIdocument)
	On Error GoTo globalerrhandle
	' Called from the uidoc
	Const MODE$ = "DECLARE"
	Dim ws As New NotesUIWorkspace
	Dim dcr As NotesDocumentCollection
	Dim category As String
	Dim editoraccess As String
	Dim msg As String
	Dim edrms_declare_record_errortext As String
	Dim responseflag As Integer
	Dim  recordflag As Integer
	Dim editorlevel As Integer
	Dim versionflag As Integer
	Dim continue As Variant

	edrms_declare_record_errortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	
	Call edrms_get_doc_access(doc,editoraccess)
	If editoraccess <> "Yes" Then
		MessageBox "You are not an eligible editor of this document, you need either higher database access or to be a named editor of the document",16, edrmsdb.title &" " & EDRMSTERM$ & " Access Error"
		Exit sub
	End If
	
	Set dcr = doc.Responses
	If dcr.count > 0 then
		Call edrms_check_responses_records(dcr,responseflag,recordflag,editorlevel ,versionflag)
		If editorlevel = 1  Or  edrms_get_thread_access(doc) = "No"  Then
			editorlevel = 1
			doc.edrmsdelayedflag = 1   ' Mark for the delayed agent
			msg = "You are not an eligible editor of all the responses in scope so these will be marked for later processing"
			MessageBox msg ,64, edrmsdb.title &" " & EDRMSTERM$ & " Access Issue"
		End If
	End If

	If edrms_uidoc.Editmode Then
		edrms_uidoc.save                      ' Paranoid check whether the user has changed anything without saving prior to declare if in edit mode
	End If

	Call edrms_check_declare(doc, continue)
	If continue = False Then
		Exit Sub
	End If

	edrmsrespcount=0

	edrmsretval = edrms_choose_record_category
	If Not IsEmpty(edrmsretval) Then
		category = edrmsretval
		Call edrms_declare_set_values(doc, category,edrmscurrentuser.abbreviated)
		Set dcr = doc.Responses
		If dcr.count > 0 And editorlevel = 0  Then   ' Only recurse responses if eligible editor  
			edrmslimitedaccessflag = 0
			Call edrms_recurse_responses(doc,MODE$,category,edrmscurrentuser.abbreviated,Date$,Nothing,Nothing,0,0)
			If edrmslimitedaccessflag = 1 Then
				doc.edrmsdelayedflag = 1       ' Some responses will need to be updated ovenight due to user not having access to all docs in the thread
				Call doc.save(True,True)
				Call logaction(doc.subject(0) & " has limited access responses which will need declaring overnight, delayed flag set")
			End if
		End If
		MessageBox "Declared document and " & CStr(edrmsrespcount) & " responses as records",64, edrmsdb.title &" " & EDRMSTERM$ & " Declaration"
		
		Call ws.currentdocument.close
		Call ws.Viewrefresh()
		Set edrms_uidoc = ws.EditDocument(False,doc)
	Else
		MsgBox "No Record Type chosen, exiting the declaration.",16,edrmserrorstub & edrmserrortext
	End If
	Exit Sub
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_declare_record_errortext
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Sub
End Sub
Sub edrms_agent_force_manual_undeclare(Agent As NotesAgent)
	On Error GoTo errhandle
	Const MODE$ = "UNDECLARE"
	Dim ws As New NotesUIWorkspace
	Dim dcr As NotesDocumentCollection
	Dim doc As NotesDocument
	Dim msg As String
	Dim replyval As Variant

	edrmsrespcount=0

	edrmserrortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	Call initlog(agent.name)

	If edrmsadminsgroupmember <> "Yes" Then
		MessageBox "You are not a member of " & EDRMSADMINSGROUP$ & " usage of force undeclare is restricted to the system admins",16,edrmsdb.title &" " & EDRMSTERM$ & " Exiting"
		logclose("User informed that they are not a member of " & EDRMSADMINSGROUP$ & " and exited")
		Exit Sub
	End If

	If edrmsdbeditor <> "Yes" Then
		MessageBox "You are a member of " & EDRMSADMINSGROUP$ & " but you do not have edit document access",16,edrmsdb.title &" " & EDRMSTERM$ & " Exiting"
		logclose("User informed that they are a member of " & EDRMSADMINSGROUP$ & " but do not have edit document access and exited")
		Exit Sub
	End If

	Set edrmsdc = edrmsdb.unprocesseddocuments

	If edrmsdc.count = 0 Then
		MessageBox "Please select a document",16,edrmsdb.title &" " & EDRMSTERM$ & " No document selected"
		logclose("User had not selected any documents, told to do so and code exited")
		Exit Sub
	End If

	msg = "You have selected " + CStr(edrmsdc.count) + " documents for manual undeclaration" + Chr(10) + Chr(10) _
	& "You will be notified once when all documents have been undeclared" + Chr(10) + Chr(10) _
	& "Are you sure you wish to continue?"
	logaction("User prompted " & msg)
	replyval = MessageBox(msg,36,edrmsdb.title &" " & EDRMSTERM$ & " Force manual undeclare")
	If replyval = 7 Then
		logclose("User aborted at confirmation prompt")
		Exit Sub
	End If

	Set doc = edrmsdc.getfirstdocument
	While Not doc Is Nothing
		If doc.edrmsrecord(0) = "Yes"  Then
			If Not doc.Isresponse Then      ' Stop arbitrary selection of Responses/Resp To Resps
				logaction("Undeclaring " & doc.subject(0))
				Call edrms_undeclare_set_values(doc,edrmscurrentuser.abbreviated)
				Set dcr = doc.Responses
				If dcr.count > 0 Then
					logaction("Recursing the " & CStr(dcr.count) & " responses")
					Call edrms_recurse_responses(doc,MODE$,"",edrmscurrentuser.abbreviated,Date$,Nothing,Nothing,0,0)
				End If
			Else
				MsgBox "Please do not select response documents, exiting",16,edrmsdb.title &" " &  LCase(LSI_Info(2)) & " Illegal Action"
				logclose("User had selected response documents, told not to do so and code exited")
				Exit Sub
			End If
		Else
			MsgBox "Please do not select undeclared documents, exiting",16,edrmsdb.title &" " &  LCase(LSI_Info(2)) & " Illegal Action"
			logclose("User had selected undeclared documents, told not to do so and code exited")
			Exit Sub
		End If
	Set doc = edrmsdc.getnextdocument(doc)
	Wend
	msg = "Undeclared " & CStr(edrmsdc.count) & " documents and " & CStr(edrmsrespcount) & " responses As records"
	MessageBox msg,64, edrmsdb.title &" " & EDRMSTERM$ & " Declaration"
	Call ws.viewrefresh
	Call edrms_deselect_docs(ws)
	Call logclose("Ends OK " & msg)

	Exit Sub
errhandle:
	Call logerror(Err, Error, Erl, LSI_Info(2), LSI_Info(12), " Last module before this call " & edrmserrortext )   ' LOGS HELPFUL DETAIL ON AN ERROR
	Call logaction(" Last Global Error " & edrmslastglobalerr)
	Call alerterrors(agent.name ,"Error")     ' EMAILS THE ERROR ALERT TO ADDRESS IN PROFILE
	Exit Sub
End Sub
Sub edrms_mark_review_status(doc As NotesDocument,status As String,reviewedcnt As Long,reviewer As String,reviewdate As Variant, category As String)
	On Error GoTo globalerrhandle
	Dim edrms_mark_review_status_errtxt As String
	Dim logmsg As String

	edrms_mark_review_status_errtxt = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	Select Case status
		Case "Re-declared" :                    	doc.edrmsreviewedby = reviewer
													doc.edrmsreviewedbydate = date
													doc.edrmsreviewstatus = status
													doc.edrmsreviewdate = CDat(reviewdate)
													doc.edrmscategory = category
													logmsg = "Reviewed as " & status &" on"
		Case "Not Required" :                   	doc.edrmsreviewedby = reviewer
			                                        doc.edrmsreviewedbydate = date
			                                        doc.edrmsreviewstatus = status
			                                        logmsg = "Reviewed as " & status &" on"
		Case "Ready for Transfer" :         	doc.edrmsreviewedby = reviewer
													doc.edrmsreviewedbydate = Date
													doc.edrmsreviewstatus = status
													logmsg = "Reviewed as " & status &" on"
		Case "Reverse" : 							doc.edrmsreviewedby = ""
													doc.edrmsreviewedbydate = Null
													doc.edrmsreviewstatus = ""
													doc.edrmssourcebdbttle = ""
													doc.edrmssourcebdbpath = ""
													logmsg = "Marked for deletion action reversed by Registrar on"
	End Select

	Call edrms_update_log(doc,EDRMSLOG$,logmsg,reviewer)
	Call doc.save(True,True)
	reviewedcnt = reviewedcnt + 1

Exit Sub
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_mark_review_status_errtxt
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Sub
End Sub
Sub edrms_agent_action_autodeclare(agent As NotesAgent)
	' This processes documents with the initial edrms declaration of "Automatically Declare" Const EDRMSVIEWAUTODECLARE$ = "EDRMSH10" (EDRMS Undeclared Documents Older Than Cutoff Auto Declare)
	On Error GoTo errhandle
	Const MODE$ = "DECLARE"
	Dim view As NotesView
	Dim doc As NotesDocument
	Dim nn As NotesName
	Dim recdeclaredby As string
	Dim doccnt As Long
	Dim respcnt As Long
	Dim respno As Integer

	edrmserrortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	Call initlog(agent.name)

	Set view = edrmsdb.getview(EDRMSVIEWAUTODECLARE$)
	If view Is Nothing Then
		Call logerror(Err, Error, Erl, LSI_Info(2), LSI_Info(12), " Cannot locate view aliased " & EDRMSVIEWAUTODECLARE$ & ", last module before this call " & edrmserrortext )
		Exit Sub
	End If
	view.Autoupdate = false
	
	logaction("Processing view " & view.name & "  which contains " & CStr(view.Toplevelentrycount) & " main documents (excluding responses)")
	logaction("")
	Set doc = view.GetFirstDocument
	doccnt = 1
	respcnt = 0
	While Not doc Is Nothing

		If doc.hasitem("bfdate") Then
			If doc.bfdate(0) <> "" Then
				Call logaction(doc.subject(0) + " B/F date removed")
				doc.bfdate = ""
				doc.bfremind = ""
			End If
		End If

		respno = 0
		Call edrms_count_responses(doc,respno)
		respcnt = respcnt + respno
		If doc.hasitem("documentauthors") Then
			Set nn = New NotesName(doc.documentauthors(0))
			recdeclaredby = nn.abbreviated
		Else
			recdeclaredby = doc.m_originator(0)
		End If

		logaction("Declaring " & doc.subject(0) & " created by " & recdeclaredby  & " and " & CStr(respno) & " responses as a record of category " & doc.edrmscategory(0))
		Call edrms_declare_set_values(doc,doc.edrmscategory(0),recdeclaredby)
		Call edrms_recurse_responses(doc, MODE$,doc.edrmscategory(0),recdeclaredby,"",Nothing,Nothing,0,0)

		Set doc = view.GetNextDocument(doc)
		doccnt = doccnt + 1
	Wend

	Call logclose("Auto Declared " & CStr(doccnt) & " main documents and " & CStr(respcnt) & " responses")
	Exit Sub
errhandle:
	Call logerror(Err, Error, Erl, LSI_Info(2), LSI_Info(12), " Last module before this call " & edrmserrortext )   ' LOGS HELPFUL DETAIL ON AN ERROR
	Call logaction(" Last Global Error " & edrmslastglobalerr)
	Call alerterrors(agent.name ,"Error")     ' EMAILS THE ERROR ALERT TO ADDRESS IN PROFILE
	Exit Sub
End Sub
Sub edrms_switch_version(doc As NotesDocument)
	On Error GoTo globalerrhandle

	Dim ws As New NotesUIWorkspace
	Dim view As NotesView
	Dim col As NotesDocumentCollection
	Dim versiondoc As NotesDocument
	Dim uidoc As NotesUIDocument
	Dim newuidoc As NotesUIDocument
	Dim array() As String
	Dim KeyArray(0 To 0) As String
	Dim edrms_switch_version_errtxt As String
	Dim flag As Integer
	Dim i As Integer
	Dim Vnumber As Integer
	Dim choice As variant

	edrms_switch_version_errtxt = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	Set uidoc = ws.CurrentDocument

	Set view = edrmsdb.GetView("EDRMSV1")

	If doc.CloneRef(0) = "" Then
		KeyArray(0) = doc.UniversalID
	Else
		KeyArray(0) = doc.CloneRef(0)
	End If

	Set col = view.GetAllDocumentsByKey(keyArray,True)

	If col.Count < 2 Then
		MessageBox "No other versions of this document exist", 64,  "Switch to Another Version"
		Exit Sub
	End If

	Set versiondoc = col.GetFirstDocument

	'load the versions into an array ready to display in a choice prompt
	i = 0

	Do Until versiondoc Is Nothing
		flag = 0

		'Don't include the current uidocument in the array
		If col.count = 2 Then
			If versiondoc.version(0) <> 0 And doc.version(0) <> 0 Then
				If versiondoc.version(0) <> doc.version(0) Then
					flag% = 1
				End If
			ElseIf versiondoc.version(0) = 0 And doc.version(0) = 0 Then
				If versiondoc.ProvVersionno(0) <> doc.ProVversionno(0) Then
					flag% = 1
				End If
			End If
		ElseIf col.count > 2 Then
			If versiondoc.version(0) <> doc.version(0) Then
				flag% = 1
			End If
		End If

		If flag% = 1 Then

			ReDim Preserve array(0 To i%)
			If versiondoc.Version(0) = 0 Then
				Vnumber% = versiondoc.Provversionno(0)
			Else
				Vnumber% = versiondoc.Version(0)
			End If

			array(i%) = CStr(Vnumber%)+" saved on "+versiondoc.lastmod(0)+" by "+versiondoc.lasteditor(0)
			i% = i% + 1

		End If

		Set versiondoc = col.GetNextDocument(versiondoc)

	Loop

	Call edrms_util_quicksort(array,"DESC")         ' sort desc instead

	'now flip it up so the higher versions are at the top
'	i% = UBound(SortedArray)
'	ReDim array(0 To i%)
'	ForAll ele In SortedArray
'		array(i%) = ele
'		i% = i% - 1
'	End ForAll

	choice = ws.Prompt(PROMPT_OKCANCELLIST,"Switch to Another Version","Please select another version to switch to","",edrmssortedarray)

	'Open the one they selected
	If choice <> "" Then
		Set view = edrmsdb.GetView("EDRMSV2")
		Set versiondoc = view.GetDocumentByKey((KeyArray(0))+"~"+Left(choice,InStr(choice," ")-1))
		Call ws.SetTargetFrame("")

		'Open the new document
		Set newuidoc = ws.EditDocument(False,versiondoc)

		'Close this one
		Call uidoc.close

	Else
		Exit Sub
	End If

Exit Sub
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_switch_version_errtxt
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Sub
End Sub
Sub edrms_update_log(doc As NotesDocument,logfield As String,comment As String,actioner As String)
	On Error GoTo globalerrhandle
	Dim item As NotesItem
	Dim logmsg As String
	Dim edrms_update_log_errortext As String
	Dim a As Integer

	edrms_update_log_errortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	logmsg = comment & " " & CStr(Now) & " by " & actioner

	Set item = doc.GetFirstItem(logfield)
	If item Is Nothing Then
		Set item = New NotesItem(doc,logfield,logmsg)
	Else
		Call item.AppendToTextList(logmsg)
	End If
Exit Sub
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_update_log_errortext
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Sub
End Sub
Sub edrms_get_view_selected_docs(dcview As NotesDocumentCollection)
	On Error GoTo globalerrhandle
	Dim ws As New NotesUIWorkspace
	Dim uiview As NotesUIView
	Dim edrms_get_view_selected_docs_errortext As String

	edrms_get_view_selected_docs_errortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	Set uiview = ws.Currentview
	Set dcview = uiview.Documents
	If dcview.count = 0 Then
		MsgBox "Please select documents by ticking in the view selection gutter",16,edrmsdb.title &" " &  LCase(LSI_Info(2)) & " Illegal Action"
		Exit Sub
	End If
	Call UIView.DeselectAll
Exit Sub
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_get_view_selected_docs_errortext
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Sub
End Sub

Function edrms_prevent_front_end_deletion As Boolean
	On Error GoTo globalerrhandle
	Dim edrms_prevent_front_end_deletion_errtxt As String

	edrms_prevent_front_end_deletion_errtxt = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	MessageBox "Direct deletion of documents is not allowed. If deletions are required," &_
	" documents can be deleted via the Mark Selected for Deletion action and responses" &_
	" via the Mark Responses for Deletion action, both in the View" &_
	" Actions dropdown.",16,edrmsdb.title &" " & EDRMSTERM$ & " Prohibited action"

	edrms_prevent_front_end_deletion = False

Exit Function
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_prevent_front_end_deletion_errtxt
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Function
End Function
Sub edrms_calculate_review_date(category As Variant, reviewdate As Variant)
	On Error GoTo globalerrhandle
	Dim edrms_calculate_review_date_errortext As String
	Dim ddate As NotesDateTime
	Dim retentionyears As Integer
	Dim retval As Variant

' Reviewdate is a variant but can be a plain string date or a string date inside a (0) structure and in both cases can be nothing potentially	
	If IsNull (reviewdate) Then
		Set ddate = New NotesDateTime(Today)
	Else
		If IsArray(reviewdate) then
				If(reviewdate(0) = "") Then
					Set ddate = New NotesDateTime(Today)
				Else
					set ddate = New NotesDateTime(reviewdate(0)) ' variant has structure
				End If
		Else
			If reviewdate = "" Then
				Set ddate = New NotesDateTime(Today)
			Else
				Set ddate = New NotesDateTime(reviewdate)     ' Normal string
			End If
		End If
	End If
	
	edrms_calculate_review_date_errortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	retval = ArrayGetIndex(edrmscategories,category)
	If Not IsNull(retval) Then
		retentionyears = edrmsretention(retval)
	Else
		reviewdate = "Error : Problem with lookup of " & EDRMSTERM$ & " Profile Document Categories"
		Exit Sub
	End If

	Call ddate.AdjustYear(retentionyears)
	reviewdate = ddate.dateonly
Exit Sub
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_calculate_review_date_errortext
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Sub
End Sub
Sub edrms_check_responses_records(dc As NotesDocumentCollection,responseflag As Integer, recordflag As Integer,editorlevel As Integer,versionflag As Integer)
	On Error GoTo globalerrhandle
	Const MODE$ = "CHECKACC"
	Dim doc As NotesDocument
	Dim edrms_check_responses_records_errortext As String
	Dim decflag As Integer
	Dim undecflag As Integer
	Dim editoraccess As String

	edrms_check_responses_records_errortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	responseflag = 0
' THE FOLLOWING TAKES A BIT OF EXPLAINING, BASICALLY THIS SUB HAS TO DO MORE THAN SIMPLY RETURN TRUE/FALSE TO AN UNAMBIGUOUS SINGLE QUESTION	
	recordflag = 0              ' zero until undeclared found, 1 when at least 1 undeclared found, 2 when both declared and undeclared found
	editorlevel = 0              ' zero until doc with no author access found, 1 if responses found, 2 if main docs found
	decflag = 0                   ' zero until a declared doc found
	undecflag = 0              ' zero until an undeclared doc found
	versionflag = 0

	Set doc = dc.getfirstdocument
	While Not doc Is Nothing
		If UCase(doc.form(0)) = "RESPONSE" Or UCase(doc.form(0)) = "RESPONSE TO RESPONSE" Or UCase(doc.form(0)) = "ALERT" Then
			responseflag = 1          ' Found at least one response doc
		Else
			responseflag = -1        ' Found at least one non-response doc
		End If
' Testing declarations - zero returned if all documents declared, 1 if all undeclared, 2 if a mixture
' Note a special case are documents declared on creation that have not yet had the edrmsrecord flag set, so we have to test the field
' edrmsinitialdeclaration to see if it has the value to declare overnight
		If doc.hasitem("edrmsrecord") Then
			If doc.edrmsrecord(0) = "Yes" Then
				decflag = 1 			 					   ' Found a declared document
			Else
				If doc.edrmsrecord(0) <> "Yes" And doc.edrmsinitialdeclaration(0) = edrmsinitialdeclaration(3) Then
					decflag = 1 			 					   ' Found  a document awaiting overnight declaration
				Else
					If doc.edrmsrecord(0) <> "Yes" Then
						undecflag = 1     					' Found an undeclared document
					End If
				End If
			End If
		Else
			undecflag = 1
		End If
		
		If doc.hasitem("version") Then
			If doc.version(0) > 0 Then
				versionflag = versionflag + 1   ' Doc is versioned
			End If
		End If

' Test for obsolete security declaration, variable is a global as it doesn't justify being a param
		If doc.hasitem("secmarking") Then
			If doc.secmarking(0) <> "" And doc.secmarking(0) <> EDRMSSECMARKING$  Then
				edrmsoldsecmarking = 1
			End If
		End If
' Check user is eligible author (editor) to Main docs
		If UCase(doc.form(0)) <> "RESPONSE" And UCase(doc.form(0)) <> "RESPONSE TO RESPONSE" And UCase(doc.form(0)) <> "ALERT" Then
			Call edrms_get_doc_access(doc,editoraccess)
			If editoraccess = "No" Then
				editorlevel = 2                                    ' Main docs selected that the current user is not an eligible author of
			End If
		End If

' Check user is eligible author (editor) to all responses
		edrmslimitedaccessflag = 0           ' Global
		Call edrms_recurse_responses(doc, MODE$,"","","",Nothing,Nothing,0,0)
		If edrmsdoceditor = "No" Or edrmslimitedaccessflag = 1   Then          ' Globals - at the time too few uses as params, obviously would change now
			editorlevel = 1                                                                                                ' Responses exist that the current user is not an eligible author of
		End If

		Set doc = dc.GetNextDocument(doc)
	Wend
	
	If decflag = 1 And undecflag = 1  Then
		recordflag = 2						' Found both declared and undeclared
	Else
		If decflag = 0 And undecflag = 1  Then
			recordflag = 1						' Found only undeclared
		End If
	End If

Exit Sub
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_check_responses_records_errortext
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Sub
End Sub
Sub edrms_declare_selected_records
	' Called from a view
	Const MODE$ = "DECLARE"
	Dim ws As New NotesUIWorkspace
	Dim dcview As NotesDocumentCollection
	Dim dcr As NotesDocumentCollection
	Dim doc As NotesDocument
	Dim category As String
	Dim msg As string
	Dim edrms_declare_selected_records_errortext As String
	Dim responseflag As Integer
	Dim  recordflag As Integer
	Dim editorlevel As Integer
	Dim versionflag As Integer
	Dim continue As Variant

	edrms_declare_selected_records_errortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	edrmsrespcount=0

	Call edrms_get_view_selected_docs(dcview)
	If(dcview.count = 0) Then
		Exit Sub
	End If
	
	call edrms_check_responses_records(dcview,responseflag,recordflag,editorlevel ,versionflag)
	If editorlevel = 1 Then
		msg = "You are not an eligible editor of all the selected documents in scope (including responses), you need either higher database access or to be a named editor of the documents"
		MessageBox msg ,16, edrmsdb.title &" " & EDRMSTERM$ & " Access Error"
		Exit Sub
	End If

	edrmsretval = edrms_choose_record_category
	If Not IsEmpty(edrmsretval) Then
		category = edrmsretval
		Set doc = dcview.getfirstdocument
		While Not doc Is Nothing
			If Not doc.Isresponse Then      ' Stop arbitrary selection of Responses/Resp To Resps
				Call edrms_check_declare(doc, continue)
				If continue = True Then
					Call edrms_declare_set_values(doc,category,edrmscurrentuser.abbreviated)
					Set dcr = doc.Responses
					If dcr.count > 0 Then
						Call edrms_recurse_responses(doc,MODE$,category,edrmscurrentuser.abbreviated,Date$,Nothing,Nothing,0,0)
					End If
				Else
					Exit Sub
				End If
			Else
				MsgBox "Please do not select response documents, exiting",16,edrmsdb.title &" " &  LCase(LSI_Info(2)) & " Illegal Action"
				Exit Sub
			End If
			Set doc = dcview.getnextdocument(doc)
		Wend
		MessageBox "Declared " & CStr(dcview.count) & " documents and " & CStr(edrmsrespcount) & " responses as records",64, edrmsdb.title &" " & EDRMSTERM$ & " Declaration"
		'		Call UIView.DeselectAll
		Call ws.viewrefresh
	Else
		MsgBox "No Record Type chosen, exiting the declaration.",16,edrmsdb.title &" " & LCase(LSI_Info(2)) & " Illegal Action"
	End If
End Sub
Sub edrms_get_doc_access(doc As NotesDocument,editoraccess As String)
	On Error GoTo globalerrhandle
	Dim authoritem As NotesItem
	Dim nn As NotesName
	Dim edrms_get_doc_access_errortext As String
	Dim y As Integer
	Dim z As Integer
	Dim authorvar As Variant

	edrms_get_doc_access_errortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	editoraccess = "No"
	If edrmsdbeditor = "Yes" Then                                                     ' ALREADY ESTABLISHED THAT USER IS Database EDITOR AT LEAST
		editoraccess = "Yes"
		Exit Sub
	End If

	authorvar = doc.documentauthors                                                ' Computed authors field
	authorvar = ArrayAppend(authorvar,doc.Authorlist)                  ' User-definable authors list

	If doc.hasitem("registrar") Then                                     				 ' Registrar role is in authors field 
		authorvar = ArrayAppend(authorvar,doc.registrar)               
	End If
	
	If doc.hasitem("templateauthors") Then                                      ' documents from template are created differently 
		authorvar = ArrayAppend(authorvar,doc.templateauthors)
	End If
	
	Set authoritem = doc.getfirstitem("authors")                               ' DJS V004 17/02/2016 - Not sure about this as notesdocument authors is a native read-only property so in theory shouldn't be able to be set 
	If Not authoritem Is Nothing Then                                                 ' note that you cannot directly access a field called "authors" because this is a notesdocument property
		authorvar = ArrayAppend(authorvar,authoritem.values)      ' The reason for this is the problem reported by Gary Greenwood and investigated by Robbie 
	End If                                                                                                   ' of Reviewing Declared Letters that have been Re-Assigned and the use of a field "Authors" by letters and blanksheets
	
	authorvar = ArrayUnique(FullTrim(authorvar),5)                        ' DJS V004 17/02/2016 - Remove redundant or blank entries
	
	For y = LBound(authorvar) To UBound(authorvar)
		Set nn = New NotesName(authorvar(y))
		If nn.abbreviated = edrmscurrentuser.abbreviated Then      ' Current user is listed by name in an authors field
			editoraccess = "Yes"
			Exit Sub
		End If
	Next

' Go through the list of authors which may include groups & roles that the current user belongs to
' and match with the result of @Usernameslist for the user held in the global edrmsusernameslist
	For y = LBound(authorvar) To UBound(authorvar)
		Set nn = New NotesName(authorvar(y))
		For z = LBound(edrmsusernameslist) To UBound(edrmsusernameslist)
			Dim nnn As New NotesName(edrmsusernameslist(z))
			If nnn.abbreviated = nn.abbreviated Then			           ' Current user is in a group or role that has author access
					editoraccess = "Yes"
					Exit Sub
			End If
		Next
	Next

	Exit Sub
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_get_doc_access_errortext
	Error Error ' Mad but effective
	Exit Sub
End Sub
Sub edrms_agent_move_to_other_bdb(Agent As NotesAgent)
	On Error GoTo errhandle
	Const MODE$ = "MOVE"
	Dim target_bdb As NotesDatabase
	Dim dcdel As NotesDocumentCollection
	Dim doc As NotesDocument
	Dim holdstring As String
	Dim target_server As String
	Dim msg As String
	Dim editoraccess As String
	Dim targetaccesslevel As Integer
	Dim responseflag As Integer
	Dim categoryflag As Integer
	Dim errorcnt As Integer
	Dim versioncount As Integer
	Dim level As Integer
	Dim reviewed As Long
	Dim errortot As Long
	Dim responsemoved As Long
	Dim retarr As Variant
	Dim replyvar As Variant

	responseflag = 0
	versioncount = 0
	targetaccesslevel = 0
	reviewed = 0
	responsemoved = 0
	errorcnt = 0
	errortot = 0

	Set dcdel = edrmsdb.GetProfileDocCollection( "NOSUCHTHING" ) ' Initialise the dcdel collection as empty - code from IBM Site - the issue was that uninitialised it cannot be copied to

	edrmserrortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	Call initlog(agent.name)

	If edrmsdbdelete = "No" Then
		MsgBox "You don't have sufficient access to be able to delete documents in this BDB",16,edrmsdb.title &" " & EDRMSTERM$ &" Action Denied"
		logaction("User does not have delete access to this database so has been informed of this and exited.")
		Exit Sub
	End If

	Set edrmsdc = edrmsdb.unprocesseddocuments
	Call logaction("User has selected " & CStr(edrmsdc.count) & " documents")

' Check that the number of documents selected does not exceed the maximum allowed...
	If edrmsdc.count > edrmsmaxmovelimit Then
		MessageBox "The number of records selected (" + CStr(edrmsdc.Count) + "), exceeds the maximum number " +_
		"of records allowed to be moved at any one time (" + CStr(edrmsmaxmovelimit) + _
		"). Please refine your selection.",16,edrmsdb.title &" " & EDRMSTERM$ &" Too Many Records Selected"
		logclose("User has been informed that they have selected more than the maximum documents that can be moved which is " & CStr(edrmsmaxmovelimit))
		Exit Sub
	End If

	Call edrms_check_responses_records(edrmsdc,responseflag,0,0,versioncount)

	If responseflag = 1 Then
		MessageBox "Please restrict your selection to top level documents only. Any response documents present "+_
		"will get picked up automatically if a parent document is selected.",16,edrmsdb.title &" " & EDRMSTERM$ &" Selection Contains Response Documents"
		logclose("User has been informed that they have included responses/resp to resp/alerts and exited.")
		Exit Sub
	End If

	If versioncount = 1 Then
		If edrmsdc.Count = 1 Then
			replyvar = MessageBox("The selected document is a versioned record. If this is moved in isolation, then any links to the records will be broken. " +_
			"You may therefore want to refine your selection to ensure that if a versioned record is selected, then all other records in the same " +_
			"versioning chain are also selected. Continue with the move anyway?",36,edrmsdb.title &" " & EDRMSTERM$ &" Confirmation Required")
		Else
			replyvar = MessageBox("The selected documents contain versioned records. If these are moved in isolation, then any links to these records will be broken. " +_
			"You may therefore want to refine your selection to ensure that if a versioned record is selected, then all other records in the same " +_
			"versioning chain are also selected. Continue with the move anyway?",36,edrmsdb.title &" " & EDRMSTERM$ &" Confirmation Required")
		End If
		logaction("User has been informed that they have included versioned documents and asked if they want to proceed anyhow")
	End If

	If replyvar = 7 Then
		MessageBox "Action aborted",64,edrmsdb.title &" " & EDRMSTERM$ &" Exiting"
		logclose("User chose to exit after the prompt about versioned documents.")
		Exit Sub
	End If

	Call edrms_choose_bdb(target_bdb)                                                               ' User chooses target Database
	If  target_bdb Is Nothing Then
		MessageBox "No destination database selected, action aborted",64,edrmsdb.title &" " & EDRMSTERM$ &" Exiting"
		logclose("User made no choice of destination database, exited")
		Exit Sub
	End If

	If edrmsdb.Title = target_bdb.Title Then
		MessageBox "You cannot select the current database as the target for this move.",16,edrmsdb.title &" " & EDRMSTERM$ &" Exiting"
		logclose("User chose the current database as the destination database, exited")
		Exit Sub
	End If

	Call edrms_get_db_access(target_bdb,"","",targetaccesslevel)                  ' Check user access to target Database
	If targetaccesslevel < 3 Then
		MessageBox "You don't have sufficient access to be able to create documents in the target BDB",16,edrmsdb.title &" " & EDRMSTERM$ &" Access to " + target_bdb.Title + " Denied"
		logclose("User only has ACL access level " & CStr(targetaccesslevel) & " to the taget BDB " &  target_bdb.Title & "   Exited")
		Exit Sub
	End If

	If edrmsdc.count = 1 Then
		msg = "This action will move the selected record to " & target_bdb.title & ". Continue?"
	Else
		msg = "This action will move the " + CStr(edrmsdc.count) + " selected records to " + target_bdb.title + ". Continue?"
	End If

	logaction("User prompted " & msg)
	replyvar = MessageBox(msg,36,edrmsdb.title &" " & EDRMSTERM$ &" Confirmation Required")
	If replyvar = 7 Then
		MessageBox "Action aborted",64,edrmsdb.title &" " & EDRMSTERM$ &" Exiting"
		logclose("User chose to exit after the confirmation prompt.")
		Exit Sub
	End If

	Set doc = edrmsdc.getfirstdocument
	While Not doc Is Nothing
		errorcnt = 0
		Call edrms_move_to_other_db(doc,target_bdb,dcdel,reviewed, errorcnt)                     ' Move the top level document
		errortot = errortot + errorcnt
		If errorcnt > 0 Then
			MessageBox "You don't have sufficient access to be able to move the document " & doc.subject(0)
			logclose("User does not have high enough access to move the document " & doc.subject(0) & "   exited")
			Exit Sub
		End If

		Call edrms_recurse_responses(doc,MODE$,"","","",target_bdb,dcdel,responsemoved,errorcnt)    ' Move the responses

		Set doc=edrmsdc.GetNextDocument(doc)
	Wend

	If errorcnt = 0 Then
		If reviewed = 0 Then
			msg = "Action complete. No records were moved."
		ElseIf reviewed = 1 Then
			If responsemoved = 0 Then
				msg = "Action complete. 1 record was moved to BDB " & target_bdb.title
			ElseIf responsemoved = 1 Then
				msg = "Action complete. 1 record and 1 response were moved to BDB " & target_bdb.title
			Else
				msg = "Action complete. 1 record and " + CStr(responsemoved) + " responses were moved to BDB " & target_bdb.title
			End If
		Else
			If responsemoved = 0 Then
				msg = "Action complete. " + CStr(reviewed) + " records were moved to BDB " & target_bdb.title
			ElseIf responsemoved = 1 Then
				msg = "Action complete. " + CStr(reviewed) + " records and 1 response were moved to BDB " & target_bdb.title
			ElseIf responsemoved > 1 Then
				msg = "Action complete. " + CStr(reviewed) + " records and " + CStr(responsemoved) + " responses were moved to BDB " & target_bdb.title
			End If
		End If
	Else
		If reviewed = 0 And errorcnt = 1 Then
			msg = "Action incomplete. It was not possible to move the selected record."
		ElseIf reviewed = 0 And errorcnt > 1 Then
			msg = "Action incomplete. It was not possible to move any of the selected records."
		ElseIf reviewed = 1 Then
			If responsemoved = 0 Then
				If errorcnt = 1 Then
					msg = "Action complete. 1 record was moved to BDB " & target_bdb.title + ". 1 record could not be moved."
				Else
					msg = "Action complete. 1 record was moved to BDB " & target_bdb.title + ", " + CStr(errorcnt) + " records could not be moved."
				End If
			ElseIf responsemoved = 1 Then
				If errorcnt = 1 Then
					msg = "Action complete. 1 record and 1 response were moved to BDB " & target_bdb.title + ", 1 record could not be moved."
				Else
					msg = "Action complete. 1 record and " + CStr(responsemoved) + " were moved to BDB " & target_bdb.title + ", "  + CStr(errorcnt) + " records could not be moved."
				End If
			End If
		Else
			If responsemoved > 1 Then
				If errorcnt = 1 Then
					msg = "Action complete. " + CStr(reviewed) + " records and " + CStr(responsemoved) + " responses were moved to BDB " & target_bdb.title + ", 1 record could not be moved."
				Else
					msg = "Action complete. 1 record and " + CStr(responsemoved) + " responses were moved to BDB " & target_bdb.title + ", " + CStr(errorcnt) + "records could not be moved."
				End If
			End If
		End If
	End If

	logaction("Removing all " & CStr(dcdel.count) & "  documents in the deletion document collection")
	Call dcdel.removeall(True)
	MessageBox msg,64,edrmsdb.title &" " & EDRMSTERM$ &" Completed"
	Call logclose(msg)
	Exit Sub
errhandle:
	Call logerror(Err, Error, Erl, LSI_Info(2), LSI_Info(12), " Last module before this call " & edrmserrortext)
	Call logaction(" Last Global Error " & edrmslastglobalerr )
	Call alerterrors(agent.name ,"Error")     ' EMAILS THE ERROR ALERT TO ADDRESS IN PROFILE
	Exit Sub
End Sub

Sub edrms_agent_process_delayed_updates(Agent As NotesAgent)
	' edrmsdelayedflag = 1 Documents with responses to be declared
	' edrmsdelayedflag = 2 Reviewed records for retention with responses to be processed
	' edrmsdelayedflag = 3 Reviewed records for deletion with responses to be processed
	' edrmsdelayedflag = 4 Reviewed records where EDRMS Categories have been added
	On Error GoTo errhandle
	Const MODE1$ = "DECLARE"
	Const MODE2$ = "MARKREVIEW"
	Const REVIEWSTATUS$ = "Re-declared"
	Const REVIEWDELSTATUS$ = "Not Required"
	Dim dc(3) As NotesDocumentCollection
	Dim dcnotrequired As NotesDocumentCollection
	Dim doc As NotesDocument
	Dim nn As NotesName
'	Dim dt As New NotesDateTime("Yesterday")
	Dim selectstring(3) As String
	Dim nrselectstring As String
	Dim report As String
	Dim responsecount As Long
	Dim totalselected As Long
	Dim i As Integer
	Dim j As Integer

	responsecount = 0
	totalselected = 0
	j = 1

	If (edrmsdbservernn.common <> edrmsmasterservernn.common) Then
		Exit Sub   ' Not on master server so exit
	End If

	edrmserrortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	Call initlog(agent.name)

	For i = LBound(selectstring) To UBound(selectstring)
		selectstring(i) = "edrmsdelayedflag = " & CStr(j)
'		Call logaction("Setting dc" & CStr(i) & " To " & selectstring(i) & " from date " & dt.Dateonly)
		Call logaction("Setting dc" & CStr(i) & " To " & selectstring(i))
		Set dc(i) = edrmsdb.search(selectstring(i),nothing,0)
		j = j + 1
		totalselected = totalselected + dc(i).count
	Next

	' Process delayed declaration updates...

	If dc(0).count > 0 Then
		Call logaction("dc0: Declaring " & CStr(dc(0).count))
		Set doc = dc(0).GetFirstDocument
		While Not doc Is Nothing
			Set nn = New NotesName(doc.edrmsdeclaredby(0))
			logaction("Declaring main document " & doc.subject(0))
			Call edrms_declare_set_values(doc,doc.edrmscategory(0),nn.abbreviated)
			logaction("Declaring responses")
			Call edrms_recurse_responses(doc,MODE1$,doc.edrmscategory(0),nn.abbreviated,doc.edrmsdate(0),Nothing,Nothing,responsecount,0)
			Set doc = dc(0).GetNextDocument(doc)
		Wend
	End If

	' Process delayed record retention updates...

	If dc(1).count > 0 Then
		Call logaction("dc1: Marking " & CStr(dc(1).count) & " to keep")
		Set doc = dc(1).GetFirstDocument
		While Not doc Is Nothing
			Set nn = New NotesName(doc.edrmsdeclaredby(0))
			logaction("Main document marked as " & REVIEWSTATUS$  & " " & doc.subject(0))
			Call edrms_mark_review_status(doc,REVIEWSTATUS$,responsecount,nn.abbreviated,doc.edrmsreviewdate(0),doc.edrmscategory(0))  ' doc save is in here
			logaction("Recursing response thread")
			Call edrms_recurse_responses(doc,MODE2$,REVIEWSTATUS$,nn.abbreviated,doc.edrmsreviewdate(0),Nothing,Nothing,responsecount,0)
			Set doc = dc(1).GetNextDocument(doc)
		Wend
		responsecount = responsecount + edrmsrespcount
	End If

	If dc(2).count > 0 Then
		Call logaction("dc2: Marking " & CStr(dc(2).count) & " for deletion")
		Set doc = dc(2).GetFirstDocument
		While Not doc Is Nothing
			Set nn = New NotesName(doc.edrmsreviewedby(0))
' 			Not sure why Set To REVIEWDELSTATUS$ Then EDRMSTRANSFERSTATUS$ later so doing it here instead
			Call edrms_mark_review_status(doc,EDRMSTRANSFERSTATUS$,responsecount,nn.abbreviated,"","")
			logaction("Main doc marked as " & EDRMSTRANSFERSTATUS$ & " " & doc.subject(0))
			logaction("Recursing response thread")
			Call edrms_recurse_responses(doc,MODE2$,EDRMSTRANSFERSTATUS$,nn.abbreviated,"",Nothing,Nothing,responsecount,0)
			Set doc = dc(2).GetNextDocument(doc)
		Wend
	End If

	If dc(3).count > 0 Then
		Call logaction("dc3: Marking " & CStr(dc(2).count) & " as Re-Declared") ' markallresponsesadd(doc,responsecount%)
		Set doc = dc(3).GetFirstDocument
		While Not doc Is Nothing
			Set nn = New NotesName(doc.edrmsdeclaredby(0))
			logaction("Main document marked as " & REVIEWSTATUS$ & " " & doc.subject(0))
			Call edrms_mark_review_status(doc,REVIEWSTATUS$,responsecount,nn.abbreviated,doc.edrmsreviewdate(0),doc.edrmscategory(0))  ' doc save is in here
			logaction("Recursing response thread")
			Call edrms_recurse_responses(doc,MODE2$,REVIEWSTATUS$,nn.abbreviated,"",Nothing,Nothing,responsecount,0)
			Set doc = dc(3).GetNextDocument(doc)
		Wend
	End If

	If totalselected = 0 Then
		report = "No documents to process were found."
	Else
'		If dc(2).count > 0 Then
'			logaction("Stamping the dc(2) documentcollection which contains " & CStr(dc(2).count) & " documents, setting field edrmsreviewstatus to " & EDRMSTRANSFERSTATUS$)
'			Call dc(2).StampAll("edrmsreviewstatus",EDRMSTRANSFERSTATUS$)
'		End If
		' Delete the flag from the source documents...
		For i = LBound(dc) To UBound(dc)
			Call dc(i).StampAll("edrmsdelayedflag", Null)
		Next
		report = CStr(responsecount) + " response documents were processed."
	End If

	Call logclose("Ends OK " & report)

	Exit Sub
errhandle:
	Call logerror(Err, Error, Erl, LSI_Info(2), LSI_Info(12), " Last module before this call " & edrmserrortext )   ' LOGS HELPFUL DETAIL ON AN ERROR
	Call logaction(" Last Global Error " & edrmslastglobalerr)
	Call alerterrors(agent.name ,"Error")     ' EMAILS THE ERROR ALERT TO ADDRESS IN PROFILE
	Exit Sub
End Sub
Sub edrms_agent_force_document_deletion(Agent As NotesAgent)
	On Error GoTo errhandle
	Dim ws As New notesuiworkspace
	Dim doc As NotesDocument
	Dim msg As String
	Dim replyval As Variant

	edrmserrortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	Call initlog(agent.name)

	If edrmsadminsgroupmember <>  "Yes" Then
		MessageBox "You are not a member of " & EDRMSADMINSGROUP$ & " usage of force deletion is restricted to the system admins",16,edrmsdb.title &" " & EDRMSTERM$ & " Exiting"
		logclose("User informed that they are not a member of " & EDRMSADMINSGROUP$ & " and exited")
		Exit Sub
	End If

	If edrmsdbdelete <>  "Yes" Then
		MessageBox "You are a member of " & EDRMSADMINSGROUP$ & " but you do not have delete document access",16,edrmsdb.title &" " & EDRMSTERM$ & " Exiting"
		logclose("User informed that they are a member of " & EDRMSADMINSGROUP$ & " but do not have delete document access and exited")
		Exit Sub
	End If

	Set edrmsdc = edrmsdb.unprocesseddocuments

	If edrmsdc.count = 0 Then
		MessageBox "Please select a document",16,edrmsdb.title &" " & EDRMSTERM$ & " No document selected"
		logclose("User had not selected any documents, told to do so and code exited")
		Exit Sub
	End If

	msg = "This action will force deletion of " & CStr(edrmsdc.count) & " documents, do you want to proceed?"
	logaction("User prompted: " & msg)
	replyval = MessageBox (msg,36,edrmsdb.title &" " & EDRMSTERM$ & " Confirmation Required")
	If replyval = 7 Then
		MessageBox "Action aborted",64,edrmsdb.title &" " & EDRMSTERM$ & " Exiting"
		logclose("User aborted at confirmation prompt")
		Exit Sub
	End If

	Set doc = edrmsdc.getfirstdocument
	While Not doc Is Nothing
		logaction("Document will be deleted " & doc.subject(0))
		Set doc = edrmsdc.getnextdocument(doc)
	Wend
	logaction("Removing all from the Documentcollection")
	Call edrmsdc.RemoveAll(True)
	Call edrms_deselect_docs(ws)
	Call logclose("Ends OK")

Exit Sub
errhandle:
Call logerror(Err, Error, Erl, LSI_Info(2), LSI_Info(12), " Last module before this call " & edrmserrortext )   ' LOGS HELPFUL DETAIL ON AN ERROR
Call logaction(" Last Global Error " & edrmslastglobalerr)
Call alerterrors(agent.name ,"Error")     ' EMAILS THE ERROR ALERT TO ADDRESS IN PROFILE
Exit Sub
End Sub
Function edrms_util_implodearray(Arr As Variant,delimiter As String) As String
On Error GoTo globalerrhandle
	Dim edrms_util_implodearray_errtxt As String
	Dim replyval As Variant

	edrms_util_implodearray_errtxt = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	Dim evaluatedoc As New NotesDocument(edrmsdb)
	evaluatedoc.arrValues = arr
	evaluatedoc.delimiter = delimiter
	replyval = Evaluate({@Implode(arrValues;delimiter)},evaluatedoc)
	edrms_util_implodearray = replyval(0)

Exit Function
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_util_implodearray_errtxt
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Function
End Function
Function edrms_profile_setup
	On Error GoTo globalerrhandle
	Dim metaprofiledoc As NotesDocument
	Dim edrms_profile_setup_errortext As String
	Dim helperdbsret As Integer

	edrms_profile_setup_errortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	' Getting DB handles to edrmsncddb, edrmsnabdb, edrmsmetadatadb, edrmsholdingdb, edrmscountsdb
	helperdbsret = edrms_get_helper_dbs
	If helperdbsret > 0 Then
		Print edrms_profile_setup_errortext & " Error getting helper DB Handles"
		Exit Function
	End If

	Set metaprofiledoc = edrmsmetadatadb.getprofiledocument( EDRMSMETADBPROFILENAME$)
	If metaprofiledoc Is Nothing Then
		Print edrms_profile_setup_errortext & " Error getting " & edrmsmetadatadb.title & " profile document " & EDRMSMETADBPROFILENAME$
		Exit Function
	End If

	edrmsprofiledoc.EDRMSMasterServer = metaprofiledoc.AgentServer(0)
	edrmsprofiledoc.EDRMSCategories = metaprofiledoc.EDRMSCategories
	edrmsprofiledoc.EDRMSRetention = metaprofiledoc.EDRMSRetention
	edrmsprofiledoc.EDRMSMaxDeclareLimit = metaprofiledoc.DeclareLimit(0)
	edrmsprofiledoc.EDRMSMaxMoveLimit = metaprofiledoc.MoveLimit(0)
	edrmsprofiledoc.EDRMSMaxReviewLimit = metaprofiledoc.ReviewLimit(0)
	edrmsprofiledoc.EDRMSBDBTitle = edrmsdb.Title
	edrmsprofiledoc.save True,False

	Exit Function
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_profile_setup_errortext
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Function
End Function
Sub edrms_examine_acl_roles(view As NotesView,item As NotesItem,roletocheck As String,sendto() As string,regrolelist As String)
	On Error GoTo globalerrhandle
	Dim Acl As NotesACL
	Dim aclentry As NotesACLEntry
	Dim dc As NotesDocumentCollection
	Dim doc As NotesDocument
	Dim rolename As NotesName
	Dim edrms_examine_acl_roles_errtxt As String
	Dim groupname As String
	Dim selectstring As String
	Dim aclcount As Integer
	Dim a As Integer

	aclcount = 0

	edrms_examine_acl_roles_errtxt = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	Set acl=edrmsdb.acl
	Set aclentry = acl.getfirstentry
' get list of staff with [registrar] role set to use as address of "Non-NCD" email
	Do While Not aclentry Is Nothing
		For a = 0 To UBound(aclentry.roles)
			If aclentry.roles(a) = roletocheck Then   'EDRMSREGISTRAR$
				Set rolename = New NotesName(aclentry.name)
				Set doc = view.getdocumentbykey(rolename.Abbreviated,True)      ' check role holder is on NCD		rob 
				If Not doc Is Nothing Then ' on NCD
					ReDim Preserve sendto(aclcount)
					sendto(aclcount) = aclentry.name
					If regrolelist = "" Then
						regrolelist = rolename.common
					Else
						regrolelist = regrolelist & ", " & rolename.common
					End If
					Call item.AppendToTextList(aclentry.name)
					aclcount = aclcount + 1
				Else

%REM
					ACLTYPE_UNSPECIFIED (0)
					ACLTYPE_PERSON (1)
					ACLTYPE_SERVER (2)
					ACLTYPE_MIXED_GROUP (3)
					ACLTYPE_PERSON_GROUP (4)
					ACLTYPE_SERVER_GROUP (5)
%END REM
				' check that the entry is not a server or group
				If aclentry.Usertype < 2  Then

					' check that entry is not a group entry on the NAB
					groupname = aclentry.name
					selectstring = "(Form = ""Database"" | Form = ""Group"") & (Type = ""Database"" | (Type = ""Group"" & GroupType = ""0"":""1"")) & (Fullname =  """ +_
					groupname + """ | Listname = """+ groupname + """)"

					Set dc = edrmsnabdb.Search(selectstring,Nothing,0)
					If dc.count = 1 Then                                 ' on NAB
						ReDim Preserve sendto(aclcount)
						sendto(aclcount) = aclentry.name
						If regrolelist = "" Then
							regrolelist = rolename.common
						Else
							regrolelist = regrolelist + ", " + rolename.common
						End If
						Call item.AppendToTextList(aclentry.name)
						aclcount = aclcount + 1
					End If

				End If

				End If
			End If
		Next
		Set aclentry = acl.getnextentry(aclentry)
	Loop

	Exit Sub
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_examine_acl_roles_errtxt
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Sub
End Sub
Sub edrms_move_to_other_db(doc As NotesDocument,target_db As NotesDatabase,dc As NotesDocumentCollection,movedcount As Long, errorcnt As Integer)
	On Error GoTo globalerrhandle
	Dim editoraccess As String
	Dim edrms_move_to_other_db_errtext As String

	edrms_move_to_other_db_errtext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	Call edrms_get_doc_access(doc,editoraccess)                    ' find user document access
	If(editoraccess = "Yes") Then
		Call edrms_update_log(doc,EDRMSLOG$,"Moved from " & edrmsdb.title,edrmscurrentuser.abbreviated)
		Call doc.save(True,True)
		Call doc.CopyToDatabase(target_db)
		movedcount = movedcount + 1
		Call dc.AddDocument(doc)
	Else
		errorcnt = errorcnt + 1
	End If

	Exit Sub
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_move_to_other_db_errtext
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Sub
End Sub
Sub edrms_agent_delete_old_advice_logs(Agent As NotesAgent)
	On Error GoTo errhandle
	Dim view As NotesView
	Dim vc As NotesViewEntryCollection

	edrmserrortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	If (edrmsdbservernn.common <> edrmsmasterservernn.common) Then
		Exit Sub   ' Not on master server so exit
	End If

	Call initlog(agent.name)

	Set view = edrmsdb.GetView(EDRMSVIEWLOGDELETE$)
	Set vc = view.allentries

	If vc.Count = 0 Then
		logclose("No log documents to delete in database ")
		Exit Sub
	Else
		logaction "Deleting " & CStr(vc.Count) & " log documents"
		Call vc.RemoveAll(True)
	End If

	Call logclose("Ends OK")

Exit Sub
errhandle:
Call logerror(Err, Error, Erl, LSI_Info(2), LSI_Info(12), " Last module before this call " & edrmserrortext )   ' LOGS HELPFUL DETAIL ON AN ERROR
Call logaction(" Last Global Error " & edrmslastglobalerr)
Call alerterrors(agent.name ,"Error")     ' EMAILS THE ERROR ALERT TO ADDRESS IN PROFILE
Exit Sub
End Sub

Sub edrms_agent_mop_up(Agent As NotesAgent)
	' Runs once scheduled in December, similar to agent edrms_agent_review_recs_not_reqd
	On Error GoTo errhandle
	Const MODE$ = "MARKREVIEW"
	Const REVIEWSTATUS$ = "Not Required"
	Dim view As NotesView
	Dim dc As NotesDocumentCollection
	Dim doc As NotesDocument
	Dim selectstring As String
	Dim reviewed As Long
	Dim responsereviewed As Long

	If (edrmsdbservernn.common <> edrmsmasterservernn.common) Then
		Exit Sub   ' Not on master server so exit
	End If

	edrmserrortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	Call initlog(agent.name)

	Set view = edrmsdb.GetView(EDRMSVIEWREVIEWEDREMAIN$)
	Set doc=view.getfirstdocument
	While Not doc Is Nothing
		If Not doc.IsResponse Then
			doc.edrmssourcebdbtitle = edrmsdb.Title
			doc.edrmssourcebdbpath = edrmsdb.filepath
			Call edrms_mark_review_status(doc,REVIEWSTATUS$,reviewed,agent.name,"","")
			logaction("Main doc marked as " & REVIEWSTATUS$  &" " &  doc.subject(0))
			logaction("Recursing response thread")
			Call edrms_recurse_responses(doc,MODE$,REVIEWSTATUS$,agent.name,"",Nothing,Nothing,responsereviewed,0)
		End If
		Set doc=view.getnextdocument(doc)
	Wend

	' Move marked documents from this view to a holding view, ready for the agent to move the record to the EDRMS Management DB...

	selectstring = "edrmsreviewstatus = """  & REVIEWSTATUS$ & """"
	logaction("Setting the documentcollection with query " & selectstring)
	Set dc = edrmsdb.search (selectstring$,Nothing,0)
	logaction("Stamping the documentcollection which contains " & CStr(dc.count) & " documents as " & EDRMSTRANSFERSTATUS$)
	Call dc.StampAll("edrmsreviewstatus",EDRMSTRANSFERSTATUS$)
	Call logclose("Ends OK")

	Exit Sub
errhandle:
	Call logerror(Err, Error, Erl, LSI_Info(2), LSI_Info(12), " Last module before this call " & edrmserrortext )   ' LOGS HELPFUL DETAIL ON AN ERROR
	Call logaction(" Last Global Error " & edrmslastglobalerr)
	Call alerterrors(agent.name ,"Error")     ' EMAILS THE ERROR ALERT TO ADDRESS IN PROFILE
	Exit Sub
End Sub
Sub edrms_agent_declare_today(agent As NotesAgent)
	On Error GoTo errhandle
	Const MODE$ = "DECLARE"
	Dim view As NotesView
	Dim doc As NotesDocument
	Dim nn As NotesName
	Dim editoraccess As String

	edrmserrortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	If (edrmsdbservernn.common <> edrmsmasterservernn.common) Then
		Exit Sub   ' Not on master server so exit
	End If

	Call initlog(agent.name)
	Set view = edrmsdb.getview(EDRMSVIEWDECLARETODAY$)
	 view.AutoUpdate = False
	logaction("Current user Database access editor or above " & edrmsdbeditor)

	Set doc = view.getfirstdocument
	While Not doc Is Nothing
		doc.edrmsinitialdeclaration = "Declared on Date of Creation"
		doc.save True, True
		Set nn = New NotesName(doc.edrmsdeclaredby(0))
		Call edrms_declare_set_values(doc,doc.edrmscategory(0),nn.abbreviated)		' SET THE EDRMS VALUES THE STANDARD WAY
		Call edrms_recurse_responses(doc,MODE$,doc.edrmscategory(0),nn.abbreviated,Date$,Nothing,Nothing,0,0)
		logaction("Automatically Declared initial declaration of today for " & doc.subject(0) & " Author " & nn.abbreviated & " and responses")
		Set doc = view.getnextdocument(doc)
	Wend
	Call logclose("Ends OK")
Exit Sub
errhandle:
	Call logerror(Err, Error, Erl, LSI_Info(2), LSI_Info(12), " Last module before this call " & edrmserrortext )   ' LOGS HELPFUL DETAIL ON AN ERROR
	Call alerterrors(agent.name ,"Please see the log for details")     ' EMAILS THE ERROR ALERT TO ADDRESS IN PROFILE
	Call logaction(" Last Global Error " & edrmslastglobalerr)
	Exit Sub
End Sub


Function edrms_amend_category_values(doc As NotesDocument,category As String,declaredby As String,reviewdate As String)
	On Error GoTo globalerrhandle
	Dim edrms_amend_category_values_errortext As String
	edrms_amend_category_values_errortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	doc.edrmscategory = category
	doc.edrmsreviewdate = CDat(reviewdate)
	Call edrms_update_log(doc,EDRMSLOG$,"Category/Record Type and review date if required amended on ",declaredby)
	doc.save False, False
Exit Function
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_amend_category_values_errortext
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Function
End Function

Function edrms_check_record_category(dc As NotesDocumentCollection) As String
	On Error GoTo globalerrhandle
	Dim doc As NotesDocument
	Dim edrms_check_record_category_errtext As String
	Dim category_present As Integer
	Dim category_absent As Integer

	edrms_check_record_category_errtext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	edrms_check_record_category = ""
	category_present = 0
	category_absent = 0

	Set doc = dc.getfirstdocument
	While Not doc Is Nothing
		If doc.hasitem("edrmscategory") Then
			If doc.edrmscategory(0) <> "" Then
				category_present = category_present + 1
			Else
				category_absent = category_absent + 1
			End If
		Else
			category_absent = category_absent + 1
		End If
		Set doc = dc.getnextdocument(doc)
	Wend

	If category_absent > 0 And category_present > 0 Then
		edrms_check_record_category = "Both"
		Exit Function
	End If
	If category_absent > 0 Then
		edrms_check_record_category = "No"
		Exit Function
	End If
	If category_present > 0 Then
		edrms_check_record_category = "Yes"
	End If

Exit Function
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_check_record_category_errtext
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Function
End Function
Function edrms_undeclare_set_values(doc As NotesDocument,undeclaredby As String)
	On Error GoTo globalerrhandle
	Dim item As NotesItem
	Dim edrms_undeclare_set_values_errtext As String
	Dim i As Integer
	Dim actioner As Variant

	edrms_undeclare_set_values_errtext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	For i = LBound(edrmsfields) To UBound(edrmsfields)
		Set item = doc.getfirstitem(edrmsfields(i))
		If Not item Is Nothing Then
			Call doc.replaceitemvalue(edrmsfields(i),"")    ' These are the default for a new doc
		End If
	Next

' log the actions
	Call edrms_update_log(doc,EDRMSLOG$, "Document Undeclared on ",undeclaredby)

'Put back default new doc value
' REMOVED DUE TO VERSIONING ISSUE 	Call doc.replaceitemvalue(edrmsfields(4),edrmsinitialdeclaration(2))
	doc.save False, False
Exit Function
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_undeclare_set_values_errtext
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Function
End Function
Sub edrms_agent_undeclared_records_delete(Agent As NotesAgent)
	On Error GoTo errhandle
	Const MODE$ = "UNDECLAREDRECORDSDELETE"    ' Clumsy . . . sigh
	Dim view As NotesView
	Dim checkview As NotesView
	Dim doc As NotesDocument
	Dim checkdoc As NotesDocument
	Dim helperdbsret As Integer
	Dim censusdb As Integer
	Dim totctmain As Long
	Dim totctresponse As Long
	Dim totct As Long

	totct = 0
	totctmain = 0
	totctresponse = 0

	If edrmssess.Isonserver Then
		If (edrmsdbservernn.common <> edrmsmasterservernn.common) Then
			Exit Sub   ' When run scheduled, not on master server so exit
		End If
	End If
	
	edrmserrortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	Call initlog(agent.name)

' Call the function that gets the required external DBS
	logaction("Getting DB handles to edrmsncddb, edrmsnabdb, edrmsmetadatadb, edrmsholdingdb, edrmscountsdb")
	helperdbsret = edrms_get_helper_dbs
	If helperdbsret > 0 Then
		logaction("Error getting one or more of the required external databases, check the Lookup.nsf and the default accesses to these DBs, error code = " & CStr(helperdbsret))
		logaction("Error codes: NCD = 99, NAB = 98, EDRMS Management DB = 97, EDRMS Holding DB = 96, EDRMS Counts DB = 95")
		Call alerterrors(agent.name ,"Error with external databases, error code " & CStr(helperdbsret))
		Exit Sub
	End If

	' Check if this database is on the exceptions list...

	Set checkview = edrmscountsdb.GetView(EDRMSEXCEPTIONSVIEW$)
	Set checkdoc = checkview.GetDocumentByKey(edrmsdb.FilePath,True)
	censusdb = 0
	If Not checkdoc Is Nothing Then    ' Found on exceptions
		censusdb = 1
	End If

	Set view = edrmsdb.getview(EDRMSVIEWREBUILD5$)     ' EDRMS7
	view.AutoUpdate = False
	Set doc = view.getfirstdocument

	If censusdb = 0 Then 'Not on the exceptions list. Mark document and responses for deletion
		logaction("Starting main loop for normal databases")
		While Not doc Is Nothing
			logaction("Marking " & doc.subject(0) & " for deletion")
			Call edrms_mark_deletion_values(doc,totctmain,edrmscurrentuser.abbreviated,MODE$)

			logaction("Marking responses to " & doc.subject(0) & " for deletion")
			Call edrms_recurse_responses(doc,MODE$,"",edrmscurrentuser.abbreviated,"",Nothing,Nothing,totctresponse,0)

			Set doc=view.getnextdocument(doc)
		Wend

	Else ' Set VersionCreateDate to creation date + 6 months or VersionCreateDate + 6 months if field already exists
		logaction("Starting main loop for Census databases")
		While Not doc Is Nothing
			If Not doc.HasItem("VersionCreateDate") Then
				Dim dt As New NotesDateTime(doc.created)
				Call dt.AdjustMonth(EDRMSMONTHS%)
				doc.versioncreatedate = dt.lslocaltime
			Else
				Dim dt1 As New NotesDateTime(doc.versioncreatedate(0))
				Call dt1.AdjustMonth(EDRMSMONTHS%)
				doc.versioncreatedate = dt1.lslocaltime
			End If

			doc.advexception = "1"
			logaction("Adjusting the version create date for " & doc.subject(0) & " to " & dt1.Dateonly )
			Call doc.save(True,True)
			totct = totct + 1
			Set doc=view.getnextdocument(doc)
		Wend

	End If

	view.AutoUpdate = True

	If censusdb = 0 Then
		logclose("End of run. Marked " & CStr(totctmain) & " main documents, " & CStr(totctresponse) & " responses for deletion")
	Else
		logclose("End of run. " & "Trigger date amended on " & CStr(totct) & " document(s)")
	End If

	Exit Sub
errhandle:
	Call logerror(Err, Error, Erl, LSI_Info(2), LSI_Info(12), " Last module before this call " & edrmserrortext )   ' LOGS HELPFUL DETAIL ON AN ERROR
	Call logaction(" Last Global Error " & edrmslastglobalerr)
	Call alerterrors(agent.name ,"Error")     ' EMAILS THE ERROR ALERT TO ADDRESS IN PROFILE
	Exit Sub
End Sub
Sub edrms_review_report(action As String,responsereviewed As Long,errorcnt As Integer,reviewed As Long,msg As String)
	On Error GoTo globalerrhandle

	Dim edrms_review_report_errtxt As String

	edrms_review_report_errtxt = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	If errorcnt = 0 Then
		If reviewed = 0 Then
			msg = "Action complete. No records were marked as " & action & "."
		ElseIf reviewed = 1 Then
			If responsereviewed = 0 Then
				msg = "Action complete. 1 record was marked as " & action & "."
			ElseIf responsereviewed = 1 Then
				msg = "Action complete. 1 record and 1 response were marked as " & action & "."
			Else
				msg = "Action complete. 1 record and " + CStr(responsereviewed) + " responses were marked as " & action & "."
			End If
		Else
			If responsereviewed = 0 Then
				msg = "Action complete. " + CStr(reviewed) + " records were marked as " & action & "."
			ElseIf responsereviewed = 1 Then
				msg = "Action complete. " + CStr(reviewed) + " records and 1 response were marked as " & action & "."
			ElseIf  responsereviewed > 1 Then
				msg = "Action complete. " + CStr(reviewed) + " records and " + CStr(responsereviewed) + " responses were marked as " & action & "."
			End If
		End If
	Else
		If reviewed = 0 And errorcnt = 1 Then
			msg = "Action incomplete. It was not possible mark the selected record as " & action & "."
		ElseIf reviewed = 0 And errorcnt > 1 Then
			msg = "Action incomplete. It was not possible to mark any of the selected records as " & action & "."
		ElseIf reviewed = 1 Then
			If responsereviewed = 0 Then
				If errorcnt = 1 Then
					msg = "Action complete. 1 record was marked as no longer required. 1 record requires further attention before it can be marked as " & action & "."
				Else
					msg = "Action complete. 1 record was marked as no longer required, " + CStr(errorcnt) + " records require further attention before they can be marked as " & action & "."
				End If
			ElseIf responsereviewed = 1 Then
				If errorcnt = 1 Then
					msg = "Action complete. 1 record and 1 response were marked as no longer required. 1 record requires further attention before it can marked as " & action & "."
				Else
					msg = "Action complete. 1 record and " + CStr(responsereviewed) + " were marked as no longer required, " + CStr(errorcnt) + " records require further attention before they can be marked as " & action & "."
				End If
			End If
		Else
			If responsereviewed > 1 Then
				If errorcnt = 1 Then
					msg = "Action complete. " + CStr(reviewed) + " records and " + CStr(responsereviewed) + " responses were marked as " & action & ", 1 record requires further attention before it can be marked."
				Else
					msg = "Action complete. 1 record and " + CStr(responsereviewed) + " responses were marked as " & action & ", " + CStr(errorcnt) + "records require further attention before they can be marked."
				End If
			End If
		End If
	End If

	MessageBox msg,64,edrmsdb.title &" " & EDRMSTERM$ &" Completed"

	Exit Sub
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_review_report_errtxt
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Sub
End Sub

Sub edrms_agent_mark_for_deletion(Agent As NotesAgent)
	On Error GoTo errhandle
	Const MODE$ = "MARKFORDELETION"
	Dim ws As New NotesUIWorkspace
	Dim viewdoc As NotesDocument
	Dim doc As NotesDocument
	Dim msg As String
	Dim responseflag As Integer
	Dim recordflag As Integer
	Dim editorlevel As Integer
	Dim versionflag As Integer
	Dim docsdeleted As Long
	Dim responsedeleted As Long
	Dim replyval As Variant

	responseflag = 0
	recordflag = 0
	editorlevel = 0
	versionflag = 0
	docsdeleted = 0
	responsedeleted = 0

	edrmserrortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	Call initlog(agent.name)

	Set edrmsdc = edrmsdb.unprocesseddocuments

	If edrmsdc.count = 0 Then
		MessageBox "Please select a document",16,edrmsdb.title &" " & EDRMSTERM$ & " No document selected"
		logclose("User had not selected any documents, told to do so and code exited")
		Exit Sub
	End If

	Call edrms_check_responses_records(edrmsdc, responseflag, recordflag,editorlevel,versionflag)

	If responseflag = 1 Then
		MessageBox "Please restrict your selection to top level documents only. Any response documents present "+_
		"will get picked up automatically if a parent document is selected.",16,edrmsdb.title &" " & EDRMSTERM$ &" Selection Contains Response Documents"
		logclose("User has been informed that they have included responses/resp to resp/alerts and exited.")
		Exit Sub
	End If

	If recordflag <> 1 Then
		MessageBox "Some of the documents you have selected are declared as " & EDRMSTERM$ &" records (or are pending declaration), please amend your selection to exclude these" _
		,16,edrmsdb.title &" " & EDRMSTERM$ & " Exiting"
		logclose("User has been informed that they have included declared documents and exited.")
		Exit Sub
	End If

	If editorlevel > 0 Then
		MessageBox "One or more of the selected documents have reponses to which you do not have edit access. The parent documents " &_
		" cannot therefore be marked for deletion. Please revise your selection before trying again.",16,edrmsdb.title &" " & EDRMSTERM$
		logaction("User informed that they are not eligible editors to all responses and exited")
		Exit Sub
	End If

	Set doc = edrmsdc.getfirstdocument
	While Not doc Is Nothing
	' Check document not already marked for deletion
		If doc.categories(0) = EDRMSAWDCAT$ And doc.categories_1(0) = EDRMSAWDSUBCAT$ Then
			MessageBox "Your selection includes documents already marked for deletion. Please refine your " +_
			"selection.",16,edrmsdb.title &" " & EDRMSTERM$ & "Invalid Selection"
			logclose("User has been informed that they have included documents already marked for deletion and exited.")
			Exit Sub
		End If
		Set doc = edrmsdc.getnextdocument(doc)
	Wend

	Set doc = edrmsdc.getfirstdocument

	msg = "Are you sure you want to mark the " + CStr(edrmsdc.count) + " selected documents for deletion?"
	logaction("User prompted " & msg)

	replyval = MessageBox (msg,36,edrmsdb.title &" " & EDRMSTERM$ & " Confirmation Required")
	If replyval = 7 Then
		MessageBox "Action aborted",64,edrmsdb.title &" " & EDRMSTERM$ & " Exiting"
		logclose("User aborted at confirmation prompt")
		Exit Sub
	End If

	While Not doc Is Nothing

		doc.OrigCategory = doc.categories
		doc.OrigCategory_1 = doc.categories_1
		doc.categories = EDRMSAWDCAT$
		doc.Categories_1 = EDRMSAWDSUBCAT$
		doc.origcloneref = doc.cloneref(0)

		logaction("Marking " & doc.subject(0) & " for deletion")
		Call edrms_mark_deletion_values(doc,docsdeleted,edrmscurrentuser.Abbreviated,MODE$)                 ' does the save
		logaction("Marking response thread of " & doc.subject(0) & " for deletion")
		Call edrms_recurse_responses(doc, MODE$,"",edrmscurrentuser.Abbreviated,"",Nothing, Nothing,responsedeleted,0)

		Set doc = edrmsdc.getnextdocument(doc)
	Wend

	Call ws.viewrefresh
	Call edrms_deselect_docs(ws)

	If docsdeleted = 0 Then
		msg = "No documents could be marked for deletion"
	ElseIf docsdeleted = 1 And responsedeleted = 0 Then
		msg = "One document was marked for deletion and will be deleted from the database within the next week."
	ElseIf docsdeleted = 1 And responsedeleted = 1 Then
		msg = "One document and one response were marked for deletion and will be deleted from the database within the next week."
	ElseIf docsdeleted > 1 And responsedeleted = 0 Then
		msg = CStr(docsdeleted) + " documents were marked for deletion and will be deleted from the database within the next week."
	ElseIf docsdeleted > 1 And responsedeleted = 1 Then
		msg = CStr(docsdeleted) + " documents and 1 response were marked for deletion and will be deleted from the database within the next week."
	Else
		msg = CStr(docsdeleted) + " document and " + CStr(responsedeleted) + " responses were marked for deletion and will be deleted from the database within the next week."
	End If
	MsgBox msg,64,edrmsdb.title &" " & EDRMSTERM$ & "Delete Action Complete"
	Call logclose("User informed " & msg)

Exit Sub
errhandle:
Call logerror(Err, Error, Erl, LSI_Info(2), LSI_Info(12), " Last module before this call " & edrmserrortext )   ' LOGS HELPFUL DETAIL ON AN ERROR
Call logaction(" Last Global Error " & edrmslastglobalerr)
Call alerterrors(agent.name ,"Error")     ' EMAILS THE ERROR ALERT TO ADDRESS IN PROFILE
Exit Sub
End Sub
Function edrms_deselect_docs(ws As NotesUIWorkspace) As Integer
	On Error GoTo globalerrhandle
	Dim UIView As NotesUIView
	
	Dim edrms_deselect_docs_errortext As String
	edrms_deselect_docs_errortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	edrms_deselect_docs = 0

	Set UIView = ws.Currentview
	If Not UIView Is Nothing Then
		Call UIView.DeselectAll
	End If
	
Exit Function
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_deselect_docs_errortext
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Function
End Function

Sub edrms_agent_alert_bdb_title_change(Agent As NotesAgent)
On Error GoTo errhandle
	Dim emaildoc As NotesDocument
	Dim rtitem As NotesRichTextItem
	edrmserrortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	If edrmsmasterservernn.common <> edrmsdbservernn.common Then
		Exit Sub     ' Only run on master server
	End If

	Call initlog(agent.name)

	If edrmsbdbtitle = "" Then
		GoSub updateprofile
	Else
		If edrmsbdbtitle <> edrmsdb.title Then
			logaction("Generating email to "  & EDRMSADMINSGROUP$ & " BDB Title Amended on " & edrmsbdbtitle)
			Set emaildoc = edrms_util_create_email("BDB Title Amended on " & edrmsbdbtitle,EDRMSADMINSGROUP$,Null,Null)
			Set rtitem = New NotesRichTextItem(emaildoc, "Body" )
			Call rtitem.appendtext("The title on this BDB has been amended to "  & edrmsdb.title)
			Call emaildoc.Send( False )
			GoSub updateprofile
		Else
			logaction("Nothing to do")
		End If
	End If

	Call logclose("Ends OK")

Exit Sub
updateprofile:
	edrmsprofiledoc.EDRMSBDBTitle = edrmsdb.title
	Call edrmsprofiledoc.save(True,True)
	logaction("Updated BDB title in profile document to " & edrmsdb.title)
Return

errhandle:
Call logerror(Err, Error, Erl, LSI_Info(2), LSI_Info(12), " Last module before this call " & edrmserrortext )   ' LOGS HELPFUL DETAIL ON AN ERROR
Call logaction(" Last Global Error " & edrmslastglobalerr)
Call alerterrors(agent.name ,"Error")     ' EMAILS THE ERROR ALERT TO ADDRESS IN PROFILE
Exit Sub
End Sub
Sub edrms_agent_display_edrms_fields(Agent As NotesAgent)
	On Error GoTo globalerrhandle
	Dim doc As NotesDocument
	Dim item As NotesItem
	Dim edrms_agent_disp_edrms_fields_errtext As String
	Dim fieldnamearr() As String
	Dim fieldvaluearr() As String
	Dim outputmess As String
	Dim v As Integer
	Dim w As Integer

	edrms_agent_disp_edrms_fields_errtext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	Set edrmsdc = edrmsdb.Unprocesseddocuments
	Set doc = edrmsdc.getfirstdocument

 	v = 0
  	ReDim fieldnamearr(v)
  	ReDim fieldvaluearr(v)

	Call edrms_util_quicksort(edrmsfields,"ASC")   ' Sort ascending

	For w = LBound(edrmssortedarray) To UBound(edrmssortedarray)
		Set item = doc.GetFirstItem(edrmssortedarray(w))
		If Not item Is Nothing Then
			ReDim Preserve fieldnamearr(v)
  			ReDim Preserve fieldvaluearr(v)
  			fieldnamearr(v) = item.name
  			fieldvaluearr(v) = item.Text
  			v = v + 1
		End If
	Next

	For w = LBound(fieldnamearr) To UBound(fieldnamearr)
		outputmess = outputmess & fieldnamearr(w) & ":" & Chr(9) & fieldvaluearr(w) & Chr(10)
	Next

	MessageBox outputmess,64,edrmsdb.title &" " & EDRMSTERM$ & " Values for " & doc.subject(0)

Exit Sub
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_agent_disp_edrms_fields_errtext
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Sub

End Sub
Sub edrms_agent_undec_recs_over_1_year_del(Agent As NotesAgent)
	On Error GoTo errhandle
	Const MODE$ = "REMOVE"
	Dim view As NotesView
	Dim dc As NotesDocumentCollection
	Dim doc As NotesDocument
'	Dim repdoc As NotesDocument
	Dim agentruntime As New NotesDateTime(Now)
	Dim selectstring As String
	Dim helperdbsret As Integer
'	Dim repdocpartno As integer
	Dim movedcount As Long

	If edrmssess.Isonserver Then
		If (edrmsdbservernn.common <> edrmsmasterservernn.common) Then
			Exit Sub   ' When run scheduled, not on master server so exit
		End If
	End If
	edrmserrortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	Call initlog(agent.name)

' Call the function that gets the required external DBS
	logaction("Getting DB handles to edrmsncddb, edrmsnabdb, edrmsmetadatadb, edrmsholdingdb, edrmscountsdb")
	helperdbsret = edrms_get_helper_dbs
	If helperdbsret > 0 Then
		logaction("Error getting one or more of the required external databases, check the Lookup.nsf and the default accesses to these DBs, error code = " & CStr(helperdbsret))
		logaction("Error codes: NCD = 99, NAB = 98, EDRMS Management DB = 97, EDRMS Holding DB = 96, EDRMS Counts DB = 95")
		Call alerterrors(agent.name ,"Error with external databases, error code " & CStr(helperdbsret))
		Exit Sub
	End If
	
'	Set repdoc = edrmsdb.createdocument
'	repdocpartno = 1
	movedcount = 0

' Added as a failsafe due to problems with restored docs still having the value 
	logaction("Resetting any stray documents from restores etc which may still have the delete flag set to 9") 
	selectstring = "SELECT (edrmsdeleteflag = ""9"") "
	logaction("Creating document collection with query " & selectstring )
	Set dc = edrmsdb.Search (selectstring,Nothing,0)
	logaction("Document collection contains " & CStr(dc.Count) )
	If dc.count > 0 Then
		logaction("Stamping the document collection to reset edrmsdeleteflag to null, these will be stray values from restores etc")
		Call dc.StampAll("edrmsdeleteflag","")
	End If
	
	logaction("Getting handle on view " & EDRMSVIEWOLDUNDECLARED$)
	Set view = edrmsdb.getview(EDRMSVIEWOLDUNDECLARED$)   	' EDRMSH5
	view.AutoUpdate = False
	Set doc = view.getfirstdocument

' Update documents prior to deletion

	While Not doc Is Nothing
		logaction("Marking " & doc.subject(0) & " and any responses for removal")
		Call edrms_mark_deletion_values(doc,movedcount,agent.name,MODE$)

		Call edrms_recurse_responses(doc,MODE$,"",agent.name,"",Nothing, Nothing, movedcount,0)

		Set doc=view.getnextdocument(doc)
	Wend

	selectstring = "SELECT (edrmsdeleteflag = ""9"") "
	logaction("Creating document collection with query " & selectstring )
	Set dc = edrmsdb.Search (selectstring,Nothing,0)
	logaction("Document collection contains " & CStr(dc.Count) )

	' Update documents prior to deletion
	Set doc = dc.getfirstdocument
	While Not doc Is Nothing
		logaction("Updating the deletion log on " & doc.form(0) & "    " & doc.subject(0) )
		Call edrms_update_log(doc,"deletelog","Deleted from " & edrmsdb.title,agent.name)
		Call doc.save(True,True)
		Set doc=dc.getnextdocument(doc)
	Wend

	logaction("Stamping the document collection with the required metadata")
	Call dc.StampAll("holdingdbtransferdate",agentruntime.dateonly)
	Call dc.stampall("sourcebdbtitle",edrmsdb.Title)
	Call dc.stampall("sourcebdbpath",edrmsdb.filepath)
	Call dc.stampall("softdeletedby",agent.name)
	Call dc.stampall("softdeleteddocsflag","1")
	Call dc.StampAll("softdeleteddate",agentruntime.lslocaltime)

	Set doc = dc.getfirstdocument
	logaction("Copying " & CStr(dc.count) & " documents to " & edrmsholdingdb.title)
	While Not doc Is Nothing
		Call doc.copytodatabase(edrmsholdingdb)
		Set doc=dc.getnextdocument(doc)
	Wend

	logaction("Removing all " & CStr(dc.count) & " documents from the document collection (and hence database)")
	Call dc.RemoveAll(True)
	Call logclose("Ends OK, moved and deleted " & CStr(movedcount) & " documents to " & edrmsholdingdb.title)

	view.AutoUpdate = True

Exit Sub
errhandle:
Call logerror(Err, Error, Erl, LSI_Info(2), LSI_Info(12), " Last module before this call " & edrmserrortext )   ' LOGS HELPFUL DETAIL ON AN ERROR
Call logaction(" Last Global Error " & edrmslastglobalerr)
Call alerterrors(agent.name ,"Error")     ' EMAILS THE ERROR ALERT TO ADDRESS IN PROFILE
Exit Sub
End Sub
Sub edrms_util_doqs( sA() As String, bottom As Long, top As Long )
     ' Called by edrms_util_QuickSort
     ' Uses Public variable sA  (array of string)
	On Error GoTo globalerrhandle
	Dim edrms_util_doqs_errortext As String
	Dim PivotValue As String
	Dim t As String
	Dim length As Long
	Dim i As Long
	Dim j As Long
	Dim Pivot As Long
	Dim LastSmall As Long

	edrms_util_doqs_errortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	length = top - bottom + 1

     ' Only do the edrms_util_QuickSort if the sublist is at least 10 items long
	If length > 10 Then
          ' Pivot is chosen approx. halfway through sublist.
          ' This gives us best speed if list is almost sorted already, and is no worse than any
          ' other choice if the list is in random order.
		Pivot = bottom + (length \ 2)

          ' Move PivotValue out of the way
		PivotValue = sA( Pivot )
		sA ( Pivot ) = sA ( bottom )
		sA ( bottom ) = PivotValue

          ' LastSmall is the location of the last value smaller than PivotValue
		LastSmall = bottom
		For i = bottom + 1 To top
			If sA ( i ) < PivotValue Then
				LastSmall = LastSmall + 1
				t = sA ( i )
				sA ( i ) = sA ( LastSmall )
				sA ( LastSmall ) = t
			End If
		Next

          ' Move the PivotValue back
		t = sA ( LastSmall )
		sA ( LastSmall ) = sA ( bottom )
		sA ( bottom ) = t
		Pivot = LastSmall

          ' Now sort each side
		Call edrms_util_DoQS ( sA, bottom, Pivot - 1 )
		Call edrms_util_DoQS ( sA, Pivot + 1, top )
	End If

	Exit Sub
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_util_doqs_errortext
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Sub
End Sub

Sub edrms_reset_initial_declaration(doc As NotesDocument,uidoc As NotesUIDocument)
	On Error GoTo globalerrhandle
	Dim ws As New notesuiworkspace
	Dim edrms_reset_initial_declaration_errtext As String
	Dim continue As Variant
	
	edrms_reset_initial_declaration_errtext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	
	doc.edrmsinitialdeclaration = ""
	Call edrms_set_initial_declaration(uidoc,continue)
	uidoc.Close
	Call ws.Viewrefresh
	Exit Sub
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_reset_initial_declaration_errtext
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Sub
End Sub
Function edrms_get_thread_access(doc As NotesDocument) As String
On Error GoTo globalerrhandle
Const RRMODE$ = "CHECKACC"
Dim edrms_get_thread_access_errtext As String
Dim threadeditor As String

	edrms_get_thread_access_errtext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	threadeditor = "No"
	Call edrms_get_doc_access(doc,threadeditor)
	If threadeditor = "Yes" Then                 ' Has editor access to main doc
		Call edrms_recurse_responses(doc,RRMODE$,"","","",Nothing,Nothing,0,0)
		threadeditor = edrmsdoceditor              ' (Global) Found one or mode responses user is not an editor of
	End If

	edrms_get_thread_access = threadeditor

Exit Function
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_get_thread_access_errtext
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
Exit Function
End Function
Sub edrms_agent_review_reverse_recs_not_reqd(Agent As NotesAgent)
	On Error GoTo errhandle
	Const MODE$ = "MARKREVIEW"
	Const RRMODE$ = "CHECKACC"
	Const REVIEWSTATUS$ = "Reverse"
	Dim ws As New NotesUIWorkspace
	Dim dcprocessed As NotesDocumentCollection
	Dim doc As NotesDocument
	Dim emaildoc As NotesDocument
	Dim rtitem As NotesRichTextItem
	Dim storedreviewernn As NotesName
	Dim currentreviewernn As NotesName
	Dim requestedby As String
	Dim msg As String
	Dim editoraccess As String
	Dim responseflag As Integer
	Dim editorlevel As Integer
	Dim emailflag As Integer
	Dim reviewed As Long
	Dim responsereviewed As Long
	Dim replyval As Variant

	reviewed = 0
	responsereviewed = 0
	responseflag = 0
	editorlevel = 0
	emailflag = 0

	edrmserrortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	Call initlog(agent.name)
	Set edrmsdc = edrmsdb.unprocesseddocuments
	Set doc = edrmsdc.getfirstdocument
	Set storedreviewernn = New NotesName (doc.edrmsreviewedby(0))
	Set dcprocessed = edrmsdb.GetProfileDocCollection( "NOSUCHTHING" ) ' Initialise the dcprocessed collection as empty - code from IBM Site - the issue was that uninitialised it cannot be copied to

	Call edrms_check_responses_records(edrmsdc, responseflag, 0,editorlevel,0)
	If responseflag = 1 Then
		MessageBox "Please restrict your selection to top level documents only. Any response documents present "+_
		"will get picked up automatically if a parent document is selected.",16,edrmsdb.title &" " & EDRMSTERM$ &" Selection Contains Response Documents"
		logclose("User has been informed that they have included responses/resp to resp/alerts and exited.")
		Exit Sub
	End If

	Set doc = edrmsdc.getfirstdocument
	While Not doc Is Nothing
		Set currentreviewernn = New NotesName (doc.edrmsreviewedby(0))
		If storedreviewernn.common <> currentreviewernn.common Then
			MessageBox "Please restrict your selection to records reviewed by the same person.",16,edrmsdb.title &" " & EDRMSTERM$ & " Selection Contains Mixed Person Documents"
			logclose("User has been informed that they have included documents reviewed by different people and exited.")
			Exit Sub
		End If
		Set doc= edrmsdc.GetNextDocument(doc)
	Wend

	If edrmsdc.count = 1 Then
		msg = "This action will undelete the selected record and return it back to the main database views. Continue?"
	Else
		msg = "This action will undelete the " + CStr(edrmsdc.count) + " selected records and return them back to the main database views. Continue?"
	End If
	logaction("User prompted with : " & msg)

	replyval = MessageBox(msg,36,edrmsdb.title &" " & EDRMSTERM$ & " Confirmation Required")
	If replyval = 7 Then
		MessageBox "Action aborted",64,edrmsdb.title &" " & EDRMSTERM$ & " Exiting"
		logclose("User has aborted and exited.")
		Exit Sub
	End If

	Set doc = edrmsdc.getfirstdocument

	While Not doc Is Nothing
		requestedby = doc.edrmsreviewedby(0)
		If editorlevel > 0 Then                                ' Not an editor to everything in scope of the dc, including responses so have to check everything
			editoraccess = ""
			Call edrms_get_doc_access(doc,editoraccess)
			If editoraccess = "Yes" Then                 ' Has editor access to main doc
				edrmsdoceditor = editoraccess
				Call edrms_recurse_responses(doc, RRMODE$,"","","",Nothing,Nothing,0,0)
				If edrmsdoceditor = "No"  Then       ' Found one or mode responses user is not an editor of
					editoraccess = edrmsdoceditor
				End If
			End If
		End If

		If editoraccess = "Yes" Or editorlevel = 0 Then
			If doc.hasitem("version") Then
				If doc.version(0) > 0 Then
					MessageBox "This record is part of a Version chain and as such, can't be moved back automatically. " +_
					"Please raise a call on " & HELPDESK$ & " to get the record restored manually.",64,doc.subject(0)
					logaction("User informed that the current document " & doc.subject(0) & " is under versioning, skipping to the next doc")
					GoTo nextrec
				End If
			End If

			Call edrms_mark_review_status(doc,REVIEWSTATUS$,reviewed,edrmscurrentuser.abbreviated,"","")
			logaction("Main doc has deletion markings removed " &  doc.subject(0))
			Call dcprocessed.Adddocument(doc)     ' Add to collection of docs that processed OK to email user about later

			logaction("Recursing response thread")
			Call edrms_recurse_responses(doc,MODE$,REVIEWSTATUS$,edrmscurrentuser.abbreviated,"",Nothing,Nothing,responsereviewed,0)

		Else
			MessageBox "You don't have sufficient access to be able to undelete the record and all responses " + doc.subject(0),16,edrmsdb.title &" " & EDRMSTERM$ & " Skipping"
			logaction("User informed they don't have editor access to current doc " & doc.subject(0) & " plus all responses, skipping to next")
		End If

nextrec:
		Set doc=edrmsdc.GetNextDocument(doc)
	Wend

	If reviewed = 0 Then
		msg = "Action complete. No records were undeleted"
	ElseIf reviewed = 1 Then
		If responsereviewed = 0 Then
			msg = "One record was undeleted. An email with a link to the record has been sent to " + storedreviewernn.common + 	"."
		Else
			If responsereviewed = 1 Then
				msg = "One record and one response were undeleted. An email with a link to the record has been sent to " + storedreviewernn.common + "."
			Else
				msg = "One record and " + CStr(responsereviewed) + " responses were undeleted. An email with a link to the record has been sent to " + storedreviewernn.common + "."
			End If
		End If
	Else
		If responsereviewed = 0 Then
			msg = CStr(reviewed) + " records were undeleted. An email with a link to the records has been sent to " + storedreviewernn.common + "."
		Else
			If responsereviewed = 1 Then
				msg = CStr(reviewed) + " records and one response were undeleted. An email with a link to the records has been sent to " + storedreviewernn.common + "."
			Else
				msg = CStr(reviewed) + " records and " + CStr(responsereviewed) + " responses were undeleted. An email with a link to the records has been sent to " + storedreviewernn.common + "."
			End If
		End If
	End If

' Email the result to the original reviewer
	logaction("Generating email to " & storedreviewernn.abbreviated)
	Set emaildoc = edrms_util_create_email("Record(s) undeleted on BDB " & edrmsdb.title,storedreviewernn.abbreviated,Null,Null)
	Set rtitem = New NotesRichTextItem(emaildoc, "Body" )
	Call rtitem.appendtext("The following " + CStr(reviewed) + " record(s) that had been marked as no longer required have been returned to you for review.")
	Call rtitem.addnewline(2)
	Set doc=dcprocessed.GetFirstDocument     ' Only list the docs that processed OK
	While Not doc Is Nothing
		Call rtitem.appendtext("    " + doc.subject(0) + " ===> ")
		Call rtitem.AppendDocLink(doc,edrmsdb.Title)
		Call rtitem.addnewline(1)
		emailflag = emailflag + 1
		Set doc=dcprocessed.GetNextDocument(doc)
	Wend

	If emailflag > 0 Then
		Call emaildoc.Send(False)
		Call logaction("Sending email to " & storedreviewernn.abbreviated & " with a list of " & CStr(emailflag) & " main documents")
	Else
		Call logaction("No email sent as nothing was done")
	End If

	MessageBox msg,64,edrmsdb.title &" " & EDRMSTERM$ & " Action Complete"
	
	Call edrms_deselect_docs(ws)
	Call ws.viewrefresh
	Call logclose("User notified " & msg)

Exit Sub
errhandle:
Call logerror(Err, Error, Erl, LSI_Info(2), LSI_Info(12), " Last module before this call " & edrmserrortext )   ' LOGS HELPFUL DETAIL ON AN ERROR
Call logaction(" Last Global Error " & edrmslastglobalerr)
Call alerterrors(agent.name ,"Error")     ' EMAILS THE ERROR ALERT TO ADDRESS IN PROFILE
Exit Sub
End Sub
Function edrms_choose_record_category As Variant
	On Error GoTo globalerrhandle
	Dim ws As New NotesUIWorkspace
	Dim edrms_choose_record_category_errortext As String
	edrms_choose_record_category_errortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	edrms_choose_record_category = ws.Prompt( PROMPT_OKCANCELLIST, edrmsdb.title &" " & EDRMSTERM$ & " Declaration", "Choose the appropriate " &  "  " & EDRMSTERM$ &  " Category",EDRMSCategories(0), EDRMSCategories )
Exit Function
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_choose_record_category_errortext
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Function
End Function
Sub edrms_agent_rebuild_views(Agent As NotesAgent)
	' The point of this is to consolidate all the EDRMS code in this script library so that one search and
	' replace on this script library is sufficient in principle to change code for anything that is a simple 
	' substitution.
	On Error GoTo errhandle
	Const VIEWMAX% = 21    ' Change this and add a new +1 element to the end of the array "views"
	Const VIEWDUMMY$ = "(EDRMSDUMMY)"
	Dim view As NotesView
	Dim dummyview As NotesView
	Dim viewsigndoc As NotesDocument
	Dim remline(1) As String
	Dim formselect() As String
	Dim query() As String
	Dim datepart() As String
	Dim excludedformselect() As String
	Dim views(VIEWMAX%) As String
	Dim formula As String
	Dim oneyearagovariable As String
	Dim twoyearsagovariable As String
	Dim doccreatedvariable As String
	Dim doclastmodvariable As String
	Dim oneyearminus6weeksvariable As String		'added Rob
	Dim twoyearsminus6weeksvariable As String
	'Dim twoyearsplus9daysvariable As String		'removed  Rob
	Dim september2006variable As String
	Dim reviewdateyearvariable As String
	Dim reacheddeclarelimit As String
	Dim notreacheddeclarelimit As String
	Dim isdeclaredrecord As String
	Dim notdeclaredrecord As String
	Dim deleteflagnotset As String
	Dim deleteflagset As String
	Dim notawaitingdeletion As String
	Dim notreadyfortransfer As String
	Dim isreadyfortransfer As String
	Dim notresponsedoc As String
	Dim isresponsedoc As String
	Dim reviewdatemet As String
	Dim selectlogfiles As String
	Dim selectmaindocs As String
	Dim autodeclare As String
	Dim notautodeclare As String
	Dim autodelete As String 
	Dim i As Integer
	Dim viewindex As Integer

	edrmserrortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	If (edrmsdbservernn.common <> edrmsmasterservernn.common) Then
		Exit Sub   ' Not on master server so exit
	End If

	Call initlog(agent.name)

	Set dummyview = edrmsdb.CreateView(VIEWDUMMY$,"SELECT 1 = 0" )             ' Want a meaningless view with no overhead, remove at end DJS
	logaction("Created "  & dummyview.name)
	
' THE COMMENTING OUT IS DUE TO THE FACT THAT REBUILT VIEWS CANNOT BE ACCESSED BY NORMAL USERS DUE TO ECL ISSUES WITH NO SiGNATURE
' RENUMBERING EVERYTHING WAS A LOT OF FIDDLING AND IF IN FUTURE THE ECL ISSUES ARE CHANGED THEN THEY CAN BE REINSTATED	

'	views(0) =  EDRMSVIEWDECLARETODAY$          ' EDRMSVIEWDECLARETODAY$ = "EDRMS2"         EDRMS\Declare Today
'	views(1) =  EDRMSVIEWREBUILD1$                     ' EDRMSVIEWREBUILD1$ = "EDRMS3"             EDRMS\Undeclared Docs By Owner
'	views(2) =  EDRMSVIEWREBUILD2$                     ' EDRMSVIEWREBUILD2$ = "EDRMS4"             EDRMS\Declared Records For Review Current Year By BDB Categories
'	views(3) =  EDRMSVIEWREBUILD3$                     ' EDRMSVIEWREBUILD3$ = "EDRMS5"             EDRMS\Declared Records For Review Current Year By EDRMS Categori
'	views(4) =  EDRMSVIEWREBUILD4$                     ' EDRMSVIEWREBUILD4$ = "EDRMS6"             EDRMS\Undeclared Records To Be Advised
'	views(5) =  EDRMSVIEWREBUILD5$                     ' EDRMSVIEWREBUILD5$ = "EDRMS7"             EDRMS\Undeclared Records To Be Deleted
	views(0) = VIEWDUMMY$
	views(1) = VIEWDUMMY$
	views(2) = VIEWDUMMY$
	views(3) = VIEWDUMMY$
	views(4) = VIEWDUMMY$
	views(5) = VIEWDUMMY$
	views(6) =  EDRMSVIEWLOGDELETE$                 ' EDRMSVIEWLOGDELETE$ = "EDRMSH1"           (EDRMS Advice Logs for Deletion)
	views(7) =  EDRMSVIEWLOGS$                              ' EDRMSVIEWLOGS$ = "EDRMSH2"                (EDRMS All Advice Logs)
	views(8) =  EDRMSVIEWREVIEWEDREMAIN$      ' EDRMSVIEWREVIEWEDREMAIN$ = "EDRMSH3"      (EDRMS Reviewed Records Remaining)
	views(9) =  EDRMSVIEWFORREVIEW$                  ' EDRMSVIEWFORREVIEW$ = "EDRMSH4"           (EDRMS Records For Review)
	views(10) = EDRMSVIEWOLDUNDECLARED$    ' EDRMSVIEWOLDUNDECLARED$ = "EDRMSH5"       (EDRMS Undeclared Documents More Than 1 Year Old 1)
'	views(11) = EDRMSVIEWTRANSFER$                    ' EDRMSVIEWTRANSFER$ = "EDRMS8"             EDRMS\Undeclared Records Ready for Transfer
'	views(12) = EDRMSVIEWDELETED$                      ' EDRMSVIEWDELETED$ = "EDRMS9"              EDRMS\Undeclared Records Deleted Documents (Top Level)
'	views(13) = EDRMSVIEWDEFAULT$                       ' EDRMSVIEWDEFAULT$ = "EDRMS1"              EDRMS\1. Everything
'	views(14) = EDRMSVIEWRECSNOTREQD$          ' EDRMSVIEWRECSNOTREQD$ = "EDRMS10"         EDRMS\2. Declared Records Not Required
'	views(15) = EDRMSVIEWREASSIGNED$               ' EDRMSVIEWREASSIGNED$ = "EDRMS11"          EDRMS\1. Reassigned Documents
	views(11) = VIEWDUMMY$
	views(12) = VIEWDUMMY$
	views(13) = VIEWDUMMY$
	views(14) = VIEWDUMMY$
	views(15) = VIEWDUMMY$
	views(16) = EDRMSVIEWTOPLEVELRECS$          ' EDRMSVIEWTOPLEVELRECS$ = "EDRMSH6"        (EDRMS Records Top Level Only)
	views(17) = EDRMSVIEWALLDOCSINSCOPE$     ' EDRMSVIEWALLDOCSINSCOPE$ = "EDRMSH7"      (EDRMS Docs In Scope No Hierarchy)
	views(18) = EDRMSVIEWALLUNDECLARED$      ' EDRMSVIEWALLUNDECLARED$ = "EDRMSH8"       (EDRMS All Undeclared Documents)
	views(19) = EDRMSVIEWALLDECLARED$            ' EDRMSVIEWALLDECLARED$ = "EDRMSH9"         (EDRMS All Declared Documents)
	views(20) = EDRMSVIEWAUTODECLARE$           ' EDRMSVIEWAUTODECLARE$  = "EDRMSH10"      (EDRMS Undeclared Documents Older Than Cutoff Auto Declare)
	views(21) = EDRMSVIEWAUTODELETE$              ' EDRMSVIEWAUTODELETE$ = "EDRMSH11"           (EDRMS Undeclared Documents Older Than Cutoff Auto Delete)

'###################################################################################################################################
' DECLARATION OF SHARED EVALUATIONS, SELECTS ETC

	' The retention period should be one year from the last modified date or two years from the date of creation, whichever is soonest
	' These variables are set up once here to reuse, the extra seven days are to be kind to people over holidays etc 
	' @Adjust( dateToAdjust ; years ; months ; days ; hours ; minutes ; seconds )
	' The @TextToTime(""Today"") code is to get around the views having blue refresh arrows continually if a normal @Now or @Today is used
'	oneyearagovariable =  "oneyearago:= @Adjust(@TextToTime(""Today"");" & EDRMSMODIFIEDYEAR% & ";0;" & EDRMS7DAYS% & ";0;0;0);"
	oneyearagovariable =  "oneyearago:= @Adjust(@TextToTime(""Today"");" & EDRMSMODIFIEDYEAR% & ";0;0;0;0;0);"											'changed 01/07/2015 Rob
	'twoyearsagovariable = "twoyearsago:= @Adjust(@TextToTime(""Today"");" & EDRMSCREATEDYEAR% & ";0;" & EDRMS7DAYS% & ";0;0;0);"
	twoyearsagovariable = "twoyearsago:= @Adjust(@TextToTime(""Today"");" & EDRMSCREATEDYEAR% & ";0;0;0;0;0);"											'changed 01/07/2015 Rob
	oneyearminus6weeksvariable = "oneyearminus6weeksago:= @Adjust(@TextToTime(""Today"");" & EDRMSMODIFIEDYEAR% & ";0;" & EDRMS6WEEKS% & ";0;0;0);"		'added- Rob
	twoyearsminus6weeksvariable = "twoyearsminus6weeksago:= @Adjust(@TextToTime(""Today"");" & EDRMSCREATEDYEAR% & ";0;" & EDRMS6WEEKS% & ";0;0;0);"
'	twoyearsplus9daysvariable = "twoyearsplus9daysago:= @Adjust(@TextToTime(""Today"");" & EDRMSCREATEDYEAR% & ";0;" & EDRMS9DAYS% & ";0;0;0);"			'removed Rob
	september2006variable = "september2006:= @TextToTime(""01/09/2006"");"          ' This was a significant system change in the past
	reviewdateyearvariable = "reviewdateyear := @Year(@Adjust(@TextToTime(""Today"");" & EDRMSMODIFIEDYEAR% & ";0;0;0;0;0));"  

	doccreatedvariable = "doccreated:= @If(@IsAvailable(VersionCreateDate);@Date(VersionCreateDate);@Date(@Created));"
	doclastmodvariable = "doclastmod:= @If(@IsAvailable(edrmslastmod);@Date(edrmslastmod);@Date(@Created));"
	reacheddeclarelimit	= "& (doccreated < twoyearsago | (doccreated > twoyearsago & doclastmod < oneyearago))"
	notreacheddeclarelimit = "& doccreated > twoyearsago & doclastmod > oneyearago"
	reviewdatemet = "@Year(edrmsreviewdate) <= reviewdateyear"             ' DELIBERATELY HAS NO AMPERSAND
	
	isdeclaredrecord = "& edrmsrecord =""Yes"""
	notdeclaredrecord = "& edrmsrecord !=""Yes"""
	deleteflagnotset = "& edrmsdeleteflag != ""1"""
	deleteflagset = "& edrmsdeleteflag = ""1"""
	notawaitingdeletion = "& Categories != """ & EDRMSAWDCAT$ & """"
	notreadyfortransfer = "& edrmsreviewstatus != """ & EDRMSTRANSFERSTATUS$ &""""
	isreadyfortransfer = "& edrmsreviewstatus = """ & EDRMSTRANSFERSTATUS$ & """"
	notresponsedoc = "!@IsResponseDoc"                                                           ' DELIBERATELY HAS NO AMPERSAND
	isresponsedoc =   "@IsResponseDoc"                                                           ' DELIBERATELY HAS NO AMPERSAND
	autodeclare = "& edrmsinitialdeclaration = """ & edrmsinitialdeclaration(0) & """"                  '	edrmsinitialdeclaration(0) = "Automatically Declare"
	notautodeclare = "& edrmsinitialdeclaration != """ & edrmsinitialdeclaration(0) & """"           '	edrmsinitialdeclaration(0) = "Automatically Declare"      V007 DJS 23/10/2017
	autodelete = "& edrmsinitialdeclaration = """ & edrmsinitialdeclaration(1) & """"                    '	edrmsinitialdeclaration(1) = "Automatically Delete"
	
	selectmaindocs = "SELECT Form = ""Document"":""ONSLetter"":""Blanksheet"":""AttachDoc"":""LinkDoc"":""URLLinkDoc"""
	selectlogfiles = "SELECT Form =  ""DelAdviceEDRMS"":""DelAdviceERMS"":""" & EDRMSDELETIONADVICELOGFORM$ & """:""DelAdviceLegacy"":""" & EDRMSDELETIONLOGFORM$ & """:""DelLogLegacy"""

	redim excludedformselect(2)
	excludedformselect(0) = "SELECT !Form = ""Valid Category"":""Valid Sub-Category"":""Keyword"":""calendarlink"":""dblink"":""helpdoc"":""logdoc"":"
	excludedformselect(1) = """Archive Profile"":""template"":""ServerRedirectionLog"":""" & EDRMSDELETIONLOGFORM$ & """:""" & EDRMSDELETIONADVICELOGFORM$ & """:""SplashText"":""DelAdviceLegacy"":"
	excludedformselect(2) = """DelLogLegacy"":""AuditRecUpdate"":""AuditRec"":""ERMS Retention Period"":""DelAdviceERMS"":""aclprofile"""	
	
	' THIS ELEMENT IS COMMON TO ALL SELECTS SO ONLY DEFINE ONCE
	remline(0) = "REM {DO NOT EDIT THIS SELECTION FORMULA DIRECTLY. IT IS RESET EVERY DAY VIA SCHEDULED AGENT};"
	remline(1) = "REM {Agent  " & agent.name & " last ran " & CStr(Now) & "};"

	' ONLY CHANGE THIS WHEN APPLICABLE   
	ReDim formselect(2)
	formselect(0) = excludedformselect(0)
	formselect(1) = excludedformselect(1)
	formselect(2) = excludedformselect(2)
		
	
'###################################################################################################################################	
' VIEW REBUILDS

' VIEW 0
' Recalculates the selection formula on the view aliased in the constant  EDRMSVIEWDECLARETODAY$ = "EDRMS2"         EDRMS\Declare Today
' This selects the documents which have the initial declaration of the same day
	ReDim query(0)
	query(0) = "SELECT edrmsinitialdeclaration = """ & edrmsinitialdeclaration(3) & """  | " & isresponsedoc
 	formula = remline(0) & Chr(10) & remline(1) & Chr(10) & Chr(10) & query(0)
	viewindex = 0
	GoSub applyformula

' VIEW 1
' Recalculates the selection formula on the view aliased in the constant EDRMSVIEWREBUILD1$ = "EDRMS3"             EDRMS\Undeclared Docs By Owner
' This view displays undeclared documents that have not yet reached the time for declaration
	ReDim datepart(3)
	ReDim query(3)
	datepart(0) = oneyearagovariable
	datepart(1) = twoyearsagovariable
	datepart(2) = doccreatedvariable
	datepart(3) = doclastmodvariable
	query(0) = notdeclaredrecord
	query(1) = notreacheddeclarelimit
	query(2) = deleteflagnotset
	query(3) = "& @If(!@IsResponseDoc;Categories!=""Awaiting Deletion"";@Success)"
	formula =  remline(0) & Chr(10) & remline(1) & Chr(10) & Chr(10) & _
	datepart(0) & Chr(10) & datepart(1) & Chr(10) & datepart(2) & Chr(10) & datepart(3) & Chr(10) & Chr(10) &_
	formselect(0) & formselect(1) & formselect(2) & Chr(10) & query(0) & Chr(10) & query(1) & Chr(10) & query(2) & Chr(10) & query(3)
	GoSub applyformula
	
' VIEW 2
' Recalculates the selection formula on the view aliased in the constant EDRMSVIEWREBUILD2$ = "EDRMS4"             EDRMS\Declared Records For Review Current Year By BDB Categories$ 
'This view displays declared records where the year of their review has passed
	ReDim datepart(0)
	ReDim query(4)
	datepart(0) = reviewdateyearvariable
	query(0) = deleteflagnotset
	query(1) = notawaitingdeletion
	query(2) = notreadyfortransfer
	query(3) = isdeclaredrecord
	query(4) = "& @If(!@IsResponseDoc;" & reviewdatemet & ";@Success)"
	formula = remline(0) & Chr(10) & remline(1) & Chr(10) & Chr(10) & datepart(0) & Chr(10) & Chr(10) & _
	formselect(0) & formselect(1) & formselect(2) & Chr(10) & query(0) & Chr(10) & query(1) & Chr(10) & query(2) & Chr(10) & query(3) & Chr(10) & query(4)
	GoSub applyformula

' VIEW 3
' Recalculates the selection formula on the view aliased in the constant EDRMSVIEWREBUILD3$ = "EDRMS5"             EDRMS\Declared Records For Review Current Year By EDRMS Categories
' The formula is the same as the one immediately above
	GoSub applyformula
	
' VIEW 4
' Recalculates the selection formula on the view aliased in the constant EDRMSVIEWREBUILD4$ = "EDRMS6"             EDRMS\Undeclared Records To Be Advised
' This view contains undeclared documents 6 weeks or less from the deadline to declare
%REM
doccreated:= @If(@IsAvailable(VersionCreateDate);@Date(VersionCreateDate);@Date(@Created));
twoyearsminus6weeksago:= @Adjust(@Today;-2;0;42;0;0;0);
september2006:= @TextToTime("01/09/2006");

	Select !Form = "Valid Category":"Valid Sub-Category":"Keyword":"calendarlink":"dblink":"helpdoc":"logdoc":"Archive Profile":"template":"ServerRedirectionLog":"DelLog":"DelAdvice":"SplashText":"DelAdviceLegacy":"DelLogLegacy":"AuditRecUpdate":"AuditRec":"ERMS Retention Period":"DelAdviceERMS":"aclprofile"
			& edrmsrecord !="Yes"
			& doccreated < twoyearsminus6weeksago
			& doccreated >= september2006
			& !@IsResponseDoc
			& Categories !="Awaiting Deletion"
	%END REM			
	ReDim datepart(4)
	ReDim query(4)
	'datepart(0) = oneyearagovariable
	datepart(0) = oneyearminus6weeksvariable		'changed 30/06/2015 Rob
	datepart(1) = doccreatedvariable 
	datepart(2) =  twoyearsminus6weeksvariable
	datepart(3) = september2006variable 
	datepart(4) = doclastmodvariable
	query(0) =  notdeclaredrecord
	'query(1) = "& (doccreated < twoyearsminus6weeksago | doclastmod < oneyearago)" ' Belatedly realised the modified issue
	query(1) = "& (doccreated < twoyearsminus6weeksago | doclastmod < oneyearminus6weeksago)" ' Belatedly realised the modified issue	changed 30/06/2015 Rob
	query(2) = "& doccreated >= september2006"
	query(3) = "& " & notresponsedoc                           ' AMPERSAND INTENTIONAL
	query(4) = notawaitingdeletion
	formula = remline(0) & Chr(10) & remline(1) & Chr(10) & Chr(10) &_
	datepart(0) & Chr(10) & datepart(1) & Chr(10) & datepart(2) & Chr(10) & datepart(3) & Chr(10) & datepart(4) & Chr(10) & Chr(10) &_
	formselect(0) & formselect(1) & formselect(2) & Chr(10) & query(0) & Chr(10) & query(1) &_
	Chr(10) & query(2) & Chr(10) & query(3) & Chr(10) & query(4)' & Chr(10) & query(5)
	GoSub applyformula

' VIEW 5
' Recalculates the selection formula on the view aliased in the constant EDRMSVIEWREBUILD5$ = "EDRMS7"             EDRMS\Undeclared Records To Be Deleted
' This view contains undeclared documents that should be deleted as they are past the deadline to declare
	ReDim datepart(4)
	ReDim query(4)
	datepart(0) = oneyearagovariable
	datepart(1) = doccreatedvariable 
	'datepart(2) = twoyearsplus9daysvariable
	datepart(2) = twoyearsagovariable							'Change 01/07/2015 Rob
	datepart(3) = september2006variable
	datepart(4) = doclastmodvariable
	query(0) = notdeclaredrecord
'	query(1) = "& (doccreated < twoyearsplus9daysago | doclastmod < oneyearago)" ' Belatedly realised the modified issue
	query(1) = "& (doccreated < twoyearsago | doclastmod < oneyearago)" ' Belatedly realised the modified issue				'changed 01/07/2015 Rob
	query(2) = "& doccreated >= september2006"
	query(3) = "& " & notresponsedoc                           ' AMPERSAND INTENTIONAL
	query(4) = deleteflagnotset
	formula = remline(0) & Chr(10) & remline(1) & Chr(10) & Chr(10) &_
	datepart(0) & Chr(10) & datepart(1) & Chr(10) & datepart(2) & Chr(10) & datepart(3) & Chr(10) & datepart(4) & Chr(10) & Chr(10) &_
	formselect(0) & formselect(1) & formselect(2) & Chr(10) & query(0) & Chr(10) & query(1) & Chr(10) & query(2) & Chr(10) & query(3) & Chr(10) & query(4)
	GoSub applyformula
	
' VIEW 6
' Recalculates the selection formula on the view aliased in the constant EDRMSVIEWLOGDELETE$ = "EDRMSH1"          (EDRMS Advice Logs for Deletion)
' This view selects logs older than the number of years in the constant EDRMSCREATEDYEAR%
	ReDim datepart(0)
	ReDim formselect(0)
	ReDim query(0)
	datepart(0) = twoyearsagovariable
	formselect(0) = selectlogfiles
	query(0) = "& @Date(LogDate) < twoyearsago"
	formula = remline(0) & Chr(10) & remline(1) & Chr(10) & Chr(10) & datepart(0) & Chr(10) &  formselect(0)  & Chr(10) & query(0)
	GoSub applyformula

' VIEW 7
' Recalculates the selection formula on the view aliased in the constant  EDRMSVIEWLOGS$ = "EDRMSH2"               (EDRMS All Advice Logs)
	ReDim formselect(0)
	formselect(0) = selectlogfiles
	formula = remline(0) & Chr(10) & remline(1) & Chr(10) & Chr(10) & formselect(0)
	GoSub applyformula

' VIEW 8
' Recalculates the selection formula on the view aliased in the constant EDRMSVIEWREVIEWEDREMAIN$ = "EDRMSH3"  (EDRMS Reviewed Records Remaining)
%REM
reviewdateyear := @Year(@Adjust(@TextToTime("Today");-1;0;0;0;0;0));
SELECT edrmsdeleteflag != "1"
& Categories != "Awaiting Deletion"
& edrmsrecord ="Yes"
& edrmsreviewstatus != "Ready for Transfer"
& @Year(edrmsreviewdate) <= reviewdateyear
%END REM	
	ReDim datepart(0)
	ReDim query(4)
	datepart(0) = reviewdateyearvariable
	query(0) = "SELECT edrmsdeleteflag != ""1"""
	query(1) = notawaitingdeletion
	query(2) = isdeclaredrecord
	query(3) = notreadyfortransfer
	query(4) = "& " & reviewdatemet
	formula = remline(0) & Chr(10) & remline(1) & Chr(10) & Chr(10) & datepart(0) & Chr(10) & Chr(10) & _
	query(0) & Chr(10) & query(1) & Chr(10) & query(2) & Chr(10) & query(3) & Chr(10) & query(4)
	GoSub applyformula
	
' VIEW 9
' Recalculates the selection formula on the view aliased in the constant EDRMSVIEWFORREVIEW$ = "EDRMSH4" (EDRMS Records For Review)
%REM	
reviewdateyear := @Year(@Adjust(@TextToTime("Today");-1;0;0;0;0;0));
SELECT !@IsResponseDoc
& edrmsdeleteflag != "1"
& Categories != "Awaiting Deletion"
& edrmsrecord ="Yes"
& edrmsreviewstatus != "Ready for Transfer"
& @Year(edrmsreviewdate) <= reviewdateyear
%END REM
   ReDim formselect(0)
	ReDim datepart(0)
	ReDim query(4)
	datepart(0) = reviewdateyearvariable
	formselect(0) = "SELECT " & notresponsedoc
	query(0) = deleteflagnotset
	query(1) = notawaitingdeletion
	query(2) = isdeclaredrecord
	query(3) = notreadyfortransfer
	query(4) = 	"& " & reviewdatemet
    formula = remline(0) & Chr(10) & remline(1) & Chr(10) & Chr(10) & datepart(0) & Chr(10) & Chr(10) & _
	formselect(0) & Chr(10) & query(0) & Chr(10) & query(1) & Chr(10) & query(2) & Chr(10) & query(3) & Chr(10) & query(4) 
	GoSub applyformula

' VIEW 10
' Recalculates the selection formula on the view aliased in the constant  	EDRMSVIEWOLDUNDECLARED$ = "EDRMSH5"      (EDRMS Undeclared Documents More Than 1 Year Old 1)
' This view selects undeclared documents past the cutoff dates
%REM
REM {The retention period should be one year from the last modified date or two years from the date of creation, whichever is soonest};
oneyearago:= @Adjust(@Today;-1;0;-7;0;0;0);
twoyearsago:= @Adjust(@Today;-2;0;-7;0;0;0);
doccreated:= @If(@IsAvailable(VersionCreateDate);@Date(VersionCreateDate);@Date(@Created));
doclastmod:= @If(@IsAvailable(edrmslastmod);@Date(edrmslastmod);@Date(@Created));
SELECT Form = "Document":"ONSLetter":"Blanksheet" & edrmsrecord!="Yes"
& (doccreated < twoyearsago | (doccreated > twoyearsago & doclastmod < oneyearago))
& edrmsinitialdeclaration != "Automatically Declare"           ' V007 DJS 23/10/2017 Close loophole where automatically declare could fall in scope
%END REM
	ReDim formselect(0)
	ReDim datepart(3)
	ReDim query(2)
	datepart(0) = oneyearagovariable
	datepart(1) = twoyearsagovariable
	datepart(2) = doccreatedvariable
	datepart(3) = doclastmodvariable
	formselect(0) = selectmaindocs
	query(0) = notdeclaredrecord
	query(1) = reacheddeclarelimit
	query(2) = notautodeclare                 ' V007 DJS 23/10/2017
	formula = remline(0) & Chr(10) & remline(1) & Chr(10) & Chr(10) &_
	datepart(0) & Chr(10) & datepart(1) & Chr(10) & datepart(2) & Chr(10) & datepart(3) & Chr(10) & Chr(10) &_
	formselect(0) & Chr(10) & query(0) & Chr(10) & query(1)  & Chr(10) & query(2)
	GoSub applyformula
	
' VIEW 11
' Recalculates the selection formula on the view aliased in the constant  	EDRMSVIEWTRANSFER$ = "EDRMS8"             EDRMS\Undeclared Records Ready for Transfer
%REM
SELECT edrmsdeleteversion != "Yes"
& edrmsdeleteflag != "1"
& edrmsreviewstatus = "Ready for Transfer"
& edrmsrecord !="Yes"
%END REM
	ReDim query(3)
	query(0) = "SELECT edrmsdeleteversion != ""Yes"""
	query(1) = deleteflagnotset
	query(2) = isreadyfortransfer
	query(3) = notdeclaredrecord
	formula = remline(0) & Chr(10) & remline(1) & Chr(10) & Chr(10) &_
	query(0) & Chr(10) & query(1) & Chr(10) & query(2) & Chr(10) & query(3)
	GoSub applyformula

' VIEW 12	
' Recalculates the selection formula on the view aliased in the constant  EDRMSVIEWDELETED$ = "EDRMS9"              EDRMS\Undeclared Records Deleted Documents (Top Level)
' This view selects main documents (no responses) that have the delete flag set
%REM	
Select edrmsdeleteflag = "1" & !@IsResponseDoc
%END REM
	ReDim query(1)
	query(0) = "SELECT " & notresponsedoc
	query(1) = deleteflagset
	formula = remline(0) & Chr(10) & remline(1) & Chr(10) & Chr(10) &_
	query(0) & Chr(10) & query(1)
	GoSub applyformula
	
' VIEW 13	
' Recalculates the selection formula on the view aliased in the constant  EDRMSVIEWDEFAULT$ = "EDRMS1"   EDRMS\1. Everything
' This default  view selects all documents that are relevant to EDRMS markings
%REM	
SELECT !Form = "Valid Category":"Valid Sub-Category":"Keyword":"calendarlink":"dblink":"helpdoc":"logdoc":"Archive Profile":"template":
"ServerRedirectionLog":"DelLog":"DelAdvice":"SplashText":"DelAdviceLegacy":"DelLogLegacy":"AuditRecUpdate":"AuditRec":"ERMS Retention Period":"DelAdviceERMS":"aclprofile"
%END REM
	ReDim formselect(2)
	formselect(0) = excludedformselect(0)
	formselect(1) = excludedformselect(1)
	formselect(2) = excludedformselect(2)
	formula =  remline(0) & Chr(10) & remline(1) & Chr(10) & Chr(10) & _
	formselect(0) & formselect(1) & formselect(2)
	GoSub applyformula		

' VIEW 14	
' Recalculates the selection formula on the view aliased in the constant 	EDRMSVIEWRECSNOTREQD$ = "EDRMS10" ' EDRMS\2. Declared Records Not Required  
%REM
SELECT edrmsdeleteversion != "Yes"
& edrmsdeleteflag != "1"
& edrmsreviewstatus = "Ready for Transfer"
& edrmsrecord ="Yes"
%END REM
	ReDim query(3)
	query(0) = "SELECT edrmsdeleteversion != ""Yes"""
	query(1) = deleteflagnotset
	query(2) = isreadyfortransfer
	query(3) = isdeclaredrecord
	formula = remline(0) & Chr(10) & remline(1) & Chr(10) & Chr(10) &_
	query(0) & Chr(10) & query(1) & Chr(10) & query(2) & Chr(10) & query(3)
	GoSub applyformula

' VIEW 15	
' Recalculates the selection formula on the view aliased in the constant  EDRMSVIEWREASSIGNED$ = "EDRMS11"  EDRMS\1. Reassigned Documents
%REM
SELECT reassign_by != "" 
& edrmsreviewstatus != "Ready for Transfer"
%END REM
	ReDim query(1)
	query(0) = "SELECT reassign_by != """""
	query(1) = notreadyfortransfer
	formula = remline(0) & Chr(10) & remline(1) & Chr(10) & Chr(10) &_
	query(0) & Chr(10) & query(1)
	GoSub applyformula

' VIEW 16	
' Recalculates the selection formula on the view aliased in the constant  EDRMSVIEWTOPLEVELRECS$ = "EDRMSH6"   ' (EDRMS Records Top Level Only) 
%REM	
Select edrmsdeleteflag != "1"
& Categories!="Awaiting Deletion"
& !@IsResponseDoc
& edrmsrecord = "Yes"
%END REM
	ReDim formselect(0)
	ReDim query(3)
	formselect(0) = "SELECT " & notresponsedoc
	query(0) = deleteflagnotset
	query(1) = notawaitingdeletion
	query(2) = isdeclaredrecord
	query(3) = notreadyfortransfer
	formula = remline(0) & Chr(10) & remline(1) & Chr(10) & Chr(10) & formselect(0) & Chr(10) &_
	query(0) & Chr(10) & query(1) & Chr(10) & query(2) & Chr(10) & query(3)
	GoSub applyformula

' VIEW 17	
' Recalculates the selection formula on the view aliased in the constant  EDRMSVIEWALLDOCSINSCOPE$ = "EDRMSH7"   (EDRMS Docs In Scope No Hierarchy)
' This  view selects all documents that are relevant to EDRMS markings but with no view hierarchy so that we do not miss orphans
%REM	
SELECT !Form = "Valid Category":"Valid Sub-Category":"Keyword":"calendarlink":"dblink":"helpdoc":"logdoc":"Archive Profile":"template":
"ServerRedirectionLog":"DelLog":"DelAdvice":"SplashText":"DelAdviceLegacy":"DelLogLegacy":"AuditRecUpdate":"AuditRec":"ERMS Retention Period":"DelAdviceERMS":"aclprofile"
%END REM
	ReDim formselect(2)
	formselect(0) = excludedformselect(0)
	formselect(1) = excludedformselect(1)
	formselect(2) = excludedformselect(2)
	formula =  remline(0) & Chr(10) & remline(1) & Chr(10) & Chr(10) & _
	formselect(0) & formselect(1) & formselect(2)
	GoSub applyformula	
	
' VIEW 18
'	recalculates the selection formula for the view aliased in the constant EDRMSVIEWALLUNDECLARED$ = "EDRMSH8"   ' (EDRMS All Undeclared Documents) 	
%REM
SELECT !Form = "Valid Category":"Valid Sub-Category":"Keyword":"calendarlink":"dblink":"helpdoc":"logdoc":"Archive Profile":"template":"ServerRedirectionLog":"DelLog":"DelAdvice":"SplashText":"DelAdviceLegacy":"DelLogLegacy":"AuditRecUpdate":"AuditRec":"ERMS Retention Period":"DelAdviceERMS":"aclprofile"
& edrmsrecord !="Yes"
& edrmsdeleteflag != "1"
& edrmsreviewstatus != "Ready for Transfer"
%END REM
	ReDim formselect(2)
	ReDim query(2)
	formselect(0) = excludedformselect(0)
	formselect(1) = excludedformselect(1)
	formselect(2) = excludedformselect(2)
	query(0) = deleteflagnotset
	query(1) = notreadyfortransfer
	query(2) = notdeclaredrecord
	formula =  remline(0) & Chr(10) & remline(1) & Chr(10) & Chr(10) & _
	formselect(0) & formselect(1) & formselect(2)	& Chr(10) &_
	query(0) & Chr(10) & query(1) & Chr(10) & query(2)
	GoSub applyformula		
	
'VIEW 19
'recalculates the selection formula For the view aliased In the constant 	EDRMSVIEWALLDECLARED$ = "EDRMSH9"   (EDRMS All Declared Documents) 	
%REM
SELECT edrmsrecord = "Yes"
& edrmsdeleteflag != "1"
& edrmsreviewstatus != "Ready for Transfer"
%END REM	
	ReDim query(2)
	query(0) = "SELECT edrmsrecord = ""Yes"""
	query(1) = deleteflagnotset
	query(2) = notreadyfortransfer
	formula =  remline(0) & Chr(10) & remline(1) & Chr(10) & Chr(10) & _
	query(0) & Chr(10) & query(1) & Chr(10) & query(2)
	GoSub applyformula	
	
	logaction("Removing "  & dummyview.name)
	Call dummyview.Remove  ' remove dummy view DJS
	Call logclose("Ends OK")
	
' VIEW 20
'recalculates the selection formula For the view aliased In the constant 	EDRMSVIEWAUTODECLARE$  = "EDRMSH10"      (EDRMS Undeclared Documents Older Than Cutoff Auto Declare)
%REM	
oneyearago:= @Adjust(@TextToTime("Today");-1;0;0;0;0;0);
twoyearsago:= @Adjust(@TextToTime("Today");-2;0;0;0;0;0);
doccreated:= @If(@IsAvailable(VersionCreateDate);@Date(VersionCreateDate);@Date(@Created));
doclastmod:= @If(@IsAvailable(edrmslastmod);@Date(edrmslastmod);@Date(@Created));

SELECT Form = "Document":"ONSLetter":"Blanksheet":"AttachDoc":"LinkDoc":"URLLinkDoc"
& edrmsrecord !="Yes"
& edrmsinitialdeclaration = "Automatically Declare"
& (doccreated < twoyearsago | (doccreated > twoyearsago & doclastmod < oneyearago))
%END REM

	ReDim formselect(0)
	ReDim datepart(3)
	ReDim query(2)
	datepart(0) = oneyearagovariable
	datepart(1) = twoyearsagovariable
	datepart(2) = doccreatedvariable
	datepart(3) = doclastmodvariable
	formselect(0) = selectmaindocs
	query(0) = notdeclaredrecord
	query(1) = reacheddeclarelimit
	query(2) = autodeclare
	formula = remline(0) & Chr(10) & remline(1) & Chr(10) & Chr(10) &_
	datepart(0) & Chr(10) & datepart(1) & Chr(10) & datepart(2) & Chr(10) & datepart(3) & Chr(10) & Chr(10) &_
	formselect(0) & Chr(10) & query(0) & Chr(10) & query(1)  & Chr(10) & query(2)
	GoSub applyformula
	
' VIEW 21
'recalculates the selection formula For the view aliased In the constant  EDRMSVIEWAUTODELETE$ = "EDRMSH11"     (EDRMS Undeclared Documents Older Than Cutoff Auto Delete)
%REM
oneyearago:= @Adjust(@TextToTime("Today");-1;0;0;0;0;0);
twoyearsago:= @Adjust(@TextToTime("Today");-2;0;0;0;0;0);
doccreated:= @If(@IsAvailable(VersionCreateDate);@Date(VersionCreateDate);@Date(@Created));
doclastmod:= @If(@IsAvailable(edrmslastmod);@Date(edrmslastmod);@Date(@Created));

SELECT Form = "Document":"ONSLetter":"Blanksheet":"AttachDoc":"LinkDoc":"URLLinkDoc"
& edrmsrecord !="Yes"
& edrmsinitialdeclaration = "Automatically Delete"
& (doccreated < twoyearsago | (doccreated > twoyearsago & doclastmod < oneyearago))	
%END REM
' This is the same as View 20 immediately above with one difference - we are looking for auto delete not auto declare so only this needs alteration

	query(2) = autodelete
	formula = remline(0) & Chr(10) & remline(1) & Chr(10) & Chr(10) &_
	datepart(0) & Chr(10) & datepart(1) & Chr(10) & datepart(2) & Chr(10) & datepart(3) & Chr(10) & Chr(10) &_
	formselect(0) & Chr(10) & query(0) & Chr(10) & query(1)  & Chr(10) & query(2)
	GoSub applyformula
	
	Exit Sub
	
applyformula:
	Set view = edrmsdb.getview(views(viewindex))
	logaction("===========================================================================================")
	logaction(CStr(viewindex)& " Setting view " & view.name & " Alias " & views(viewindex) & " to :")
	logaction("===========================================================================================")
	logaction(formula)
	logaction("")
	view.SelectionFormula = formula             ' Updates the view, no save required

	Set viewsigndoc = edrmsdb.GetDocumentByUNID(view.Universalid)       ' get hold of the view design doc  by unid
	viewsigndoc.sign                                                                                                   ' sign it - crucial to stop ECL errors
	viewsigndoc.save False, False                                                                           ' save the signing 
	logaction("Signing view " & view.name & " as " & viewsigndoc.Signer)		 
	
	viewindex = viewindex +1
	Return
	
errhandle:
	Call logerror(Err, Error, Erl, LSI_Info(2), LSI_Info(12), " Last module before this call " & edrmserrortext )   ' LOGS HELPFUL DETAIL ON AN ERROR
	Call logaction(" Last Global Error " & edrmslastglobalerr)
	Call alerterrors(agent.name ,"Error")     ' EMAILS THE ERROR ALERT TO ADDRESS IN PROFILE
	Exit Sub
End Sub
Sub edrms_agent_restore_selected_deletions(agent As NotesAgent)
  On Error GoTo errhandle
	Const MODE$ = "RESTOREFROMDELETION"
	Dim ws As New NotesUIWorkspace
	Dim view As NotesView
	Dim viewdoc As NotesDocument
	Dim doc As NotesDocument
	Dim msg As String
	Dim responsereviewed As Integer
	Dim responseflag As Integer
	Dim recordflag As Integer
	Dim editorlevel As Integer
	Dim versioncount As Integer
	Dim responsemoved As Long
	Dim docsmoved As Long
	Dim replyval As Variant

	docsmoved = 0
	responsemoved = 0

	edrmserrortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	Call initlog(agent.name)

	Set edrmsdc = edrmsdb.unprocesseddocuments
	Set doc = edrmsdc.getfirstdocument

	If edrmsdc.count = 0 Then
		MessageBox "You have no documents selected.",16,edrmsdb.title &" " & EDRMSTERM$ & " Invalid Action"
		logclose("User informed no documents selected, exiting")
		Exit Sub
	End If

	Call edrms_check_responses_records(edrmsdc,responseflag,recordflag,editorlevel,versioncount)
	If responseflag = 1 Then
		MessageBox "Please restrict your selection to top level documents only. Any response documents present "+_
		"will get picked up automatically if a parent document is selected.",16,edrmsdb.title &" " & EDRMSTERM$ &" Selection Contains Response Documents"
		logclose("User has been informed that they have included responses/resp to resp/alerts and exited.")
		Exit Sub
	End If

	If editorlevel > 0 Then
		MessageBox "One or more of the selected documents have reponses to which you do not have edit access. The parent documents " &_
		" cannot therefore be restored from deletion by you. Please revise your selection before trying again.",16,edrmsdb.title &" " & EDRMSTERM$
		logaction("User informed that they are not eligible editors to all responses and exited")
		Exit Sub
	End If

	While Not doc Is Nothing
		If doc.categories(0) <> EDRMSAWDCAT$ And doc.categories(0) <> EDRMSRESTCAT$ Then
			MessageBox "This action can only be used on documents marked for deletion or restored. " + Chr(10) + Chr(10)+_
			"You have included documents not in these categories. Please amend your selection.",16,edrmsdb.title &" " & EDRMSTERM$ & " Selection Error"
			logclose("User informed this has to be run against docs marked for deletion, exiting")
			Exit Sub
		End If
		Set doc = edrmsdc.getnextdocument(doc)
	Wend

	msg = "Are you sure you want to restore the " + CStr(edrmsdc.count) + " selected documents to their original categories?"
	logaction("User prompted " & msg)
	replyval = MessageBox (msg,36,edrmsdb.title &" " & EDRMSTERM$ & " Confirmation Required")
	If replyval = 7 Then
		MessageBox "Action aborted"
		logclose("User aborted at prompt, exited")
		Exit Sub
	End If

	logaction("Passed the reasonableness tests, processing main loop")
	Set doc = edrmsdc.getfirstdocument
	While Not doc Is Nothing
		doc.deletethisdocument = "0"
		doc.Categories = doc.Origcategory
		doc.Categories_1 = doc.Origcategory_1
		doc.Origcategory = ""
		doc.OrigCategory_1 = ""

		logaction("Restoring " & doc.subject(0) & " from deletion")
		Call edrms_mark_deletion_values(doc,docsmoved,edrmscurrentuser.Abbreviated,MODE$)                 ' does the save

		logaction("Restoring response thread of " & doc.subject(0) & " from deletion")
		Call edrms_recurse_responses(doc, MODE$,"",edrmscurrentuser.Abbreviated,"",Nothing, Nothing,responsemoved,0)

		Set doc = edrmsdc.getnextdocument(doc)
	Wend

	Call edrms_deselect_docs(ws)
	Call ws.viewrefresh

	If docsmoved = 0 Then
		msg = "No documents could be restored"
	ElseIf docsmoved = 1 And responsemoved = 0 Then
		msg = "One document was restored"
	ElseIf docsmoved = 1 And responsemoved = 1 Then
		msg = "One document and one response were restored"
	ElseIf docsmoved > 1 And responsemoved = 0 Then
		msg = CStr(docsmoved) + " documents were restored"
	ElseIf docsmoved > 1 And responsemoved = 1 Then
		msg = CStr(docsmoved) + " documents and 1 response were restored"
	Else
		msg = CStr(docsmoved) + " document and " + CStr(responsemoved) + " responses restored"
	End If

	Call logclose("User informed " & msg)
	MsgBox msg,64,edrmsdb.title &" " & EDRMSTERM$ &" Restore Complete"

Exit Sub
errhandle:
Call logerror(Err, Error, Erl, LSI_Info(2), LSI_Info(12), " Last module before this call " & edrmserrortext )   ' LOGS HELPFUL DETAIL ON AN ERROR
Call logaction(" Last Global Error " & edrmslastglobalerr)
Call alerterrors(agent.name ,"Error")     ' EMAILS THE ERROR ALERT TO ADDRESS IN PROFILE
Exit Sub
End Sub
Function edrms_util_quicksort(sArray As Variant, sortorder As String)
	On Error GoTo globalerrhandle
	Dim edrms_util_quicksort_errortext As String
	Dim sA() As String
	Dim j As Long
	Dim bottom As Long
	Dim top As Long

	edrms_util_quicksort_errortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	bottom = LBound ( sArray )
	top = UBound ( sArray )
	ReDim sA( bottom To top ) As String
	For j = bottom To top
		sA ( j ) = sArray ( j )
	Next
     ' edrms_util_DoQS does a edrms_util_QuickSort if the Sublist is longer than 10 elements
     ' Thus, when edrms_util_DoQS finishes, all elements are within 10 spots of their correct location.
     ' For lists that are close to being in order, an Insertion Sort is much faster than a edrms_util_QuickSort, so we
     ' run through the whole thing once doing an Insertion Sort to finish tidying up the order.
	Call edrms_util_DoQS( sA, bottom, top )
	Call edrms_util_DoInsertSort( sA, bottom, top, sortorder )
	edrmssortedarray = sA

	Exit Function
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_util_quicksort_errortext
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Function
End Function
Sub edrms_get_db_access(accdb As NotesDatabase,dbeditor As String,dbdelete As String,useraccesslevel As Integer)
' This sub called by the script library initialise sets two globals, one indicating if the current user is an effective editor of all docs, the other
' indicating if the current user has document delete access.
	Dim edrms_get_db_access_errortext As String
	Dim accPriv As Long
	Dim x As Integer
%REM
ACLLEVEL_NOACCESS (0)
ACLLEVEL_DEPOSITOR (1)
ACLLEVEL_READER (2)
ACLLEVEL_AUTHOR (3)
ACLLEVEL_EDITOR (4)
ACLLEVEL_DESIGNER (5)
ACLLEVEL_MANAGER (6)
%END REM
	edrms_get_db_access_errortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	dbeditor = "No"
	dbdelete = "No"
	edrmsusernameslist = Evaluate("@UserNamesList")        ' could also do almost this with  notesdatabase.QueryAccessRoles(session.UserName)

' Does the current user have delete access on ACL
	accPriv = accdb.QueryAccessPrivileges(edrmscurrentuser.Canonical)
	If (accPriv And DBACL_DELETE_DOCUMENTS) > 0 Then
		dbdelete = "Yes"                                                                                       				'  delete access
	End If

' Is current user a database editor on ACL
	useraccesslevel =  accdb.CurrentAccessLevel
	If useraccesslevel > 3 Then																			' Editor Access to Database
		dbeditor = "Yes"
	End If

' Is current user a database author on ACL with a system role that promotes them to effective doc editors
	For x = LBound(edrmsusernameslist) To UBound(edrmsusernameslist)
		If(InStr(EDRMSSYSTEMROLES$, edrmsusernameslist(x)) > 0) Then		' Has system role in Authors field
			If useraccesslevel > 2 Then																	' Is at least an Author
				dbeditor = "Yes"
			End If
		End If
		If(InStr(EDRMSADMINSGROUP$, edrmsusernameslist(x)) > 0) Then		' Is member of EDRMSADMINSGROUP$
			edrmsadminsgroupmember = "Yes"
		End If
		If(InStr(EDRMSDEVELOPERGROUP$, edrmsusernameslist(x)) > 0) Then		' Is member of EDRMSDEVELOPERGROUP$
			edrmsadminsgroupmember = "Yes"
		End If
	Next
End Sub


Sub edrms_agent_refuse_undeclare_request(agent As NotesAgent)
	On Error GoTo errhandle
	Dim ws As New NotesUIWorkspace
	Dim doc As NotesDocument
	Dim msgtxt As String
	Dim responsereviewed As Integer
	Dim responseflag As Integer
	Dim recordflag As Integer
	Dim editorlevel As Integer
	Dim a As Integer

	edrmserrortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	Call initlog(agent.name)
	Set edrmsdc = edrmsdb.unprocesseddocuments
	Set doc = edrmsdc.getfirstdocument

	If edrmsdc.count = 0 Then
		MessageBox "You have no documents selected.",16,edrmsdb.title &" " & EDRMSTERM$ & " Invalid Action"
		logaction("User informed no documents selected, exiting")
		Exit Sub
	End If

	If doc.IsUIDocOpen Then
		Dim doclevel As String
		doclevel = "Yes"
	End If

	logaction("Checking for documents of type response, response to response or alert")

' TEST WHETHER RESPONSES AND DOCS NOT DECLARED AS RECORDS ARE IN THE SELECTION, ALSO CHECKS USER ACCESS
	Call edrms_check_responses_records(edrmsdc, responseflag, recordflag,editorlevel,0)

	If responseflag = 1 Then
		MessageBox "Please restrict your selection to top level documents only. Any response documents present "+_
		"will get picked up automatically if a parent document is selected.",16, edrmsdb.title &" " & EDRMSTERM$ &" Selection Contains Response Documents"
		logaction("User notified that they had selected response, response to response or alert documents, exiting")
		Exit Sub
	End If

' Make sure only declared records are selected...

	If recordflag > 0 Then
		If doclevel = "Yes" Then
			MessageBox "This document is not a declared record." ,16,edrmsdb.title &" " & EDRMSTERM$ & " Not a Declared Record"
		Else
			MessageBox "Your selection includes documents that have not been declared. Please restrict your selection to declared " +_
			"records.",16,edrmsdb.title &" " & EDRMSTERM$ &" Selection Contains Undeclared Documents"
		End If
		logaction("User notified that they had selected document(s) that are not a record, exiting")
		Exit Sub
	End If

	Set doc=edrmsdc.getfirstdocument

	While Not doc Is Nothing
		Call edrms_update_log(doc,EDRMSLOG$, "Undeclared request refused by Records Management on ",edrmscurrentuser.Abbreviated)
		logaction("Undeclared request refused by Records Management " & doc.subject(0))

		doc.edrmsundeclarepending = ""     '  Set in agent edrms_agent_undeclare_records
		Call doc.save(True,True)
		Set doc=edrmsdc.getnextdocument(doc)
	Wend

	If edrmsdc.Count = 1 Then
		If doclevel = "Yes" Then
			msgtxt = "The Undeclare request for this record has been refused"
		Else
			msgtxt = "The Undeclare request for the selected record has been refused"
		End If
	Else
		msgtxt = "The Undeclare request for " + CStr(edrmsdc.Count) & " selected records have been refused"
	End If

	Call ws.viewrefresh

	MessageBox msgtxt,64,edrmsdb.title &" " & EDRMSTERM$ &" Undeclare Refuse Action Complete"

	logclose("User informed : " & msgtxt)

	If doclevel = "Yes" Then
		Dim uidoc As NotesUIDocument
		Set uidoc=ws.currentdocument
		Call uidoc.close
		Call ws.viewrefresh
	End If

Exit Sub
errhandle:
	Call logerror(Err, Error, Erl, LSI_Info(2), LSI_Info(12), " Last module before this call " & edrmserrortext)
	Call logaction(" Last Global Error " & edrmslastglobalerr )
	Call alerterrors(agent.name ,"Error")     ' EMAILS THE ERROR ALERT TO ADDRESS IN PROFILE
	Exit Sub
End Sub


Sub edrms_check_view_paste(uiview As NotesUIView,continue As Variant)
	On Error GoTo globalerrhandle
	Dim ws As New NotesUIWorkspace
	Dim dcview As NotesDocumentCollection
	Dim doc As NotesDocument
	Dim edrms_check_view_paste_errortext As String

	edrms_check_view_paste_errortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	Call edrms_get_view_selected_docs(dcview)
	If(dcview.count = 0) Then
		continue = False
		Exit Sub
	End If

	Set doc = dcview.getfirstdocument
	While Not doc Is Nothing
		If doc.edrmsrecord(0) = "Yes" Then
			MsgBox "Declared Records cannot be copied and pasted",16,edrmsdb.title &" " & EDRMSTERM$ & " Illegal Action"
			continue = False
			Exit Sub
		Else
			If doc.isresponse Then
				MsgBox "Responses cannot be copied and pasted",16,edrmsdb.title &" " & EDRMSTERM$ & " Illegal Action"
				continue = False
				Exit Sub
			End If
		End If
		Set doc = dcview.getnextdocument(doc)
	Wend
Exit Sub
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_check_view_paste_errortext
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Sub
End Sub

Sub edrms_agent_set_categories(Agent As NotesAgent)
	On Error GoTo errhandle
	Const MODE$ = "AMENDCAT"
	Dim ws As New NotesUIWorkspace
	Dim doc As NotesDocument
	Dim uidoc As NotesUIDocument
	Dim doclevel As String
	Dim msg As String
	Dim msgtitle As String
	Dim editoraccess As String
	Dim responseflag As Integer
	Dim recordflag As Integer
	Dim versionflag As Integer
	Dim editorlevel As Integer
	Dim amendct As Integer
	Dim alreadydeclaredflag As Integer
	Dim responsecheck As Integer
	Dim responseamendct As Long
	Dim replyval As Variant
	Dim reviewdate As Variant

	amendct = 0
	responseamendct = 0
	responseflag = 0
	alreadydeclaredflag = 0
	recordflag = 0
	versionflag = 0

	edrmserrortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	Call initlog(agent.name)
	Set edrmsdc = edrmsdb.unprocesseddocuments

	Call edrms_check_responses_records(edrmsdc, responseflag, recordflag,editorlevel,versionflag)
	If responseflag = 1 Then
		MessageBox "Please restrict your selection to top level documents only. Any response documents present "+_
		"will get picked up automatically if a parent document is selected.",16,edrmsdb.title &" " & EDRMSTERM$ &" Selection Contains Response Documents"
		logclose("User has been informed that they have included responses/resp to resp/alerts and exited.")
		Exit Sub
	End If

	If editorlevel > 0 Then
		MessageBox "Some of the documents being amended have responses to which you do not have edit access. The selected documents " +_
		"will be actioned now with the edit of responses being completed overnight tonight.",64,edrmsdb.title &" " & EDRMSTERM$
		logaction("User informed that they are not eligible editors to all responses so these will be done overnight")
	End If

	If recordflag = 0 Then    ' DOCS ARE RECORDS BUT NEED TO CHECK IF CATEGORIES ARE SET
		If edrms_check_record_category(edrmsdc) <> "No" Then
			msg = "This action is designed to add " & EDRMSTERM$ &"  information to records where it is not already present. " +_
			"Your selection includes records where the fields in question already contain legitimate values. Please amend your selection."
			msgtitle = "Selection contains records where " & EDRMSTERM$ &"  Information is already present"
			MessageBox msg,16,edrmsdb.title &" " & EDRMSTERM$ &" " & msgtitle
			logclose("User informed " & msg & " and exited")
			Exit Sub
		End If
	Else
		msg = "This action is designed to add " & EDRMSTERM$ &" category information to records where it is not already present. " +_
		"Your selection includes undeclared documents, please amend your selection."
		msgtitle = "Selection contains undeclared documents"
		MessageBox msg,16,edrmsdb.title &" " & EDRMSTERM$ &" " & msgtitle
		logclose("User informed " & msg & " and exited")
		Exit Sub
	End If

	Set doc = edrmsdc.getfirstdocument
	If doc.IsUIDocOpen Then
		doclevel = "Yes"
	End If

	If edrmsdc.count = 1 Then
		If doclevel = "Yes" Then
			msg = "This action will add " & EDRMSTERM$ & " Category values to this record. Continue?"
		Else
			msg = "This action will add " & EDRMSTERM$ & " Category values to the selected record. Continue?"
		End If
	Else
		msg = "This action will add " & EDRMSTERM$ & " Category values to the " + CStr(edrmsdc.count) + " selected records. Continue?"
	End If

	Call logaction("User prompted: " & msg)
	replyval = MessageBox(msg,36,edrmsdb.title &" " & EDRMSTERM$ & " Confirmation Required")

	If replyval = 7 Then
		MessageBox "Action aborted",64,edrmsdb.title &" " & EDRMSTERM$ & " Exiting"
		Call logclose("User aborted after prompt")
		Exit Sub
	End If

	edrmsretval = edrms_choose_record_category
	If IsEmpty(edrmsretval) Then
		MsgBox "No Record Type chosen, exiting the declaration.",16,edrmsdb.title &" " & EDRMSTERM$ & " Exiting"
		Call logclose("User made no valid Record category choice, exited")
		Exit Sub
	End If
	Call logaction("User chose to apply record category " & edrmsretval)
	reviewdate = Date
	Call edrms_calculate_review_date(edrmsretval, reviewdate)
	Call logaction("Calculated review date " & CStr(reviewdate))

	Set doc = edrmsdc.getfirstdocument
	While Not doc Is Nothing
		Call edrms_get_doc_access(doc,editoraccess)   ' ALSO PUT THIS IN THE OTHER AGENT THAT DOES THIS
		If editoraccess = "Yes" Then
			Call edrms_amend_category_values(doc,CStr(edrmsretval),edrmscurrentuser.abbreviated,CStr(reviewdate))
			Call logaction("Record " & doc.subject(0) & " updated to " & edrmsretval & " review Date " & CStr(reviewdate))
			amendct = amendct + 1
			If edrms_get_thread_access(doc) = "Yes"  Then
				Call edrms_recurse_responses(doc,MODE$,CStr(edrmsretval),edrmscurrentuser.Abbreviated,CStr(reviewdate),Nothing,Nothing,responseamendct,0)
			Else
				doc.edrmsdelayedflag = 4
				Call doc.Save(True,True)
			End If
		Else
			MsgBox "You don not have editor access to " & doc.subject(0),16,edrmsdb.title &" " & EDRMSTERM$ & " Skipping"
		End If
		Set doc=edrmsdc.GetNextDocument(doc)
	Wend

	If amendct = 0 Then
		msg = "Action complete. No records were amended"
	Else
		If responseamendct = 0 Then
			If editorlevel = 0 Then
				msg = "Action complete. " + CStr(amendct) + " record(s) were amended and are now available for review"
			Else
				msg = "Action complete. " + CStr(amendct) + " record(s) were amended and will be available for review tomorrow"
			End If
		Else
			If editorlevel = 0 Then
				msg = "Action complete. " + CStr(amendct) + " record(s) and " + CStr(responseamendct) + " response(s) were amended and the main documents are now available for review"
			Else
				msg = "Action complete. " + CStr(amendct) + " record(s) and " + CStr(responseamendct) + " response(s) were amended and the main documents will be available for review tomorrow"
			End If
		End If
	End If

	MessageBox msg,64,edrmsdb.title &" " & EDRMSTERM$ & " Ends OK"
	logaction("User informed " & msg)

	If doclevel = "Yes" Then
		Set uidoc=ws.currentdocument
		Call uidoc.close
	Else
		Call edrms_deselect_docs(ws)
	End If
	Call ws.viewrefresh
	Call logclose("")

Exit Sub
errhandle:
Call logerror(Err, Error, Erl, LSI_Info(2), LSI_Info(12), " Last module before this call " & edrmserrortext )   ' LOGS HELPFUL DETAIL ON AN ERROR
Call logaction(" Last Global Error " & edrmslastglobalerr)
Call alerterrors(agent.name ,"Error")     ' EMAILS THE ERROR ALERT TO ADDRESS IN PROFILE
Exit Sub
End Sub
Function edrms_declare_set_values(doc As NotesDocument,category As String,declaredby As String)
	On Error GoTo globalerrhandle
	Dim parentdoc As NotesDocument
	Dim edrms_declare_set_values_errortext As String
	Dim reviewdate As Variant
	edrms_declare_set_values_errortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	doc.edrmsrecord = "Yes"
	doc.edrmscategory = category
	If doc.isresponse Then                           ' Inherit the declared date, declarer and review date from parent
		Set parentdoc = edrmsdb.Getdocumentbyunid(doc.Parentdocumentunid)
		doc.edrmsdate =   CDat(parentdoc.edrmsdate(0))
		doc.edrmsdeclaredby = parentdoc.edrmsdeclaredby(0)
		doc.edrmsreviewdate =  CDat(parentdoc.edrmsreviewdate(0))
	Else	
		doc.edrmsdate = Date
		doc.edrmsdeclaredby = declaredby
		reviewdate = Date$
		Call edrms_calculate_review_date(category,reviewdate)
		If InStr(reviewdate,"Error") = 0 Then              ' 0 = No Error
			doc.edrmsreviewdate =  CDat(reviewdate)
		Else
			edrmserrorstub = edrms_declare_set_values_errortext & " " & reviewdate & ".  Doc Subject : " & doc.subject(0)
			GoTo globalerrhandle
		End if
	End If
	
	If doc.hasitem(BFFIELD$) Then               ' DJS V005 19/09/2016 - Failsafe to ensure docs are not declared with a BF
		If doc.bfdate(0) <> "" Then
			doc.bfdate = ""
			doc.bfremind = ""
		End If
	End If

	Call edrms_update_log(doc,EDRMSLOG$, "Document Declared on ",declaredby)  		' log the actions
	doc.save True, False

	Exit function
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_declare_set_values_errortext
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit function
End Function
Sub edrms_create_version(doc As NotesDocument)
	On Error GoTo globalerrhandle
	
	Dim ws As New NotesUIWorkspace
	Dim resp As NotesDocumentCollection
	Dim dc As NotesDocumentCollection
	Dim respdoc As NotesDocument
	Dim newdoc As NotesDocument
	Dim responsedoc As NotesDocument	
	Dim uidoc As NotesUIDocument
	Dim rtitem As NotesRichTextItem	
	Dim origrtitem As NotesRichTextItem	
	Dim item As NotesItem
	Dim edrms_create_version_errortext As String
	Dim editoraccess As String

	edrms_create_version_errortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

	Set uidoc = ws.currentdocument

	If edrmspreventnewdocs = "Yes" Then
		MessageBox "New versions cannot be created on this database.",16, edrmsdb.title &" " & EDRMSTERM$ & " Action Not Allowed"
		Exit Sub
	End If
	
	If doc.hasitem("edrmsrecord") Then
		If doc.edrmsrecord(0) <> "Yes" Then
			MessageBox "This document is not a record",16, edrmsdb.title &" " & EDRMSTERM$ & " exiting"
			Exit Sub
		End If
	Else
		MessageBox "This document is not a record",16, edrmsdb.title &" " & EDRMSTERM$ & " exiting"
		Exit Sub
	End If
	
	'doc is the new (undeclared) version. It is, however, the original notes document with various fields reset and its version number incremented by 1
	'newdoc is the (declared) previous version created as a copy of doc before doc's fields are reset and before its version number is incremented. It therefore holds the previous version number
	'Any response that were assigned to doc get their $ref reassigned to hang off newdoc
	'If the new undeclared version is "deleted", the database querydocumentdelete event undoes all of this (oh yes!) including reassigning the $refs back

' The intention of the code here is to allow people who are an eligible author of the main doc to version it if there are no responses, otherwise they need dbadmin access DJS 15/06/2015	
	
	Set resp = doc.Responses
	Set respdoc = resp.GetFirstDocument
	If respdoc Is Nothing Then
		editoraccess = ""
		Call edrms_get_doc_access(doc,editoraccess)
		If editoraccess <> "Yes" Then
			MessageBox "You do not have author access to this document. Because of this you are not able to create a new version of it. Please contact the BDB administrator",64, edrmsdb.title &" " & EDRMSTERM$ & " Create New Version"
			Exit Sub
		End If
	Else
		If edrms_findrole("[dbadmin]") <> 1 Then
			MessageBox "You do not have DB admin or EDRMS admin rights to this database and this document has responses to which you may not have author access. Because of this you are not able to create a new version of it. Please contact the BDB administrator",64, edrmsdb.title &" " & EDRMSTERM$ & " Create New Version"
			Exit Sub
		End If
	End If
	
	If edrmsdb.server = "" Then
		MessageBox "To protect document integrity versioning can only be performed on the server, not a local replica.",64,  edrmsdb.title &" " & EDRMSTERM$ & " Create New Version"
		Exit Sub
	End If
	
	If doc.provversionno(0) >=1 Then
		MessageBox "A new version has already been taken from this record. Further versions are therefore not allowed.",64, edrmsdb.title &" " & EDRMSTERM$ & " Create New Version"
		Exit Sub
	End If
	
	Set newdoc=doc.copytodatabase(edrmsdb)
	
	' Remove EDRMS values
	Call edrms_undeclare_set_values(doc,edrmscurrentuser.Abbreviated)
	
	newdoc.clonedto = doc.universalID
	doc.clonedfrom = newdoc.universalID
	doc.VersionCreateDate = Now
	doc.VersionCreatedBy = edrmscurrentuser.Abbreviated
	Set item = doc.GetFirstItem("VersionCreatedBy")
	item.IsNames = True
	
	If Not newdoc.HasItem("version") Then
		newdoc.version = 0
	End If
	
	If newdoc.version(0) = 0 Then
		newdoc.version = newdoc.version(0) + 1
		newdoc.versionno = newdoc.version(0)
	End If
	
	If newdoc.version(0) = 0 Then
		doc.versionno = newdoc.versionno(0) + 2
	Else
		doc.versionno = newdoc.versionno(0) + 1	
	End If
	
	doc.version=doc.versionno(0)
	
	'change lastmod date to today to avoid EDRMS Notification/Deletion - Rob 30/06/2015
	doc.edrmslastmod = Today
	
	
	Set rtitem = New NotesRichTextItem( doc, "oldversionlink" )
	Call rtitem.AppendDocLink( newdoc, "Link to Old Document?" )
	
	Set origrtitem = New NotesRichTextItem( newdoc, "newversionlink" )
	Call origrtitem.AppendDocLink( doc, "Link to New Document?" )
	
'Check for responses to original document and move these to the new copy
	
	Set dc=doc.responses
	
	If dc.count > 0 Then
		Set responsedoc = dc.getfirstdocument
		While Not responsedoc Is Nothing
			Call responsedoc.makeresponse(newdoc)
			Call responsedoc.save(True,True)
			Set responsedoc = dc.getnextdocument(responsedoc)
		Wend
	End If
	
	Call newdoc.save(True,True,True)
	Call doc.save(True,True,False)
	Call ws.viewrefresh
	MessageBox "A new version of this record (version " + CStr(doc.versionno(0)) + ") has been successfully created",64, edrmsdb.title &" " & EDRMSTERM$ & " Create New Version"
	Call uidoc.close
		
Exit Sub
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_create_version_errortext
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Sub
End Sub
Sub edrms_agent_reassign_documents(Agent As NotesAgent)
	' Converted Email Text Lookups to profile on Management DB 
	On Error GoTo errhandle
	Dim ws As New NotesUIWorkspace
	Dim ncdview As NotesView
	Dim NotesUIView As NotesUIView
	Dim doc As NotesDocument
	Dim item As NotesItem
	Dim emaildoc1 As NotesDocument
	Dim emaildoc2 As NotesDocument
	Dim emaildoc3 As NotesDocument
	Dim emaildoc4 As NotesDocument
	Dim lookupdoc As NotesDocument
	Dim ncddoc As NotesDocument
	Dim uidoc As NotesUIDocument
	Dim rtitem1 As NotesRichTextItem
	Dim rtitem2 As NotesRichTextItem
	Dim rtitem3 As NotesRichTextItem
	Dim rtitem4 As NotesRichTextItem
	Dim rsnormal As NotesRichTextStyle
	Dim rs1 As NotesRichTextStyle
	Dim rs2 As NotesRichTextStyle
	Dim rs3 As NotesRichTextStyle
	Dim rs4 As NotesRichTextStyle
	Dim allocatetonn As NotesName
	Dim storedname As NotesName
	Dim storeddate As NotesDateTime
	Dim doccreationdate As NotesDateTime
	Dim howold3 As New NotesDateTime(Today) 'used to determine date 6 weeks before declaration deadline
	Dim howold4 As New NotesDateTime(Today) 'used to determine date of declaration deadline
	Dim legacyview As String
	Dim weekno As String
	Dim msg As String
	Dim msgtxt As String
	Dim storedsubject As String
	Dim versioncount As Integer
	Dim responseflag As Integer
	Dim recordflag As Integer
	Dim type1email As Integer
	Dim type2email As Integer
	Dim type3email As Integer
	Dim type4email As Integer
	Dim numrecs As Integer
	Dim sent As Integer
	Dim helperdbsret As Integer
	Dim howold1 As Long ' used to store current date
	Dim howold2 As Long ' used to store date 14 days before declaration deadline
	Dim R_emailtext1 As Variant
	Dim R_emailtext1A As Variant
	Dim R_emailtext2 As Variant
	Dim R_emailtext2A As Variant
	Dim R_emailtext3 As Variant
	Dim R_emailtext3A As Variant
	Dim R_emailtext4 As Variant
	Dim R_emailtext4A As Variant
	Dim replyval As Variant
	Dim added As Boolean

	responseflag = 0
	versioncount = 0
	recordflag = 0
	sent = 0
	added = False

	edrmserrortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	Call initlog(agent.name)
	Set NotesUIView = ws.CurrentView
	Set edrmsdc = edrmsdb.unprocesseddocuments
	Set doc = edrmsdc.getfirstdocument

	If edrmsdc.count = 0 Then
		MessageBox "No documents selected",16,edrmsdb.title &" " & EDRMSTERM$ & " Exiting"
		logclose("User informed that no documents selected and exited")
		Exit Sub
	End If

	If edrmsdbservernn.common = "" Then
		MsgBox "You are using a local replica, this process requires you are on a server database.",16,edrmsdb.title &" " & EDRMSTERM$ & " Exiting"
		logclose("User informed that they are not on a server and exited")
		Exit Sub
	End If

	Call edrms_check_responses_records(edrmsdc,responseflag,recordflag,0,versioncount)
	If responseflag = 1 Then
		MessageBox "Please restrict your selection to top level documents only. Any response documents present "+_
		"will get picked up automatically if a parent document is selected.",16,edrmsdb.title &" " & EDRMSTERM$ &" Selection Contains Response Documents"
		logclose("User has been informed that they have included responses/resp to resp/alerts and exited.")
		Exit Sub
	End If

	If recordflag <> 1 Then   ' 0 = Records, 2 = Docs and records
		msg = "This action will add a Staff Member to the Additional Editors Field on all selected records and documents and email the Staff Member with links to these records. " & Chr(10) & Chr(10) +_
		"Do you wish to continue?"
	Else
		msg = "This action will add a Staff Member to the Additional Editors Field on all selected documents and email the Staff Member with links to these documents. " & Chr(10) & Chr(10) +_
		"Do you wish to continue?"
	End If

	logaction("User prompted: " & msg)
	If MsgBox(msg,36,edrmsdb.title &" " & EDRMSTERM$ & " Add Staff Member") = 6 Then
		replyval = ws.PickListStrings(3,False,edrmsdbservernn.abbreviated,NAMESNSF$,"People",edrmsdb.title,"Choose the new people to allocate to",7)
		If IsEmpty(replyval) Then
			MsgBox "No Staff Member selected",48,edrmsdb.title &" " & EDRMSTERM$ & " Documents not amended"
			logclose("User cancelled so exiting")
			Exit Sub
		Else
			logaction("User chose to allocate to " & replyval(0))
			Set allocatetonn = New NotesName(replyval(0))
		End If
		If allocatetonn.common = "" Then
			MsgBox "No Staff Member selected",16,edrmsdb.title &" " & EDRMSTERM$ & " Documents not amended"
			logclose("User made no choice so exiting")
			Exit Sub
		End If
		
		' Call the function that gets the required external DBS
		logaction("Getting DB handles to edrmsncddb, edrmsnabdb, edrmsmetadatadb, edrmsholdingdb, edrmscountsdb")
		helperdbsret = edrms_get_helper_dbs
		If helperdbsret > 0 Then
			logaction("Error getting one or more of the required external databases, check the Lookup.nsf and the default accesses to these DBs, error code = " & CStr(helperdbsret))
			logaction("Error codes: NCD = 99, NAB = 98, EDRMS Management DB = 97, EDRMS Holding DB = 96, EDRMS Counts DB = 95")
			MsgBox "A problem was encountered accessing the external databases required for this task, this could be an access issue or a system configuration problem, please contact " & EDRMSADMINSGROUP$ ,16,edrmsdb.title &" " & EDRMSTERM$ & " Error " & CStr(helperdbsret) & " accessing external databases"
			Call alerterrors(agent.name ,"Error with external databases, error code " & CStr(helperdbsret))
			Exit Sub
		End If

		' CHECK PERSON EXISTS ON NCD
		Set ncdview = edrmsncddb.GetView(EDRMSNCDVIEW$)
		Set ncddoc = ncdview.GetDocumentByKey(allocatetonn.abbreviated)
		If ncddoc Is Nothing Then
			MsgBox allocatetonn.common & " cannot be found in NCD. Please try again",48,edrmsdb.title &" " & EDRMSTERM$ & " Unknown Staff Member"
			logclose("Failed to find " & allocatetonn.common$ & " on NCD user informed and exited")
			Exit Sub
		Else
			Set allocatetonn = New NotesName(ncddoc.NotesName(0))
		End If

		If recordflag <> 1 Then   ' 0 = Records, 2 = Docs and records
			msgtxt = CStr(edrmsdc.count) + " selected records/documents. "
			msg = "You have selected " + allocatetonn.common + " as the new owner of the " + msgtxt + "Is this correct?"
		Else
			msgtxt = CStr(edrmsdc.count) + " selected documents. "
			msg = "You have selected " + allocatetonn.common + " as the new owner of the " + msgtxt + "Is this correct?"
		End If

		logaction("User prompted " & msg)
		replyval = MessageBox (msg,36,edrmsdb.title &" " & EDRMSTERM$ & " Warning")
		If replyval = 7 Then
			MessageBox "Run aborted",64,edrmsdb.title &" " & EDRMSTERM$ & " Exiting"
			logclose("User aborted at prompt, exited")
			Exit Sub
		End If

		logaction("Calling setup emails subroutine")
		GoSub setupemails

		storedsubject = doc.subject(0)

		While Not doc Is Nothing
			If doc.Versioncreatedby(0) = "" Then
				Set storedname = New NotesName(doc.permanentauthor(0))
				Set storeddate = New NotesDateTime(doc.created)
			Else
				Set storedname = New NotesName(doc.versioncreatedby(0))
				Set storeddate = New NotesDateTime(doc.versioncreatedate(0))
			End If
			If doc.hasitem("edrmsrecord") Then
				If doc.edrmsrecord(0) = "Yes" Then
					recordflag = 1
					logaction("Document is declared as a record " & doc.subject(0))
				End If
			End If
			storedsubject = doc.subject(0)
			If doc.form(0) <> "ONSLetter" And doc.form(0) <> "Blanksheet" Then
				Set item = doc.GetFirstItem( "AuthorList" )
				If item Is Nothing Then
					Set Item = New NotesItem( doc, "AuthorList", "",AUTHORS )
				End If
			Else
				Set item = doc.GetFirstItem( "authors" )
				If item Is Nothing Then
					Set Item = New NotesItem( doc, "authors", "",AUTHORS )
				End If
			End If
			Call item.AppendToTextList(allocatetonn.canonical)
			' Following code added to convert any private documents in the collection to limited access...
			If doc.M_Secure(0) = "Private" Then
				Set item = doc.GetFirstItem( "ReadList" )
				Call item.AppendToTextList(allocatetonn.canonical)
				doc.M_Secure = "Limit Access"
				doc.scope = "Public"
			End If

			' Add fields to document to show reassignment details
			doc.Reassign_Date = Date
			doc.Reassign_By = edrmscurrentuser.Abbreviated
			doc.Reassign_To = allocatetonn.canonical

			' End of reassign code

			If doc.save(True,True) Then ' determine if line on email needs to be written in red
				howold1 = CLng(storeddate.lslocaltime)
				If howold1 < howold2 Then
					Call rtitem1.AppendStyle(rs1)
					Call rtitem2.AppendStyle(rs1)
				Else
					Call rtitem1.AppendStyle(rs3)
					Call rtitem2.AppendStyle(rs3)
				End If

				' Decide which email to send, depending on document created date (set to m_orig_date for testing)...

				If doc.hasitem("version") Then
					If doc.version(0) > 0 Then
						Set doccreationdate = New NotesDateTime(doc.versioncreatedate(0))
					Else
						Set doccreationdate = New NotesDateTime(doc.created)
					End If
				Else
					Set doccreationdate = New NotesDateTime(doc.created)
				End If

				recordflag = 0
				If doc.hasitem("edrmsrecord") Then
					If doc.edrmsrecord(0) = "Yes" Then
						recordflag = 1
					End If
				End If

				If recordflag = 1 Then
					type3email = 1
					Call logaction(doc.subject(0) & " is a Type 3")
					Call rtitem3.AppendStyle(rs3)
					Call rtitem3.AppendText("     " + storedsubject + " (created by " + storedname.common + " on " + CStr(storeddate.dateonly) + ") ===> ")
					Call rtitem3.AppendDocLink( doc, doc.allcats(0))
					Call rtitem3.addnewline(1)
					' For declared documents, write an entry to the audit table...
					Call edrms_update_log(doc,EDRMSLOG$,"Reassigned to " & allocatetonn.abbreviated & " on ", edrmscurrentuser.abbreviated)
					Call logaction(doc.subject(0) & "Reassigned to " & allocatetonn.abbreviated)
					Call doc.save(True,True)

				ElseIf CDat(doccreationdate.dateonly) >= CDat(howold4.dateonly) And CDat(doccreationdate.dateonly) < CDat(howold3.DateOnly) Then
					type1email = 1
					Call rtitem1.AppendStyle(rs3)
					Call rtitem1.AppendText("     " + storedsubject + " (created by " + storedname.common + " on " + CStr(storeddate.dateonly) + ") ===> ")
					Call rtitem1.AppendDocLink( doc, doc.allcats(0))
					Call rtitem1.addnewline(1)
					Call logaction(doc.subject(0) & " is a Type 1")

				ElseIf CDat(doccreationdate.dateonly) <= CDat(howold4.dateonly) And recordflag = 0 Then
					type2email = 1
					Call rtitem2.AppendStyle(rs3)
					Call rtitem2.AppendText("     " + storedsubject + " (created by " + storedname.common + " on " + CStr(storeddate.dateonly) + ") ===> ")
					Call rtitem2.AppendDocLink( doc, doc.allcats(0))
					Call rtitem2.addnewline(1)
					Call logaction(doc.subject(0) & " is a Type 2")
				Else
					type4email = 1
					Call rtitem4.AppendStyle(rs3)
					Call rtitem4.AppendText("     " + storedsubject + " (created by " + storedname.common + " on " + CStr(storeddate.dateonly) + ") ===> ")
					Call rtitem4.AppendDocLink( doc, doc.allcats(0))
					Call rtitem4.addnewline(1)
					Call logaction(doc.subject(0) & " is a Type 4")
				End If
				added = True
			End If

			Set doc = edrmsdc.getnextdocument(doc)
		Wend

		' Write second part of email

		Call rtitem1.AppendRTItem(R_emailtext1A)
		Call rtitem2.AppendRTItem(R_emailtext2A)
		Call rtitem3.AppendRTItem(R_emailtext3A)
		Call rtitem4.AppendRTItem(R_emailtext4A)

		If added Then
			numrecs = edrmsdc.count
			If recordflag = 1 Then
				If numrecs = 1 Then
					msg = allocatetonn.common & " has been added as an additional author on the selected record and " +_
					"a link to the record has been sent via email."
				Else
					msg = allocatetonn.common & " has been added as an additional author on the " + CStr(numrecs) & " selected " +_
					"record(s) and links to the records have been sent via email."
				End If
			Else
				If numrecs = 1 Then
					msg = allocatetonn.common & " has been added as an additional author on the selected " +_
					"document and a link to the document has been sent via email."
				Else
					msg = allocatetonn.common & " has been added as an additional author on the " + CStr(numrecs) & " selected " +_
					"documents and links to these documents have been sent via email."
				End If
			End If

			MsgBox msg,64,edrmsdb.title &" " & EDRMSTERM$ & " " & allocatetonn.common & " added"
			logaction("User informed: " & msg)

			If type1email = 1 Then
				emaildoc1.returnreceipt="1"
				Call emaildoc1.send(False,allocatetonn.abbreviated)
			End If
			If type2email = 1 Then
				emaildoc2.returnreceipt="1"
				Call emaildoc2.send(False,allocatetonn.abbreviated)
			End If
			If type3email = 1 Then
				emaildoc3.returnreceipt="1"
				Call emaildoc3.send(False,allocatetonn.abbreviated)
			End If
			If type4email = 1 Then
				emaildoc4.returnreceipt="1"
				Call emaildoc4.send(False,allocatetonn.abbreviated)
			End If

		Else
			MsgBox allocatetonn.common & " not added to documents",64,edrmsdb.title &" " & EDRMSTERM$ & " " & allocatetonn.common & " not added"
			logaction("User informed: " & allocatetonn.common & " not added to documents")
		End If

	End If

	Call edrms_deselect_docs(ws)
	Call ws.viewrefresh
	Call logclose("Ends OK")

	Exit Sub
errhandle:
	Call logerror(Err, Error, Erl, LSI_Info(2), LSI_Info(12), " Last module before this call " & edrmserrortext )   ' LOGS HELPFUL DETAIL ON AN ERROR
	Call logaction(" Last Global Error " & edrmslastglobalerr)
	Call alerterrors(agent.name ,"Error")     ' EMAILS THE ERROR ALERT TO ADDRESS IN PROFILE
	Exit Sub

setupemails:
	Set emaildoc1 = edrmsdb.createdocument ' documents created since 01/09/2007 eg already advised
	Set emaildoc2 = edrmsdb.createdocument ' documents created current legacy year
	Set emaildoc3 = edrmsdb.createdocument ' declared records
	Set emaildoc4 = edrmsdb.createdocument ' anything else eg created in last year but not yet advised
	emaildoc1.Form = "Memo"
	emaildoc2.Form = "Memo"
	emaildoc3.Form = "Memo"
	emaildoc4.Form = "Memo"
	emaildoc1.subject = edrmsmetaprofiledoc.R_emailsubject1(0) & " "  & edrmsdb.title
	emaildoc2.subject = edrmsmetaprofiledoc.R_emailsubject2(0) & " "  & edrmsdb.title
	emaildoc3.subject = edrmsmetaprofiledoc.R_emailsubject3(0) & " "  & edrmsdb.title
	emaildoc4.subject = edrmsmetaprofiledoc.R_emailsubject4(0) & " "  & edrmsdb.title
	Set rsnormal = edrmssess.CreateRichTextStyle ' default text
	rsnormal.bold=False
	rsnormal.fontsize = 10
	rsnormal.NotesColor = COLOR_BLACK
	Set rs1 = edrmssess.CreateRichTextStyle
	rs1.NotesColor = COLOR_RED
	Set rs2 = edrmssess.CreateRichTextStyle
	rs2.bold=True
	Set rs3 = edrmssess.CreateRichTextStyle
	rs3.NotesColor = COLOR_BLUE
	Set rs4 = edrmssess.CreateRichTextStyle
	rs4.NotesColor = COLOR_BLUE
	rs4.fontsize = 8
	' System checks date created on records against next parameter. If create date is earlier than this value, line on email is red,
	' otherwise line is blue.
	'  howold1 As Long ' used to store current date
	'  howold2 As Long ' used to store date 15 days before declaration deadline
	'  howold3 As New NotesDateTime(Today) 'used to determine date 6 weeks before declaration deadline
	'  howold4 As New NotesDateTime(Today) 'used to determine date of declaration deadline
	'	howold2 = (CLng(Today) - EDRMSCREATED350DAYSAGO%)

	howold2 = (CLng(Today) - (EDRMSCREATEDDAYS% + EDRMS15DAYS%))         '   howold2 As Long ' used to store date 15 days before declaration deadline
	Call howold3.adjustyear(EDRMSCREATEDYEAR%)     ' howold3 = SIX WEEKS TO DECLARE DEADLINE - FIRST SUBRACT THE YEARS
	Call howold3.adjustday( EDRMS6WEEKS%)                 ' THEN ADJUST DAYS
	Call howold4.adjustyear(EDRMSCREATEDYEAR%)                  
	
	Set R_emailtext1 = edrmsmetaprofiledoc.GetFirstItem("R_emailtext1")
	Set R_emailtext1A = edrmsmetaprofiledoc.GetFirstItem("R_emailtext1A")
	Set R_emailtext2 = edrmsmetaprofiledoc.GetFirstItem("R_emailtext2")
	Set R_emailtext2A = edrmsmetaprofiledoc.GetFirstItem("R_emailtext2A")
	Set R_emailtext3 = edrmsmetaprofiledoc.GetFirstItem("R_emailtext3")
	Set R_emailtext3A = edrmsmetaprofiledoc.GetFirstItem("R_emailtext3A")
	Set R_emailtext4 = edrmsmetaprofiledoc.GetFirstItem("R_emailtext4")
	Set R_emailtext4A = edrmsmetaprofiledoc.GetFirstItem("R_emailtext4A")
	Set rtitem1 = New NotesRichTextItem(emaildoc1,"Body")
	Set rtitem2 = New NotesRichTextItem(emaildoc2,"Body")
	Set rtitem3 = New NotesRichTextItem(emaildoc3,"Body")
	Set rtitem4 = New NotesRichTextItem(emaildoc4,"Body")
	Call rtitem1.AppendRTItem(R_emailtext1)
	Call rtitem2.AppendRTItem(R_emailtext2)
	Call rtitem3.AppendRTItem(R_emailtext3)
	Call rtitem4.AppendRTItem(R_emailtext4)
	Return

End Sub
Sub edrms_agent_amend_record_types(Agent As NotesAgent)
	On Error GoTo errhandle
	Const MODE$ = "AMENDCAT"
	Dim ws As New NotesUIWorkspace
	Dim doc As NotesDocument
	Dim msgtxt As String
	Dim msghdr As String
	Dim responseflag As Integer
	Dim responsecheck As Integer
	Dim amendct As Integer
	Dim recordflag  As Integer
	Dim editorlevel As Integer
	Dim a As Integer
	Dim cont As Variant
	Dim reviewdate As Variant
	amendct = 0
	responseflag = 0
	recordflag = 0

	edrmserrortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	Call initlog(agent.name)
	Set edrmsdc = edrmsdb.unprocesseddocuments
	Set doc = edrmsdc.getfirstdocument

	If doc.IsUIDocOpen Then
		Dim doclevel As String
		doclevel = "Yes"
	End If

	If edrmsdc.count = 1 Then
		If doclevel = "Yes" Then
			msgtxt = "This action will amend " & EDRMSTERM$ & " Record Type values on this record. Continue?"
		Else
			msgtxt = "This action will amend " & EDRMSTERM$ & " Record Type values on the selected record. Continue?"
		End If
	Else
		msgtxt = "This action will amend " & EDRMSTERM$ & " Record Type values on the " + CStr(edrmsdc.count) + " selected records. Continue?"
	End If

	cont = MessageBox(msgtxt,36,edrmsdb.title &" " & EDRMSTERM$ & " Confirmation Required")

	If cont = 7 Then
		MessageBox "Action aborted",64,edrmsdb.title &" " & EDRMSTERM$ & " Exiting"
		logaction("User cancelled at confirmation prompt")
		Exit Sub
	End If

	logaction("Checking whether selected documents contain responses/resp to resp/alerts, are records and user has access")
	' TEST WHETHER RESPONSES AND DOCS NOT DECLARED AS RECORDS ARE IN THE SELECTION, ALSO CHECKS USER ACCESS
	Call edrms_check_responses_records(edrmsdc, responseflag, recordflag,editorlevel,0)

	If responseflag = 1 Then
		MessageBox "Please restrict your selection to top level documents only. Any response documents present "+_
		"will get picked up automatically if a parent document is selected.",16,edrmsdb.title &" " & EDRMSTERM$ & " Selection Contains Response Documents"
		logaction("User informed that responses were selected")
		Exit Sub
	End If

	If editorlevel = 1 Then  ' edrms_check_responses_records now recurses responses
		MessageBox "Some of the documents being amended have responses to which you do not have edit access. The selected documents " +_
		"will be actioned now with the edit of responses being completed overnight tonight.",64,edrmsdb.title &" " & EDRMSTERM$
		logaction("User informed that they don't have editor access to some responses to selected docs")
	End If

	If recordflag > 0 Then
	If edrmsdc.Count = 1 Then
		If doclevel = "Yes" Then
			msgtxt = "This action is designed to amend " & EDRMSTERM$ & " Record Types on Declared Records. " +_
			"This document has not been declared so the requested action is not valid."
			msghdr = "Document is not a Declared Record"
		Else
			msgtxt = "This action is designed to amend " & EDRMSTERM$ & " Record Types on Declared Records. " +_
			"The document you have selected is not a declared record. Please amend your selection."
			msghdr = "The selected document is not a Declared Record"
		End If
	Else
		msgtxt = "This action is designed to amend " & EDRMSTERM$ & " Record Types on Declared Records. " +_
		"Your selection includes documents that have not been declared. Please amend your selection."
		msghdr = "Selection contains documents that are not Declared Records"
	End If
	logaction("User informed " & msghdr & " " & msgtxt & " Exiting")
	MessageBox msgtxt,16,edrmsdb.title &" " & EDRMSTERM$ & " " & msghdr
	Exit Sub
End If

	Set doc=edrmsdc.getfirstdocument

	edrmsretval = edrms_choose_record_category
	If IsEmpty(edrmsretval) Then
		MsgBox "No Record Type chosen, exiting the declaration.",16,edrmsdb.title &" " & EDRMSTERM$ & " Exiting Amend record type "
		logaction("User exited at the category choice dialog")
		Exit Sub
	End If

	If edrmsdc.count = 1 Then
		If doclevel = "Yes" Then
			msgtxt = "The Record Type of this record will be updated as follows:- " + Chr(10) + Chr(10) +_
			"From Record Type: " + doc.edrmscategory(0) +  Chr(10) +_
			"To Record Type: " + edrmsretval + Chr(10) +  Chr(10) +_
			"Are you sure you want to proceed?"
		Else
			msgtxt = "The Record Type and SubType of the selected record will be updated as follows:- " + Chr(10) + Chr(10) +_
			"From Record Type: " + doc.edrmscategory(0) +  Chr(10) +_
			"To Record Type: " + edrmsretval + Chr(10) +  Chr(10) +_
			"Are you sure you want to proceed?"
		End If
	Else
		msgtxt = "The Record Type  of the " + CStr(edrmsdc.Count) + " selected records will be updated as follows:- " + Chr(10) + Chr(10) +_
		"From Record Type: " + doc.edrmscategory(0) +  Chr(10) +_
		"To Record Type: " + edrmsretval + Chr(10) +  Chr(10) +_
		"Are you sure you want to proceed?"
	End If

	cont = MessageBox(msgtxt,36,edrmsdb.title &" " & EDRMSTERM$ & " Amend Record Types")
	logaction("User asked: "  & msgtxt)

	If cont = 7 Then
		MessageBox "Action aborted",64,edrmsdb.title &" " & EDRMSTERM$ & " Exiting"
		logaction("User exited at the prompt to go ahead and apply changes")
		Exit Sub
	End If

	edrmsrespcount = 0
	While Not doc Is Nothing
		reviewdate = doc.edrmsdate(0)               ' DATE OF DECLARATION
		Call edrms_calculate_review_date(edrmsretval,reviewdate)
		Call edrms_amend_category_values(doc,CStr(edrmsretval),edrmscurrentuser.Abbreviated,CStr(reviewdate))
		amendct = amendct + 1
		Call edrms_recurse_responses(doc,MODE$,CStr(edrmsretval),edrmscurrentuser.Abbreviated,CStr(reviewdate),Nothing,Nothing,0,0)
		Set doc = edrmsdc.GetNextDocument(doc)
	Wend

	If amendct = 0 Then
	msgtxt = "Action complete. No records were amended"
	ElseIf amendct = 1 Then
		If edrmsrespcount = 0 Then
			msgtxt = "Action complete. 1 record was amended"
		ElseIf edrmsrespcount = 1 Then
			msgtxt = "Action complete. 1 record and 1 response were amended"
		Else
			msgtxt = "Action complete. 1 record and " + CStr(edrmsrespcount) + " responses were amended"
		End If
	Else
		If edrmsrespcount = 0 Then
			msgtxt = "Action complete. " + CStr(amendct) + " records were amended"
		ElseIf edrmsrespcount = 1 Then
			msgtxt = "Action complete. " + CStr(amendct) + " records and 1 response were amended"
		Else
			msgtxt = "Action complete. " + CStr(amendct) + " records and " + CStr(edrmsrespcount) + " responses were amended"
		End If
	End If

	MessageBox msgtxt,64,edrmsdb.title &" " & EDRMSTERM$ & " Completed"
	logaction("User informed: "  & msgtxt)

	If doclevel = "Yes" Then
		Dim uidoc As NotesUIDocument
		Set uidoc=ws.currentdocument
		Call uidoc.close
	Else
		Call edrms_deselect_docs(ws)
	End If
	
	Call ws.viewrefresh

	Call logclose("")
Exit Sub
errhandle:
	Call logerror(Err, Error, Erl, LSI_Info(2), LSI_Info(12), " Last module before this call " & edrmserrortext )   ' LOGS HELPFUL DETAIL ON AN ERROR
	Call logaction(" Last Global Error " & edrmslastglobalerr)
	Call alerterrors(agent.name ,"Error")     ' EMAILS THE ERROR ALERT TO ADDRESS IN PROFILE
	Exit Sub
End Sub
%REM
	Sub edrms__changelog
	Description:  For Documenting Changes to the EDRMS code, as all code that does anything other than merely calling other code should reside here 
%END REM
Sub edrms__changelog
%REM
		Version 1 - Development code - Feb to June 2015 DJS	
%END REM
End Sub
Sub edrms_count_responses(doc As NotesDocument,respcnt As integer)
 Dim dc As NotesDocumentCollection
 Dim respdoc As NotesDocument

 Set dc = doc.Responses
 Set respdoc = dc.GetFirstDocument
 Do Until respdoc Is Nothing
	 respcnt = respcnt + 1
 	 Call edrms_count_responses(respdoc,respcnt)
 	 Set respdoc = dc.GetNextDocument(respdoc)
 Loop

End sub
Sub edrms_set_initial_declaration(uidoc As NotesUIDocument,continue As variant)
	On Error GoTo globalerrhandle
	Dim ws As New NotesUIWorkspace
	Dim edrms_set_initial_declaration_errortext As String
	Dim timeexpiry As string
	Dim initialdeclareexplanation As String
	Dim reply As Integer
	Dim category As Variant
	edrms_set_initial_declaration_errortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))

' Only prompt for  the initial declaration at first document save or new version
	If Not uidoc.isnewdoc And uidoc.document.edrmsinitialdeclaration(0) <> ""  then 
		Exit Sub
	End If
	
	timeexpiry = " 1 year after the document is last modified OR 2 years from the document's date of creation, whichever comes first."
	initialdeclareexplanation = "Automatic declaration or deletion will take place"  & timeexpiry & " If no automatic option is chosen, the document will be notified to you after this time."
	
	choice:
	edrmsretval = ws.Prompt( PROMPT_OKCANCELLIST, edrmsdb.title &" " & EDRMSTERM$ & " initial Declaration", initialdeclareexplanation ,edrmsinitialdeclaration(2), edrmsinitialdeclaration )
	If(IsEmpty(edrmsretval)) Then
			continue = False             ' Let the user abandon
			Exit Sub 
	End If

	If (edrmsretval = edrmsinitialdeclaration(0) Or edrmsretval = edrmsinitialdeclaration(3) ) Then ' Auto declaring so need to know record category
			category = ws.Prompt( PROMPT_OKCANCELLIST, edrmsdb.title &" " & EDRMSTERM$ & " Declaration", "Choose the appropriate " &  "  " & EDRMSTERM$ &  " Category",EDRMSCategories(0), EDRMSCategories )
			If Not IsEmpty(category) Then
				uidoc.document.edrmscategory = category
				uidoc.document.edrmsdeclaredby = edrmscurrentuser.abbreviated
			Else
				MsgBox "You must choose a category",16,edrmsdb.title &" " & EDRMSTERM$ & " Error"
				GoTo choice
			End If
	End If
	uidoc.document.edrmsinitialdeclaration = edrmsretval                       ' Moved here because user can abandon above 
	Call uidoc.document.save(True,False,True)
	If uidoc.Editmode then
		Call uidoc.reload    ' required because it would appear that subsequent events lose the back end
	End if 
Exit Sub
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_set_initial_declaration_errortext
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Sub
End Sub


Sub edrms_copy_document(doc As NotesDocument)
	On Error GoTo globalerrhandle
	Dim edrms_copy_document_errortext As String
	edrms_copy_document_errortext = LCase(LSI_Info(2)) & " called by " & LCase(LSI_Info(12))
	Dim newdoc As New NotesDocument(edrmsdb)
	Call doc.Copyallitems(newdoc,True)
	Call newdoc.save(False,False)
Exit Sub
globalerrhandle:
	edrmslastglobalerr = CStr(Err) & " " & CStr(Error) & " : Line Number: " & CStr(Erl) & ": " & edrmserrorstub  & " " & edrms_copy_document_errortext
	Print Time$ & " " & edrmslastglobalerr
	Error Error ' Mad but effective
	Exit Sub
End Sub
